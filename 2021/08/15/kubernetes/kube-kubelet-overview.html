<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Kubernetes Kubelet 机制概述 - 开心BOY</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="开心BOY"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="开心BOY"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="距离上一篇文章，已经过去了将近9个月的时间，2021年第一篇文章，竟然是到8月份了，真没想到这个kubelet竟然拖了我这么长时间。研究api以及scheduler的日夜还历历在目，不知不觉就过了这么长时间，现在突然写起来，恍如隔世的感觉，这一方面说明kubelet相比其他组件确实要更复杂一些，另一方面说明最近这一段时间我有些懈怠了，感觉有50%的时间在忙其他事情，25%的时间在研究kubelet"><meta property="og:type" content="blog"><meta property="og:title" content="Kubernetes Kubelet 机制概述"><meta property="og:url" content="https://hackerain.me/2021/08/15/kubernetes/kube-kubelet-overview.html"><meta property="og:site_name" content="开心BOY"><meta property="og:description" content="距离上一篇文章，已经过去了将近9个月的时间，2021年第一篇文章，竟然是到8月份了，真没想到这个kubelet竟然拖了我这么长时间。研究api以及scheduler的日夜还历历在目，不知不觉就过了这么长时间，现在突然写起来，恍如隔世的感觉，这一方面说明kubelet相比其他组件确实要更复杂一些，另一方面说明最近这一段时间我有些懈怠了，感觉有50%的时间在忙其他事情，25%的时间在研究kubelet"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hackerain.me/assets/kubernetes-kubelet-cxi.jpeg"><meta property="og:image" content="https://hackerain.me/assets/kubelet_overview.png"><meta property="og:image" content="https://hackerain.me/assets/kubelet_architecture.png"><meta property="article:published_time" content="2021-08-15T00:00:00.000Z"><meta property="article:modified_time" content="2023-03-11T15:45:44.739Z"><meta property="article:author" content="hackerain"><meta property="article:tag" content="kubernetes"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hackerain.me/assets/kubernetes-kubelet-cxi.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hackerain.me/2021/08/15/kubernetes/kube-kubelet-overview.html"},"headline":"Kubernetes Kubelet 机制概述","image":["https://hackerain.me/assets/kubelet_overview.png","https://hackerain.me/assets/kubelet_architecture.png"],"datePublished":"2021-08-15T00:00:00.000Z","dateModified":"2023-03-11T15:45:44.739Z","author":{"@type":"Person","name":"hackerain"},"publisher":{"@type":"Organization","name":"开心BOY","logo":{"@type":"ImageObject","url":"https://hackerain.me/assets/logo.jpg"}},"description":"距离上一篇文章，已经过去了将近9个月的时间，2021年第一篇文章，竟然是到8月份了，真没想到这个kubelet竟然拖了我这么长时间。研究api以及scheduler的日夜还历历在目，不知不觉就过了这么长时间，现在突然写起来，恍如隔世的感觉，这一方面说明kubelet相比其他组件确实要更复杂一些，另一方面说明最近这一段时间我有些懈怠了，感觉有50%的时间在忙其他事情，25%的时间在研究kubelet"}</script><link rel="canonical" href="https://hackerain.me/2021/08/15/kubernetes/kube-kubelet-overview.html"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="开心BOY" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/assets/logo.jpg" alt="开心BOY" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-15T00:00:00.000Z" title="8/15/2021, 12:00:00 AM">2021-08-15</time>发表</span><span class="level-item"><time dateTime="2023-03-11T15:45:44.739Z" title="3/11/2023, 3:45:44 PM">2023-03-11</time>更新</span><span class="level-item">41 分钟读完 (大约6204个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Kubernetes Kubelet 机制概述</h1><div class="content"><p>距离上一篇文章，已经过去了将近9个月的时间，2021年第一篇文章，竟然是到8月份了，真没想到这个kubelet竟然拖了我这么长时间。研究api以及scheduler的日夜还历历在目，不知不觉就过了这么长时间，现在突然写起来，恍如隔世的感觉，这一方面说明kubelet相比其他组件确实要更复杂一些，另一方面说明最近这一段时间我有些懈怠了，感觉有50%的时间在忙其他事情，25%的时间在研究kubelet，然后25%的时间在懈怠。不过还好，经过这么长时间断断续续的研究，记了很多笔记，梳理清楚了其大致脉络，对kubelet有了一个比较全面的认知，尤其是跟框架有关的，比如CRI，CNI，CSI等各种Plugin机制，知道了这些框架的原理，不论是做插件开发还是运维，都能够按图索骥，快速找到问题所在，然后再深入到具体的细节中。</p>
<span id="more"></span>

<p>其实Kubernetes跟OpenStack在资源管理这个层面上非常类似，都需要涉及到最基础的计算、网络、存储以及各种外设这些资源的管理，在计算上，OpenStack是各种虚拟机，而Kubernetes是各种容器，而这两种计算形态的不同，从本质上决定了OpenStack和Kubernetes的不同，由于容器的易封装、轻量级的特点，逐渐演化出了云原生、微服务等新形式的业务形态，而虚拟机主要还是面向传统的业务形态，OpenStack中的Nova项目通过插件机制可以支持各种虚拟化方案，比如Qemu/KVM, Xen, HyperV, 甚至还有VMWare，当然最常用的还是KVM虚拟化方案，而Kubernetes则通过CRI协议对接各种容器方案，比如最常用的docker, cri-o，还有rkt, kata container等等；至于网络，Kubernetes本身并没有实现什么具体的网络方案，而是仅仅要求Pod之间网络是可以连通的，因此Kubernetes就依赖于第三方提供的网络方案，而第三方的网络方案通过CNI协议跟Container Runtime进行交互，这其实跟OpenStack也很类似，OpenStack的Neutron项目就抽象了二层三层的网络概念供虚拟机使用，而具体的实现则依赖于底层的SDN方案，通常一个成熟的SDN方案，既有面向IaaS的，也有面向PaaS的，他们都有对应的协议标准，所以可以在某一个网络方案上同时对这两者提供服务；至于存储，更是如此，一般存储都以三种形式体现：块存储，文件存储，以及对象存储，每一种形式的存储都有很多协议去实现，比如块存储就有FC、ISCSI、RBD等协议，文件存储有NFS、CephFS等，对象存储则主要是是S3或者是Swift，有的存储系统会同时提供这三种形式的存储，有的则专门只提供一种存储，OpenStack通过Cinder, Manila等项目对接多种存储后端提供不同的存储类型，而Kubernetes则依赖于CSI协议跟第三方存储进行交互。来看看Kubernetes通过各种接口协议跟外部资源整合的图：</p>
<p><img src="/assets/kubernetes-kubelet-cxi.jpeg"></p>
<p>所以从资源管理的角度来说，Kubernetes和OpenStack是存在某些功能上的重叠的，存在一定的竞争关系，Kubernetes完全可以在没有IaaS的环境下使用，直接部署在物理机上，但是两者的定位不同，Kubernetes更偏向于应用侧，侧重于怎么使用资源，而OpenStack等IaaS平台则更侧重于对底层各种硬件资源的统一管理，这在资源隔离上差别很明显，Kubernetes在网络和计算隔离上明显不如OpenStack等IaaS平台彻底，所以更通常的做法是将Kubernetes部署在IaaS平台上，甚至是跨多个云平台部署，充分利用IaaS平台的隔离性和弹性，这样Kubernetes作为IaaS平台的资源消费者而存在，不用去管底层硬件的复杂性和多样性，并且将IaaS平台的使用者由多变的人切换到固定的程序，这对IaaS平台来说会更具确定性和稳定性，所以这两者应该是合作共生的关系，而不是取代的关系，各自在各自的领域里做自己擅长的事情。</p>
<p>Kubernetes对各种资源的使用，则主要依赖于抽象出来的三种接口协议，即CRI, CNI和CSI，在Kubernetes经典的Controller-Loop模型中，kubelet是最终的动作执行者，它部署在每个worker节点，负责当前节点Pod相关的资源生命周期管理，通过这三个接口协议跟远端的资源服务提供者进行交互。通过CRI，向远端的计算资源提供者（容器运行时，Container Runtime）申请对应的容器资源，但是在创建容器之前，先要准备容器所在网络环境，即SandBox，所谓SandBox，其实就是网络命名空间，比如是一个network namespace或者是一个虚拟机，以及在其中的网络设备和相关的网络信息，而这些网络信息则是容器运行时(Container Runtime)通过CNI接口向远端的网络资源提供者申请的，包括IP地址，路由以及DNS等信息，将这些信息配置到网络命名空间中，SandBox就准备好了，然后就可以在其中创建容器了，在同一个SandBox中可以创建多个容器，它们共享同一个网络命名空间，这些就组成了所谓的Pod；Kubelet再通过CSI接口，向远端的存储资源提供者申请对应的存储资源，根据存储类型，可能需要挂载或者格式化成文件系统供Pod使用；这里面有点特殊的就是CNI，kubelet没有直接通过CNI跟网络资源提供者交互，而是由Container Runtime来做这件事，kubelet只需要通过CRI向Container Runtime发送请求，即可获得相关的网络信息。他们之间的关系如下图：</p>
<p><img src="/assets/kubelet_overview.png"></p>
<p>CRI和CSI这两者都是使用gRPC进行的远程过程调用，gRPC是一个高性能、开源、通用的RPC框架，由Google推出，基于HTTP2协议标准设计开发，默认采用Protocol Buffers数据序列化协议，支持多种开发语言，在gRPC客户端可以直接调用不同服务器上的远程程序，使用姿势看起来就像调用本地程序一样，很容易去构建分布式应用和服务。CRI和CSI都对应的提供了一些lib库，在这些库中定义好了客户端和服务端的接口，并且实现了客户端的相关代码逻辑，以及服务端的部分逻辑，作为客户端在使用CRI和CSI时，可以直接引用这些库，向对应的服务资源提供者发送rpc请求，作为服务端，可以引用这些库，更标准和快速的实现服务端的相关逻辑。至于CNI，它就不是通过gRPC的方式了，而是由很多二进制可执行文件组成的网络插件，被Container Runtime调用执行，每个网络插件对应的实现相关的网络功能，CNI也有对应的lib库，针对它的协议，封装了一些公共代码，可以用来方便构建自己的网络插件。</p>
<p>Kubelet实现对Pod以及各种外部资源的管理，主要依赖两个机制：一个是SyncLoop，一个是各种各样的Manager。在SyncLoop中，kubelet会从几个特定的事件来源处，获取到关于Pod的事件，比如通过informer机制从apiserver处获取到的Pod的增删改事件，这些事件触发kubelet根据Pod的期望状态对本节点的Pod做出相应操作，比如新建一个Pod，或者给Pod添加一个新的存储等等，除了apiserver的事件，还有每隔1秒获取到的定期执行sync的事件，周期性的sync事件确保Pod的实际状态跟期望状态是一致的，在Kubelet的实现中，每一个Pod都对应的建了一个worker线程，在该线程中处理对该Pod的更新操作，同一个Pod不能并发进行更新，但是不同Pod是可以并发进行操作的；而各种各样的Manager则负责各种对象以及资源的管理，它们互相配合，形成一个有机的整体，是kubelet各种功能的实现者，比如secretManager/configMapManager等，它们负责从apiserver处通过reflector机制将本节点Pod绑定的secret和configmap缓存到本地，containerManager负责管理container所需要使用到的资源，比如qos, cpu, memory, device等，statusManager负责Pod状态的持续维护，会周期性的将缓存中的pod status通过apiserver更新到数据库中，volumePluginManager负责管理内置(intree)和动态发现的(flexvolume dynamic)的存储插件，csi就是作为intree的一个plugin的形式存在的，volumeManager则是负责管理本节点上的pod/volume/node的attach和mount操作的，等等这些Manager就好比人体的各种器官一样，每个器官负责一个或多个功能，各种器官协调组成一个健康的个体。整体上看，kubelet的架构图如下：</p>
<p><img src="/assets/kubelet_architecture.png"></p>
<p>SyncLoop负责Pod的增删改等操作，通过不断轮询，维护Pod这个主体跟期望状态一致，而各种Manager其实是一个个小的Loop，实现了跟Pod相关的某方面的功能，比如维护Pod在本地的缓存，以及Pod的状态的维护，Pod使用计算资源的维护，Pod使用存储资源的维护等等，这些相互配合，共同完成了kubelet完整的功能，所以，未来可能随着需求的变化，会不断有新的Manager被引入，旧的Manager被淘汰，但是总体的架构方式应该不会发生什么太大的变化。</p>
<p>下面梳理了下当前master分支，也就是1.21版本，SyncLoop的大致脉络，以及kubelet中各种Manager的作用简介：</p>
<h4 id="SyncLoop脉络"><a href="#SyncLoop脉络" class="headerlink" title="SyncLoop脉络"></a>SyncLoop脉络</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">NewKubeletCommand()</span><br><span class="line">* Run()</span><br><span class="line">    * run()</span><br><span class="line">        * PreInitRuntimeService()</span><br><span class="line">            * runDockershim()</span><br><span class="line">                * <span class="comment">// DockerService继承自CRIService，包含RuntimeServiceServer 和 ImageServiceServer 两个Interface</span></span><br><span class="line">                * ds := dockershim.NewDockerService()</span><br><span class="line">                * <span class="comment">// 创建了一个grpc.Server，并将DockerService注册到grpc.Server中</span></span><br><span class="line">                * dockerServer := dockerremote.NewDockerServer(remoteRuntimeEndpoint, ds)</span><br><span class="line">                * dockerServer.Start()</span><br><span class="line">            * <span class="comment">// 实现了grpc.Server的客户端</span></span><br><span class="line">            * kubeDeps.RemoteRuntimeService = remote.NewRemoteRuntimeService(remoteRuntimeEndpoint, ...)</span><br><span class="line">            * kubeDeps.RemoteImageService = remote.NewRemoteImageService(remoteImageEndpoint, ...)</span><br><span class="line">        * RunKubelet()</span><br><span class="line">            * k := createAndInitKubelet()</span><br><span class="line">                * NewMainKubelet()</span><br><span class="line">                    * klet := &amp;Kubelet&#123;&#125;</span><br><span class="line">                    * runtime, err := kuberuntime.NewKubeGenericRuntimeManager()</span><br><span class="line">                    * klet.containerRuntime = runtime</span><br><span class="line">                    * klet.streamingRuntime = runtime</span><br><span class="line">                    * klet.runner = runtime</span><br><span class="line">            * startKubelet(k)</span><br><span class="line">                * <span class="keyword">go</span> k.Run(podCfg.Updates())</span><br><span class="line">                    * <span class="keyword">go</span> kl.cloudResourceSyncManager.Run(wait.NeverStop)</span><br><span class="line">                    * <span class="keyword">go</span> kl.volumeManager.Run(kl.sourcesReady, wait.NeverStop)</span><br><span class="line">                        * <span class="keyword">go</span> vm.volumePluginMgr.Run(stopCh)  <span class="comment">// start informer for CSIDriver</span></span><br><span class="line">                        * <span class="keyword">go</span> vm.desiredStateOfWorldPopulator.Run(sourcesReady, stopCh)</span><br><span class="line">                        * <span class="keyword">go</span> vm.reconciler.Run(stopCh)</span><br><span class="line">                    * <span class="keyword">go</span> wait.Until(kl.syncNodeStatus, kl.nodeStatusUpdateFrequency, wait.NeverStop)</span><br><span class="line">                        * kl.registerWithAPIServer() <span class="comment">// 向apiserver创建Node对象</span></span><br><span class="line">                        * kl.updateNodeStatus()</span><br><span class="line">                            * kl.tryUpdateNodeStatus(i)</span><br><span class="line">                                * kl.setNodeStatus(node)</span><br><span class="line">                                    * defaultNodeStatusFuncs() <span class="comment">// 更新node status的各个方面</span></span><br><span class="line">                                        * NodeAddress()</span><br><span class="line">                                        * MachineInfo()</span><br><span class="line">                                        * Images()</span><br><span class="line">                                        * .......</span><br><span class="line">                                * updatedNode, _, err := nodeutil.PatchNodeStatus(kl.heartbeatClient.CoreV1(), types.NodeName(kl.nodeName), originalNode, node)</span><br><span class="line">                    * <span class="keyword">go</span> kl.fastStatusUpdateOnce()</span><br><span class="line">                        * <span class="keyword">for</span>&#123;</span><br><span class="line">                            * kl.updateRuntimeUp()</span><br><span class="line">                            * kl.syncNodeStatus()</span><br><span class="line">                        * &#125;</span><br><span class="line">                    * <span class="keyword">go</span> kl.nodeLeaseController.Run(wait.NeverStop)</span><br><span class="line">                    * <span class="keyword">go</span> wait.Until(kl.updateRuntimeUp, <span class="number">5</span>*time.Second, wait.NeverStop)</span><br><span class="line">                        * 检查networkReady和runtimeReady，并且将状态设置到runtimeState中</span><br><span class="line">                        * kl.oneTimeInitializer.Do(kl.initializeRuntimeDependentModules)</span><br><span class="line">                            * kl.cadvisor.Start()</span><br><span class="line">                            * kl.containerManager.Start(node, kl.GetActivePods, kl.sourcesReady, kl.statusManager, kl.runtimeService)</span><br><span class="line">                                * cm.cpuManager.Start()</span><br><span class="line">                                * cm.memoryManager.Start()</span><br><span class="line">                                * cm.setupNode(activePods) <span class="comment">// container_manager_linux.go</span></span><br><span class="line">                                    * <span class="keyword">if</span> CgroupsPerQOS</span><br><span class="line">                                        * cm.createNodeAllocatableCgroups()  <span class="comment">// node_container_manager_linux.go</span></span><br><span class="line">                                        * cm.qosContainerManager.Start(cm.getNodeAllocatableAbsolute, activePods) <span class="comment">// qos_container_manager_linux.go</span></span><br><span class="line">                                            * <span class="keyword">go</span> m.UpdateCgroups()</span><br><span class="line">                                    * cm.enforceNodeAllocatableCgroups() <span class="comment">// node_container_manager_linux.go</span></span><br><span class="line">                                * cm.deviceManager.Start()</span><br><span class="line">                            * kl.evictionManager.Start(kl.StatsProvider, kl.GetActivePods, kl.podResourcesAreReclaimed, evictionMonitoringPeriod)</span><br><span class="line">                            * kl.containerLogManager.Start()</span><br><span class="line">                            * kl.pluginManager.AddHandler(pluginwatcherapi.CSIPlugin, plugincache.PluginHandler(csi.PluginHandler))</span><br><span class="line">                            * kl.pluginManager.AddHandler(pluginwatcherapi.DevicePlugin, kl.containerManager.GetPluginRegistrationHandler())</span><br><span class="line">                            * <span class="keyword">go</span> kl.pluginManager.Run(kl.sourcesReady, wait.NeverStop)</span><br><span class="line">                            * err = kl.shutdownManager.Start()</span><br><span class="line">                    * <span class="keyword">go</span> wait.Until(kl.podKiller.PerformPodKillingWork, <span class="number">1</span>*time.Second, wait.NeverStop)</span><br><span class="line">                    * kl.statusManager.Start()</span><br><span class="line">                    * kl.probeManager.Start()</span><br><span class="line">                    * kl.runtimeClassManager.Start(wait.NeverStop)</span><br><span class="line">                    * kl.pleg.Start()</span><br><span class="line">                    * kl.syncLoop(updates, kl)</span><br><span class="line">                        * <span class="keyword">for</span>&#123;</span><br><span class="line">                            * kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh)</span><br><span class="line">                                * HandlePodAdditions()</span><br><span class="line">                                * HandlePodUpdates()</span><br><span class="line">                                * HandlePodRemoves()</span><br><span class="line">                                * HandlePodSyncs()</span><br><span class="line">                                    * <span class="comment">//  1. Compute sandbox and container changes.</span></span><br><span class="line">                                    * <span class="comment">//  2. Kill pod sandbox if necessary.</span></span><br><span class="line">                                    * <span class="comment">//  3. Kill any containers that should not be running.</span></span><br><span class="line">                                    * <span class="comment">//  4. Create sandbox if necessary.</span></span><br><span class="line">                                    * <span class="comment">//  5. Create ephemeral containers.</span></span><br><span class="line">                                    * <span class="comment">//  6. Create init containers.</span></span><br><span class="line">                                    * <span class="comment">//  7. Create normal containers</span></span><br><span class="line">                                    * syncPod(o syncPodOptions)   <span class="comment">// kubelet.go,  在podWorkers中执行这个syncPod</span></span><br><span class="line">                                        * pcm := kl.containerManager.NewPodContainerManager()</span><br><span class="line">                                            * <span class="keyword">if</span> CgroupsPerQOS</span><br><span class="line">                                                * <span class="keyword">return</span> podContainerManagerImpl</span><br><span class="line">                                            * <span class="keyword">return</span> podContainerManagerNoop</span><br><span class="line">                                        * kl.containerManager.UpdateQOSCgroups()</span><br><span class="line">                                            * cm.qosContainerManager.UpdateCgroups()</span><br><span class="line">                                        * pcm.EnsureExists(pod)</span><br><span class="line">                                        * kl.containerRuntime.SyncPod(pod, podStatus, pullSecrets, kl.backOff)</span><br><span class="line">                                            * <span class="comment">//  1. Compute sandbox and container changes.</span></span><br><span class="line">                                            * podContainerChanges := m.computePodActions(pod, podStatus)</span><br><span class="line">                                            * <span class="comment">//  2. Kill pod sandbox if necessary.</span></span><br><span class="line">                                            * m.killContainersWithSyncResult(pod, runningPod, gracePeriodOverride)</span><br><span class="line">                                            * m.runtimeService.StopPodSandbox(podSandbox.ID.ID)</span><br><span class="line">                                            * <span class="comment">//  3. Kill any containers that should not be running.</span></span><br><span class="line">                                            *  m.killContainer(pod,...)</span><br><span class="line">                                            * <span class="comment">//  4. Create sandbox if necessary.</span></span><br><span class="line">                                            * <span class="comment">// pod的网络是在建sandbox时建立的，sandbox可以理解成linux network namespace或者vm，即准备一个隔离环境</span></span><br><span class="line">                                            * m.createPodSandbox(pod, podContainerChanges.Attempt)</span><br><span class="line">                                                * m.runtimeService.RunPodSandbox(podSandboxConfig, runtimeHandler)</span><br><span class="line">                                            * <span class="comment">//  5. Create ephemeral containers.</span></span><br><span class="line">                                            * doBackOff()</span><br><span class="line">                                            * startContainer()  <span class="comment">// kuberuntime_container.go</span></span><br><span class="line">                                                * <span class="comment">// * pull the image</span></span><br><span class="line">                                                * m.imagePuller.EnsureImageExists(pod, container, pullSecrets, podSandboxConfig)</span><br><span class="line">                                                * <span class="comment">// * create the container</span></span><br><span class="line">                                                * m.runtimeService.CreateContainer(podSandboxID, containerConfig, podSandboxConfig)</span><br><span class="line">                                                * <span class="comment">// * start the container</span></span><br><span class="line">                                                * m.runtimeService.StartContainer(containerID)</span><br><span class="line">                                                * <span class="comment">// * run the post start lifecycle hooks (if applicable)</span></span><br><span class="line">                                                * m.runner.Run(kubeContainerID, pod, container, container.Lifecycle.PostStart)</span><br><span class="line">                                            * <span class="comment">//  6. Create init containers.</span></span><br><span class="line">                                            * doBackOff()</span><br><span class="line">                                            * startContainer()  <span class="comment">// kuberuntime_container.go</span></span><br><span class="line">                                            * <span class="comment">//  7. Create normal containers.</span></span><br><span class="line">                                            * doBackOff()</span><br><span class="line">                                            * startContainer()  <span class="comment">// kuberuntime_container.go</span></span><br><span class="line">                        * &#125;</span><br><span class="line">                * <span class="keyword">go</span> k.ListenAndServe(kubeCfg, kubeDeps.TLSOptions, kubeDeps.Auth, enableCAdvisorJSONEndpoints)</span><br><span class="line">                * <span class="keyword">go</span> k.ListenAndServeReadOnly(net.ParseIP(kubeCfg.Address), <span class="type">uint</span>(kubeCfg.ReadOnlyPort), enableCAdvisorJSONEndpoints)</span><br><span class="line">                * <span class="keyword">go</span> k.ListenAndServePodResources()</span><br></pre></td></tr></table></figure>

<h4 id="各种Manager"><a href="#各种Manager" class="headerlink" title="各种Manager"></a>各种Manager</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">* cloudResourceSyncManager</span><br><span class="line">    * pkg/kubelet/cloudresource/cloud_request_manager.go</span><br><span class="line">    * 从cloud provider周期性的同步instnace列表到本地</span><br><span class="line">* secretManager</span><br><span class="line">    * pkg/kubelet/secret/secret_manager.go</span><br><span class="line">    * NewWatchingSecretManager</span><br><span class="line">    * 当一个pod在本节点注册时，会将该pod绑定的secret通过reflector机制缓存到本地</span><br><span class="line">* configMapManager</span><br><span class="line">    * pkg/kubelet/configmap/configmap_manager.go</span><br><span class="line">    * NewWatchingConfigMapManager</span><br><span class="line">    * 当一个Pod在本节点注册时，会将该pod绑定的configmap通过reflector机制缓存到本地</span><br><span class="line">* livenessManager</span><br><span class="line">    * pkg/kubelet/prober/results/results_manager.go</span><br><span class="line">    * Manager</span><br><span class="line">    * set/get某个container在本地缓存中的的liveness状态</span><br><span class="line">* startupManager</span><br><span class="line">    * pkg/kubelet/prober/results/results_manager.go</span><br><span class="line">    * Manager</span><br><span class="line">    * set/get某个container在本地缓存中的startup缓存状态</span><br><span class="line">* podCache</span><br><span class="line">    * pkg/kubelet/container/cache.go</span><br><span class="line">    * cache</span><br><span class="line">    * 各个pods的PodStatus缓存</span><br><span class="line">* podManager</span><br><span class="line">    * pkg/kubelet/pod/pod_manager.go</span><br><span class="line">    * basicManager</span><br><span class="line">    * Kubelet relies on the pod manager as the source of truth for the desired state.</span><br><span class="line">    * 管理pod在本地的映射，从podUID或者是podFullName到pod的映射关系</span><br><span class="line">    * mirrorPod是static pod在apiserver中的代表对象，static pod就是从file, http等source创建的pod，不是从apiserver中直接创建的，这种pod会对应的在apiserver中创建一个mirror pod，跟static pod对应</span><br><span class="line">* statusManager</span><br><span class="line">    * pkg/kubelet/status/status_manager.go</span><br><span class="line">    * manager</span><br><span class="line">    * pod status状态的管理，同时维护了一份本地的缓存，并且有一个周期性的sync任务，将缓存中的pod status跟通过apiserver跟数据库中的pod status进行同步</span><br><span class="line">    * 实现了GetPodStatus()、SetPodStatus()、SetContainerReadiness()等方法</span><br><span class="line">    * 这里有一个很经典的chan的用法，异步的实现缓存和数据库的同步</span><br><span class="line">* resourceAnalyzer</span><br><span class="line">    * pkg/kubelet/server/stats/resource_analyzer.go</span><br><span class="line">    * resourceAnalyzer&#123;fsResourceAnalyzer, SummaryProvider&#125;</span><br><span class="line">    * SummaryProvider提供该node节点的cpu/内存/磁盘/网络/pods等信息，而fsResourceAnalyzer，则提供每个pod的volume信息，并且通过每个pod的周期性循环任务，将该节点上所有pod的volume信息缓存到本地statCache中</span><br><span class="line">* dockerLegacyService</span><br><span class="line">    * DockerService</span><br><span class="line">* runtimeService</span><br><span class="line">    * remoteRuntimeService，实现了k8s.io/cri-api项目中定义的RuntimeService接口，而它又是调用了k8s.io/cri-api中定义的runtimeServiceClient，它客户端实现了grpc的调用。</span><br><span class="line">    * grpc.Server的客户端，用来跟remote runtime service发送请求</span><br><span class="line">* containerLogManager</span><br><span class="line">* containerManager</span><br><span class="line">    * 路径：kubernetes/pkg/kubelet/cm/*</span><br><span class="line">    * 该manager并不是针对container本身的管理，而更多的是管理container所需要使用的资源的管理，比如qos, cpu, memory, device等</span><br><span class="line">    * cgroupManager</span><br><span class="line">        * 跟cgroup交互的manager，通过它来对cgroup进行更新，被qosContainerManager引用</span><br><span class="line">    * qosContainerManager</span><br><span class="line">        * 设置/kubepods.slice/kubepods-burstable.slice 和 /kubepods.slice/kubepods-besteffort.slice级别的cgroup</span><br><span class="line">        * besteffort级别的cpu.shares设置为固定值2，burstable级别的cpu.shares设置为该节点的所有pods的request cpu之和</span><br><span class="line">        * 此外还有hugepage, memory的设置，这里设置的是总的qos，并不是单个pod的</span><br><span class="line">        * 有一个周期性循环的任务在不断更新这两个cgroup</span><br><span class="line">    * podContainerManager</span><br><span class="line">        * 设置pod级别的cgroup，包括cpu, memory, hugepage, pids</span><br><span class="line">        * container级别的cgroup规则是由cri runtime下发的，kubelet没有直接下发</span><br><span class="line">    * cpuManager</span><br><span class="line">        * 可以为containder设置静态cpuset，即进行CPU绑定</span><br><span class="line">        * The static policy allows containers in Guaranteed pods with integer CPU requests access to exclusive CPUs on the node.</span><br><span class="line">        * https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/</span><br><span class="line">    * memoryManager</span><br><span class="line">        * 跟topologyManager一起配合使用</span><br><span class="line">    * deviceManager</span><br><span class="line">    * topologyManager</span><br><span class="line">        * 能够让container感知各种外设(gpu/sr-iov nic)和CPU，与NUMA node的关系，可以将设备绑定到同一个NUMA node上，以提高性能。</span><br><span class="line">        * https://kubernetes.io/blog/2020/04/01/kubernetes-1-18-feature-topoloy-manager-beta/</span><br><span class="line">* containerRuntime</span><br><span class="line">    * kubeGenericRuntimeManager，实现了container/runtime.go中定义的Runtime接口</span><br><span class="line">    * Kubelet的Runtime Manager，通过runtimeService来向remote runtime进行交互，各个manager要跟runtime交互，都是通过该接口</span><br><span class="line">* streamingRuntime</span><br><span class="line">* runner</span><br><span class="line">* runtimeCache</span><br><span class="line">    * runtimeCache &#123;pods []*Pod&#125;</span><br><span class="line">    * pod的本地缓存，从runtime里面拿到pods列表，更新到本地缓存中</span><br><span class="line">* StatsProvider</span><br><span class="line">* pleg(Pod Lifecycle Event Generator)</span><br><span class="line">    * GenericPLEG</span><br><span class="line">    * https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md</span><br><span class="line">    * https://developers.redhat.com/blog/2019/11/13/pod-lifecycle-event-generator-understanding-the-pleg-is-not-healthy-issue-in-kubernetes/</span><br><span class="line">    * 它的作用是周期性从container runtime中获取到pods/containers列表，即relist，跟之前的状态进行比较，如果发生变化，则生成一个对应的event</span><br><span class="line">* runtimeState</span><br><span class="line">    * 检查container runtime的storage/network/runtime的状态</span><br><span class="line">* containerGC</span><br><span class="line">    * 清理不正常的container</span><br><span class="line">* containerDeletor</span><br><span class="line">    * podContainerDeletor</span><br><span class="line">    * 通过channel的方式异步删除container，即外部调用deleteContainersInPod()方法，将待删除的container id放入到channel中，然后调用runtime中的DeleteContainer()方法，向runtime发送删除请求</span><br><span class="line">* imageManager</span><br><span class="line">    * realImageGCManager</span><br><span class="line">    * 根据镜像占用的文件系统的百分比，删除没有用的镜像</span><br><span class="line">* serverCertificateManager</span><br><span class="line">    * 动态rotate kubelet server certificate</span><br><span class="line">* probeManager</span><br><span class="line">    * 针对每一个Pod中的每一个container的startup/readiness/liveness这三种probe，分别建一个周期性循环的worker任务，不断通过其定义的probe条件进行检查，将检查的结果更新到startupManager/readinessManager/livenessManager中，这三个Manager是同一个类型的Manager，通过其Set()方法，将probe的结果放到updates channel中，probeManager周期性的从readniessManager和startupManager的Updates channel中读取result，然后通过statusManager的SetContainerReadiness()和SetContainerStartup()方法将结果同步到statusManager中，然后statusManager再将结果异步同步到apiserver</span><br><span class="line">    * 以上的逻辑涉及到probeManager，statusManager, startupManager, readniessManager, livenessManager这几个manager的相互协作。</span><br><span class="line">* tokenManager</span><br><span class="line">    * 获取ServiceAccountToken，缓存到本地，通过GetServiceAccountToken()先从cache中找token，如果过期了，则从TokenRequest API中重新获取新的token</span><br><span class="line">* volumePluginMgr</span><br><span class="line">    * VolumePluginMgr</span><br><span class="line">        * plugins  map[string]VolumePlugin</span><br><span class="line">        * probedPlugins  map[string]VolumePlugin</span><br><span class="line">    * 管理intree和flexvolume dynamic的VolumePlugin，csi也是作为intree的一个plugin的形式存在的，所谓管理就是自动发现，注册，查找VolumePlugin。</span><br><span class="line">    * 在volumeManager中，会根据各种条件查找注册到volumePluginMgr中的VolumePlugin</span><br><span class="line">    * flexvolume动态发现插件的默认目录：/usr/libexec/kubernetes/kubelet-plugins/volume/exec/，由配置项VolumePluginDir进行配置</span><br><span class="line">* pluginManager</span><br><span class="line">    * 主要是来注册CSIPlugin和DevicePlugin</span><br><span class="line">    * 这里面主要有两个loop: desiredStateOfWorldPopulator 和 reconciler</span><br><span class="line">        * 前者是通过fsnotify watch机制从插件目录发现csi的socket文件，默认路径在/var/lib/kubelet/plugins_registry/，然后将其信息添加到desiredStateOfWorld结构中；</span><br><span class="line">        * 后者会去对比actualStateOfWorld 和 desiredStateOfWorld中记录的插件注册的情况，desiredStateOfWorld是全部期望注册的插件，而actualStateOfWorld则是全部已经注册的插件，如果没注册的，则会调用operationExecutor去注册，如果需要插件已经没删除，则调用operationExecutor去删除注册；</span><br><span class="line">    * operationExecutor是用来执行注册方法的执行器，本质上就是通过goroutine去执行注册方法，而operationGenerator则是注册方法生成器，在该注册方法中，首先通过该socket建立了一个grpc的客户端，通过向该socket发送grpc请求，即client.GetInfo()，获取到该CSI插件的信息，根据该插件的种类(CSIPlugin或者是DevicePlugin)，来调用相应的handler，来进一步进行注册，首先要handler.ValidatePlugin()，然后handler.RegisterPlugin()，handler是在服务启动时，添加到pluginManager中的。</span><br><span class="line">    * 如果是CSIPlugin的话，其注册流程大致如下：</span><br><span class="line">        * 主要代码逻辑在 kubernetes/pkg/volume/csi/ 路径下</span><br><span class="line">        * 首先根据插件的socket文件，初始化一个csi的grpc client，用来跟csi server进行交互</span><br><span class="line">            * csi rpc client又引用了container-storage-interface项目中定义的csi protobuffer协议的接口</span><br><span class="line">        * 发送csi.NodeGetInfo() rpc请求，获取到本节点的相关信息 //NodeGetInfo()即是CSI规范定义的接口</span><br><span class="line">        * 接下来，通过nim，即nodeInfoManager（这个是在volumePluginMgr在进行插件初始化的时候实例化的），继续进行注册，主要分为两步：</span><br><span class="line">            * 更新本节点的Node对象，添加csi相关的annotation和labels</span><br><span class="line">            * 创建或者更新本节点对应的CSINode对象，里面包含了该node的CSI插件信息，主要是包含插件的名字</span><br><span class="line">* volumeManager</span><br><span class="line">    * 是用来管理本node上的pod/volume/node的attach 和 mount 操作的</span><br><span class="line">    * DesiredStateOfWorldPopulator 周期性的从podManager中获取本node的Pod列表，然后遍历pod列表，获取到每个pod的Volumes，遍历每个volume，获取到详细的信息，然后添加到desiredStateOfWorld中，desiredStateOfWorld用以下的数据结构记录本节点的所有pod的所有volume信息，包括该volume是否可挂载，可mount，以及所属的pod，而且某个volume可能属于多个pod</span><br><span class="line">        * desiredStateOfWorld</span><br><span class="line">            * volumesToMount map[v1.UniqueVolumeName]volumeToMount</span><br><span class="line">            * volumePluginMgr *volume.VolumePluginMgr</span><br><span class="line">        * volumeToMount</span><br><span class="line">            * volumeName v1.UniqueVolumeName</span><br><span class="line">            * podsToMount map[types.UniquePodName]podToMount</span><br><span class="line">            * pluginIsAttachable bool</span><br><span class="line">            * pluginIsDeviceMountable bool</span><br><span class="line">            * volumeGidValue string</span><br><span class="line">        * podToMount</span><br><span class="line">            * podName types.UniquePodName</span><br><span class="line">            * pod *v1.Pod</span><br><span class="line">            * volumeSpec *volume.Spec</span><br><span class="line">    * OperatorGenerator是从volume对应的VolumePlugin中获取到对应的AttachVolume/MountVolume等具体实现方法</span><br><span class="line">    * OperatorExecutor会在goroutine中调用OperatorGenerator中的方法去执行具体的动作</span><br><span class="line">    * reconciler会周期性的从desiredStateOfWorld中获取到需要进行Attach或者Mount的Volume，然后调用OperatorExecutor来执行具体的Attach/Mount操作</span><br><span class="line">        * rc.unmountVolumes()</span><br><span class="line">            * // Filesystem volume case</span><br><span class="line">            * volumePlugin, err := og.volumePluginMgr.FindPluginByName(volumeToUnmount.PluginName)</span><br><span class="line">            * volumeUnmounter, newUnmounterErr :=volumePlugin.NewUnmounter()</span><br><span class="line">            * unmountErr := volumeUnmounter.TearDown()</span><br><span class="line">            * // Block volume case</span><br><span class="line">            * blockVolumePlugin, err := og.volumePluginMgr.FindMapperPluginByName(volumeToUnmount.PluginName)</span><br><span class="line">            * blockVolumeUnmapper, newUnmapperErr := blockVolumePlugin.NewBlockVolumeUnmapper()</span><br><span class="line">            * customBlockVolumeUnmapper, ok := blockVolumeUnmapper.(volume.CustomBlockVolumeUnmapper)</span><br><span class="line">            * unmapErr = customBlockVolumeUnmapper.UnmapPodDevice()</span><br><span class="line">        * rc.mountAttachVolumes()</span><br><span class="line">            * // if volume is not attached</span><br><span class="line">            * attachableVolumePlugin, err := og.volumePluginMgr.FindAttachablePluginBySpec(volumeToAttach.VolumeSpec)</span><br><span class="line">            * volumeAttacher, newAttacherErr := attachableVolumePlugin.NewAttacher()</span><br><span class="line">            * devicePath, attachErr := volumeAttacher.Attach()</span><br><span class="line">            * // if volume is not mounted</span><br><span class="line">                * // Filesystem volume case</span><br><span class="line">                * volumePlugin, err := og.volumePluginMgr.FindPluginBySpec(volumeToMount.VolumeSpec)</span><br><span class="line">                * volumeMounter, newMounterErr := volumePlugin.NewMounter()</span><br><span class="line">                * attachableVolumePlugin, _ := og.volumePluginMgr.FindAttachablePluginBySpec(volumeToMount.VolumeSpec)</span><br><span class="line">                * volumeAttacher, _ = attachableVolumePlugin.NewAttacher()</span><br><span class="line">                * deviceMountableVolumePlugin, _ := og.volumePluginMgr.FindDeviceMountablePluginBySpec(volumeToMount.VolumeSpec)</span><br><span class="line">                * volumeDeviceMounter, _ = deviceMountableVolumePlugin.NewDeviceMounter()</span><br><span class="line">                * devicePath, err = volumeAttacher.WaitForAttach()</span><br><span class="line">                * err = volumeDeviceMounter.MountDevice()</span><br><span class="line">                * mountErr := volumeMounter.SetUp()</span><br><span class="line">                * // Block volume case</span><br><span class="line">                * blockVolumePlugin, err := og.volumePluginMgr.FindMapperPluginBySpec(volumeToMount.VolumeSpec)</span><br><span class="line">                * blockVolumeMapper, newMapperErr := blockVolumePlugin.NewBlockVolumeMapper()</span><br><span class="line">                * attachableVolumePlugin, _ := og.volumePluginMgr.FindAttachablePluginBySpec(volumeToMount.VolumeSpec)</span><br><span class="line">                * volumeAttacher, _ = attachableVolumePlugin.NewAttacher()</span><br><span class="line">                * devicePath, err = volumeAttacher.WaitForAttach()</span><br><span class="line">                * customBlockVolumeMapper, ok := blockVolumeMapper.(volume.CustomBlockVolumeMapper);</span><br><span class="line">                * stagingPath, mapErr = customBlockVolumeMapper.SetUpDevice()</span><br><span class="line">                * pluginDevicePath, mapErr := customBlockVolumeMapper.MapPodDevice()</span><br><span class="line">        * rc.unmountDetachDevices()</span><br><span class="line">    * 所以，具体的Attach/Mount逻辑是在对应的VolumePlugin中实现的</span><br><span class="line">* podWorkers</span><br><span class="line">    * klet.podWorkers = newPodWorkers(klet.syncPod, kubeDeps.Recorder, klet.workQueue, klet.resyncInterval, backOffPeriod, klet.podCache)</span><br><span class="line">    * podUpdates map[types.UID]chan UpdatePodOptions  // 每个pod对应了一个chan，里面保存了针对该pod的更新选项</span><br><span class="line">    * 每一个pod有一个loop，当有对该pod的更新操作时，该loop就会被触发执行syncPod()方法，每个pod同时只能有一个syncPod()动作在执行</span><br><span class="line">* podKiller</span><br><span class="line">    * 删除pod</span><br><span class="line">* evictionManager</span><br><span class="line">    * Eviction，就是当节点的内存，磁盘，pid这几个资源压力大时，会选择性的将一些Pod kill掉，以保持资源足够维持系统稳定</span><br><span class="line">* admitHandlers</span><br><span class="line">    * 在kubelet创建pod时，会依次调用admit handler去检查该pod是否符合创建条件，如果不符合的话，则会返回相应的错误信息</span><br><span class="line">* softAdmitHandlers</span><br><span class="line">    * softAdmithandlers are applied to the pod after it is admitted by the Kubelet, but before it is run.</span><br><span class="line">    * A pod rejected by a softAdmitHandler will be left in a Pending state indefinitely.</span><br><span class="line">* nodeLeaseController</span><br><span class="line">    * node的心跳机制，每个node都在apiserver中创建了一个Lease对象，每隔10秒，kubelet就会更新它对应的Lease对象，类似于租约续期</span><br><span class="line">    * 除了Lease这种心跳机制，还有NodeStatus，kubelet也会周期性的更新NodeStatus，不过这个间稍长，默认是5分钟</span><br><span class="line">* shutdownManager</span><br></pre></td></tr></table></figure></div><div class="article-licensing box"><div class="licensing-title"><p>Kubernetes Kubelet 机制概述</p><p><a href="https://hackerain.me/2021/08/15/kubernetes/kube-kubelet-overview.html">https://hackerain.me/2021/08/15/kubernetes/kube-kubelet-overview.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>hackerain</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-08-15</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-03-11</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/kubernetes/">kubernetes</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/09/07/kubernetes/kube-kubelet-cri.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Kubernetes Kubelet CRI 机制解析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/12/21/kubernetes/kube-scheduler-framework.html"><span class="level-item">Kubernetes Scheduler Scheduling Framework</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/assets/avatar.jpg" alt="开心BOY"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">开心BOY</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">42</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="/about" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/hackerain"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="知识星球" href="https://t.zsxq.com/0bWmBFDpu"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#SyncLoop脉络"><span class="level-left"><span class="level-item">1</span><span class="level-item">SyncLoop脉络</span></span></a></li><li><a class="level is-mobile" href="#各种Manager"><span class="level-left"><span class="level-item">2</span><span class="level-item">各种Manager</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-28T00:00:00.000Z">2023-10-28</time></p><p class="title"><a href="/2023/10/28/kubernetes/kube-scheme.html">Kubernetes Scheme 解析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-26T00:00:00.000Z">2022-09-26</time></p><p class="title"><a href="/2022/09/26/elasticsearch/elasticsearch_large_text_field.html">Elasticsearch大文本字段(large text field)优化方案</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-08-07T10:52:55.000Z">2022-08-07</time></p><p class="title"><a href="/2022/08/07/umi/umi.html">UMI框架解析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-19T22:12:55.000Z">2021-11-19</time></p><p class="title"><a href="/2021/11/19/openstack/openstack_uvw_highlight.html">OpenStack Ussuri-Victoria-Wallaby版本新功能介绍</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-19T22:03:55.000Z">2021-11-19</time></p><p class="title"><a href="/2021/11/19/openstack/openstack_rst_highlight.html">OpenStack Stein-Train版本新功能介绍</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/"><span class="level-start"><span class="level-item">2017</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ceph/"><span class="tag">ceph</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/elasticsearch/"><span class="tag">elasticsearch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kubernetes/"><span class="tag">kubernetes</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/openstack/"><span class="tag">openstack</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/operations/"><span class="tag">operations</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/umi/"><span class="tag">umi</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/assets/logo.jpg" alt="开心BOY" height="28"></a><p class="is-size-7"><span>&copy; 2023 hackerain</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hackerain"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
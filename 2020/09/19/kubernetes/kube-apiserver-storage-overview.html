<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Kubernetes APIServer Storage 框架解析 - 开心BOY</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="开心BOY"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="开心BOY"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Kubernetes使用etcd作为后端存储，etcd是一个分布式的，高可靠性的键值存储系统，跟传统的平台系统不同，Kubernetes把所有的数据都存储到了kv数据库中，而没有像OpenStack一样使用像MySQL这种关系型数据库，做这种选型的原因，我想可能一方面是由于Kubernetes中存储的数据，关系性不是很强，更多的是类似配置管理这类数据，一方面是由于etcd的特性，像效率比较高的gR"><meta property="og:type" content="blog"><meta property="og:title" content="Kubernetes APIServer Storage 框架解析"><meta property="og:url" content="https://hackerain.me/2020/09/19/kubernetes/kube-apiserver-storage-overview.html"><meta property="og:site_name" content="开心BOY"><meta property="og:description" content="Kubernetes使用etcd作为后端存储，etcd是一个分布式的，高可靠性的键值存储系统，跟传统的平台系统不同，Kubernetes把所有的数据都存储到了kv数据库中，而没有像OpenStack一样使用像MySQL这种关系型数据库，做这种选型的原因，我想可能一方面是由于Kubernetes中存储的数据，关系性不是很强，更多的是类似配置管理这类数据，一方面是由于etcd的特性，像效率比较高的gR"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hackerain.me/img/og_image.png"><meta property="article:published_time" content="2020-09-19T00:00:00.000Z"><meta property="article:modified_time" content="2023-11-05T16:20:55.995Z"><meta property="article:author" content="hackerain"><meta property="article:tag" content="kubernetes"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hackerain.me/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hackerain.me/2020/09/19/kubernetes/kube-apiserver-storage-overview.html"},"headline":"Kubernetes APIServer Storage 框架解析","image":["https://hackerain.me/img/og_image.png"],"datePublished":"2020-09-19T00:00:00.000Z","dateModified":"2023-11-05T16:20:55.995Z","author":{"@type":"Person","name":"hackerain"},"publisher":{"@type":"Organization","name":"开心BOY","logo":{"@type":"ImageObject","url":"https://hackerain.me/assets/logo.jpg"}},"description":"Kubernetes使用etcd作为后端存储，etcd是一个分布式的，高可靠性的键值存储系统，跟传统的平台系统不同，Kubernetes把所有的数据都存储到了kv数据库中，而没有像OpenStack一样使用像MySQL这种关系型数据库，做这种选型的原因，我想可能一方面是由于Kubernetes中存储的数据，关系性不是很强，更多的是类似配置管理这类数据，一方面是由于etcd的特性，像效率比较高的gR"}</script><link rel="canonical" href="https://hackerain.me/2020/09/19/kubernetes/kube-apiserver-storage-overview.html"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="开心BOY" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/assets/logo.jpg" alt="开心BOY" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-19T00:00:00.000Z" title="9/19/2020, 12:00:00 AM">2020-09-19</time>发表</span><span class="level-item"><time dateTime="2023-11-05T16:20:55.995Z" title="11/5/2023, 4:20:55 PM">2023-11-05</time>更新</span><span class="level-item">37 分钟读完 (大约5565个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Kubernetes APIServer Storage 框架解析</h1><div class="content"><p>Kubernetes使用<a target="_blank" rel="noopener" href="https://etcd.io/">etcd</a>作为后端存储，etcd是一个分布式的，高可靠性的键值存储系统，跟传统的平台系统不同，Kubernetes把所有的数据都存储到了kv数据库中，而没有像OpenStack一样使用像MySQL这种关系型数据库，做这种选型的原因，我想可能一方面是由于Kubernetes中存储的数据，关系性不是很强，更多的是类似配置管理这类数据，一方面是由于etcd的特性，像效率比较高的gRPC接口、支持事务以及Kubernetes严重依赖的Watch机制等，能够通过单一数据库就满足它的需求，不用再引入其他组件实现类似功能，简化了架构的复杂性。</p>
<span id="more"></span>

<p>本篇文章主要来介绍下Kubernetes APIServer是如何跟存储打交道的，不涉及存储底层的细节，只到存储接口层，即主要介绍Kubernetes的存储框架是怎么样的，如何做的抽象，它里面的资源是如何存到etcd里面去的。在介绍具体的流程机制之前，我们先来介绍下Kubernetes里面几个相关的抽象，从顶层看下是如何做的设计。</p>
<h2 id="顶层抽象"><a href="#顶层抽象" class="headerlink" title="顶层抽象"></a>顶层抽象</h2><h3 id="资源、类别以及对象"><a href="#资源、类别以及对象" class="headerlink" title="资源、类别以及对象"></a>资源、类别以及对象</h3><p>在API中抽象出来资源(Resource)、类别(Kind)以及对象(Object)这几个概念，其相关的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupVersionResource <span class="keyword">struct</span> &#123;</span><br><span class="line">    Group    <span class="type">string</span></span><br><span class="line">    Version  <span class="type">string</span></span><br><span class="line">    Resource <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupVersionKind <span class="keyword">struct</span> &#123;</span><br><span class="line">    Group   <span class="type">string</span></span><br><span class="line">    Version <span class="type">string</span></span><br><span class="line">    Kind    <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupResource <span class="keyword">struct</span> &#123;</span><br><span class="line">    Group    <span class="type">string</span></span><br><span class="line">    Resource <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupKind <span class="keyword">struct</span> &#123;</span><br><span class="line">    Group <span class="type">string</span></span><br><span class="line">    Kind  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Object <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetObjectKind() schema.ObjectKind</span><br><span class="line">    DeepCopyObject() Object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ObjectKind <span class="keyword">interface</span> &#123;</span><br><span class="line">    SetGroupVersionKind(kind GroupVersionKind)</span><br><span class="line">    GroupVersionKind() GroupVersionKind</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道Kubernetes中的API对象都是带版本以及分组的，比如<code>/apis/networking.k8s.io/v1beta1/ingresses</code>，<code>/apis</code>是前缀，<code>networking.k8s.io</code>就是组(Group)，<code>v1beta1</code>就是版本(Version)，<code>ingresses</code>就是上面提到的资源(Resource)或者类别(Kind)，至于<code>Object</code>则是对API对象的抽象接口，具体的API对象则都实现了这些接口，在golang里，实现了这些接口的结构体，都可以用这个<code>type xxx interface</code>来统一表示，类似于父类的概念，所以<code>Object</code>可以代表所有实现了它的接口的对象，通常作为方法的参数或者返回值。可见，这三个概念其实都代表的是同一个意思，都是对像<code>pod</code>, <code>service</code>, <code>ingress</code>等这些API对象的抽象，但是表现形式不同，用途也不一样……:-(所以之前说的Kubernetes代码复杂就复杂在这些地方，抽象的云里雾里的:-)</p>
<p>这些结构体和接口定义在<a target="_blank" rel="noopener" href="https://github.com/kubernetes/apimachinery">apimachinery</a>这个库中，这个库可以说是Kubernetes中最高层的抽象，除了上面说的Resource, Kind, Object，还有各种类型定义、序列化、类型转换之类的抽象，都是会被其他的库引用到的一些结构体或者方法。</p>
<h3 id="etcd存储接口"><a href="#etcd存储接口" class="headerlink" title="etcd存储接口"></a>etcd存储接口</h3><p>所谓etcd存储接口是对etcd数据库的增删查改的抽象，其定义在<a target="_blank" rel="noopener" href="https://github.com/kubernetes/apiserver">apiserver</a>的<code>apiserver/pkg/storage/interfaces.go</code>文件中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Versioner() Versioner</span><br><span class="line">    Create(ctx context.Context, key <span class="type">string</span>, obj, out runtime.Object, ttl <span class="type">uint64</span>) <span class="type">error</span></span><br><span class="line">    Delete(ctx context.Context, key <span class="type">string</span>, out runtime.Object, preconditions *Preconditions, validateDeletion ValidateObjectFunc) <span class="type">error</span></span><br><span class="line">    Watch(ctx context.Context, key <span class="type">string</span>, resourceVersion <span class="type">string</span>, p SelectionPredicate) (watch.Interface, <span class="type">error</span>)</span><br><span class="line">    WatchList(ctx context.Context, key <span class="type">string</span>, resourceVersion <span class="type">string</span>, p SelectionPredicate) (watch.Interface, <span class="type">error</span>)</span><br><span class="line">    Get(ctx context.Context, key <span class="type">string</span>, resourceVersion <span class="type">string</span>, objPtr runtime.Object, ignoreNotFound <span class="type">bool</span>) <span class="type">error</span></span><br><span class="line">    GetToList(ctx context.Context, key <span class="type">string</span>, resourceVersion <span class="type">string</span>, p SelectionPredicate, listObj runtime.Object) <span class="type">error</span></span><br><span class="line">    List(ctx context.Context, key <span class="type">string</span>, resourceVersion <span class="type">string</span>, p SelectionPredicate, listObj runtime.Object) <span class="type">error</span></span><br><span class="line">    GuaranteedUpdate(</span><br><span class="line">        ctx context.Context, key <span class="type">string</span>, ptrToType runtime.Object, ignoreNotFound <span class="type">bool</span>,</span><br><span class="line">        precondtions *Preconditions, tryUpdate UpdateFunc, suggestion ...runtime.Object) <span class="type">error</span></span><br><span class="line">    Count(key <span class="type">string</span>) (<span class="type">int64</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，跟我们传统的数据库应用不同的地方在于，它的接口比较少，只有这么几个，比如<code>Create()</code>方法，一般我们写应用程序，要存一个东西，都会有类似<code>CreateXXX()</code>这样的方法，比如<code>CreatePerson(person Person)</code>，就是保存一个<code>Person</code>对象到数据库中，然后会有一堆这样的<code>CreateXXX()</code>方法来对不同的对象进行存储，但是这里<code>Create()</code>方法定义的，则是一个高度抽象的方法，<code>obj</code>是要存进去的对象，即上面说到的<code>Object</code>，至于这个对象具体是什么，其实是看方法调用者构造了一个什么对象传给它，<code>key</code>则是其键值，实际上<code>etcd3 store</code>在实现这些接口时，会将<code>obj</code>进行编码，即序列化，然后再存到数据库中，这种方法大大减少了数据库层的代码量，也充分利用了kv数据库的特性。</p>
<p>此外，<a target="_blank" rel="noopener" href="https://github.com/kubernetes/apiserver">apiserver</a> 这个库是将构建APIServer的一些通用代码抽出来，独立构成了一个库，以便代码复用，可以给第三方应用构建扩展使用，Kubernetes APIServer的实现大量依赖了该库。</p>
<h3 id="REST存储接口"><a href="#REST存储接口" class="headerlink" title="REST存储接口"></a>REST存储接口</h3><p>Kubernetes API是RESTful API，它的每一种REST资源，比如<code>pod</code>, <code>service</code>, <code>ingress</code>，在APIServer中，都有一个Store与之对应，通过实现统一的接口，来实现对REST资源的增删改查等操作，这些统一的接口定义在 <code>apiserver/pkg/registry/rest/rest.go</code> 文件中，列举几个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Storage is a generic interface for RESTful storage services.</span></span><br><span class="line"><span class="comment">// Resources which are exported to the RESTful API of apiserver need to implement this interface. It is expected</span></span><br><span class="line"><span class="comment">// that objects may implement any of the below interfaces.</span></span><br><span class="line"><span class="keyword">type</span> Storage <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// New returns an empty object that can be used with Create and Update after request data has been put into it.</span></span><br><span class="line">    <span class="comment">// This object must be a pointer type for use with Codec.DecodeInto([]byte, runtime.Object)</span></span><br><span class="line">    New() runtime.Object</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy cleans up its resources on shutdown.</span></span><br><span class="line">    <span class="comment">// Destroy has to be implemented in thread-safe way and be prepared</span></span><br><span class="line">    <span class="comment">// for being called more than once.</span></span><br><span class="line">    Destroy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Getter is an object that can retrieve a named RESTful resource.</span></span><br><span class="line"><span class="keyword">type</span> Getter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(ctx context.Context, name <span class="type">string</span>, options *metav1.GetOptions) (runtime.Object, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creater is an object that can create an instance of a RESTful object.</span></span><br><span class="line"><span class="keyword">type</span> Creater <span class="keyword">interface</span> &#123;</span><br><span class="line">    New() runtime.Object</span><br><span class="line">    Create(ctx context.Context, obj runtime.Object, createValidation ValidateObjectFunc, options *metav1.CreateOptions) (runtime.Object, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GracefulDeleter knows how to pass deletion options to allow delayed deletion of a</span></span><br><span class="line"><span class="comment">// RESTful object.</span></span><br><span class="line"><span class="keyword">type</span> GracefulDeleter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Delete(ctx context.Context, name <span class="type">string</span>, deleteValidation ValidateObjectFunc, options *metav1.DeleteOptions) (runtime.Object, <span class="type">bool</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Watcher should be implemented by all Storage objects that</span></span><br><span class="line"><span class="comment">// want to offer the ability to watch for changes through the watch api.</span></span><br><span class="line"><span class="keyword">type</span> Watcher <span class="keyword">interface</span> &#123;</span><br><span class="line">    Watch(ctx context.Context, options *metainternalversion.ListOptions) (watch.Interface, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即针对某一个API对象的REST操作，会由对应的Store中的方法进行处理，这个Store又引用了实现了etcd存储接口的Store，从而可以对数据库进行操作。</p>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>上一小节，主要介绍了两类存储接口，一类是针对etcd的存储接口，一类是针对REST的存储接口，下面我们来分别说一下实现这两类接口的方法和结构体。</p>
<h3 id="etcd存储接口实现"><a href="#etcd存储接口实现" class="headerlink" title="etcd存储接口实现"></a>etcd存储接口实现</h3><p>针对etcd存储接口的实现，在<code>apiserver/pkg/storage/etcd3/store.go</code> 这个文件中，最主要的结构体为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> store <span class="keyword">struct</span> &#123;</span><br><span class="line">    client *clientv3.Client</span><br><span class="line">    <span class="comment">// getOpts contains additional options that should be passed</span></span><br><span class="line">    <span class="comment">// to all Get() calls.</span></span><br><span class="line">    getOps        []clientv3.OpOption</span><br><span class="line">    codec         runtime.Codec</span><br><span class="line">    versioner     storage.Versioner</span><br><span class="line">    transformer   value.Transformer</span><br><span class="line">    pathPrefix    <span class="type">string</span></span><br><span class="line">    watcher       *watcher</span><br><span class="line">    pagingEnabled <span class="type">bool</span></span><br><span class="line">    leaseManager  *leaseManager</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见该结构体最重要的属性为<code>client</code>，即直接调用到了etcd的client库，通过该<code>client</code>可以对etcd进行操作，在该结构体上，还实现了<code>apiserver/pkg/storage/interfaces.go</code>中定义的接口，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> Get(ctx context.Context, key <span class="type">string</span>, resourceVersion <span class="type">string</span>, out runtime.Object, ignoreNotFound <span class="type">bool</span>)&#123;</span><br><span class="line">    getResp, err := s.client.KV.Get(ctx, key, s.getOps...)</span><br><span class="line">    kv := getResp.Kvs[<span class="number">0</span>]</span><br><span class="line">    data, _, err := s.transformer.TransformFromStorage(kv.Value, authenticatedDataString(key))</span><br><span class="line">    <span class="keyword">return</span> decode(s.codec, s.versioner, data, out, kv.ModRevision)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> Create(ctx context.Context, key <span class="type">string</span>, obj, out runtime.Object, ttl <span class="type">uint64</span>)&#123;</span><br><span class="line">    data, err := runtime.Encode(s.codec, obj)</span><br><span class="line">    newData, err := s.transformer.TransformToStorage(data, authenticatedDataString(key))</span><br><span class="line"></span><br><span class="line">    txnResp, err := s.client.KV.Txn(ctx).If(</span><br><span class="line">        notFound(key),</span><br><span class="line">    ).Then(</span><br><span class="line">        clientv3.OpPut(key, <span class="type">string</span>(newData), opts...),</span><br><span class="line">    ).Commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">        putResp := txnResp.Responses[<span class="number">0</span>].GetResponsePut()</span><br><span class="line">        <span class="keyword">return</span> decode(s.codec, s.versioner, data, out, putResp.Header.Revision)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上代码为简化代码，忽略了一些不重要的逻辑，且只列出<code>GET</code>和<code>Create</code>两个方法，其他未列出。可以看到<code>GET</code>方法，通过一个<code>string</code>类型的<code>key</code>，从etcd中取出了对应的<code>value</code>，然后通过decode进行解码，将数据解码到<code>out</code>这个<code>Object</code>中，然后将其返回。而<code>CREATE</code>方法，则反过来，先将<code>obj</code>进行编码，然后通过<code>etcd client</code>将数据通过事务的方式保存到etcd中。这个编码解码的过程，就是常说的序列化的过程。</p>
<h3 id="REST存储接口实现"><a href="#REST存储接口实现" class="headerlink" title="REST存储接口实现"></a>REST存储接口实现</h3><p>REST存储接口的实现在 <code>apiserver/pkg/registry/generic/retistry/store.go</code> 这个文件中，定义了如下的结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Store <span class="keyword">struct</span> &#123;</span><br><span class="line">    NewFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span> runtime.Object</span><br><span class="line">    NewListFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span> runtime.Object</span><br><span class="line">    KeyFunc <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, name <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">    ObjectNameFunc <span class="function"><span class="keyword">func</span><span class="params">(obj runtime.Object)</span></span> (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    Storage DryRunnableStorage  <span class="comment">// etcd3.store, implement the storage.Interface</span></span><br><span class="line">    DestroyFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    StorageVersioner runtime.GroupVersioner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该结构体实现了上面小节中REST存储定义的各种接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span></span> New() runtime.Object &#123;</span><br><span class="line">    <span class="keyword">return</span> e.NewFunc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span></span> Get(ctx context.Context, name <span class="type">string</span>, options *metav1.GetOptions) (runtime.Object, <span class="type">error</span>) &#123;</span><br><span class="line">    obj := e.NewFunc()</span><br><span class="line">    key, err := e.KeyFunc(ctx, name)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := e.Storage.Get(ctx, key, options.ResourceVersion, obj, <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, storeerr.InterpretGetError(err, e.qualifiedResourceFromContext(ctx), name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> e.Decorator != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := e.Decorator(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span></span> Create(ctx context.Context, obj runtime.Object, createValidation rest.ValidateObjectFunc, options *metav1.CreateOptions) (runtime.Object, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := rest.BeforeCreate(e.CreateStrategy, ctx, obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> createValidation != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := createValidation(ctx, obj.DeepCopyObject()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    name, err := e.ObjectNameFunc(obj)</span><br><span class="line"></span><br><span class="line">    key, err := e.KeyFunc(ctx, name)</span><br><span class="line"></span><br><span class="line">    qualifiedResource := e.qualifiedResourceFromContext(ctx)</span><br><span class="line">    ttl, err := e.calculateTTL(obj, <span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    out := e.NewFunc()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := e.Storage.Create(ctx, key, obj, out, ttl, dryrun.IsDryRun(options.DryRun)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Store</code>结构体中，有一个非常重要的成员 <code>Storage DryRunnableStorage</code>，它即是对etcd store的引用，其定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DryRunnableStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">    Storage storage.Interface</span><br><span class="line">    Codec   runtime.Codec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DryRunnableStorage)</span></span> Get(ctx context.Context, key <span class="type">string</span>, resourceVersion <span class="type">string</span>, objPtr runtime.Object, ignoreNotFound <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.Storage.Get(ctx, key, resourceVersion, objPtr, ignoreNotFound)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的成员<code>Storage storage.Interface</code>即是上面小节中提到的<code>etcd存储接口</code>，之所以中间又套了一层<code>DryRunnableStorage</code>主要是为了编写单元测试方便，针对真实写数据库的操作，可以让它DryRun，而不实际写数据库。</p>
<p>至此，我们知道Kubernetes中定义了两种Store，分别是针对REST资源的Store，以及针对etcd数据库的Store，包括他们各自实现的接口方法，后文我们将他们称为<code>REST store</code>以及<code>etcd store</code>，这两个store之间是引用的关系是<code>REST store</code>引用了<code>etcd store</code>。上层实例化一个<code>REST store</code>，则会同时实例化一个<code>etcd store</code>，用于对数据库的增删查改操作，即上面代码中的<code>e.Storage.Create()</code>，<code>e.Storage.Get()</code>等，即是调用<code>etcd store</code>去读写数据库。</p>
<h2 id="上层应用"><a href="#上层应用" class="headerlink" title="上层应用"></a>上层应用</h2><p>这里所说的上层应用，指的是Kubernetes中是如何使用上面说到的<code>REST store</code>和<code>etcd store</code>这两个Store的。</p>
<h3 id="etcd存储"><a href="#etcd存储" class="headerlink" title="etcd存储"></a>etcd存储</h3><p>本小节主要是介绍下如何构建出<code>etcd store</code>实体的，首先来看下最上面的代码逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># cmd/kube-apiserver/app/server.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">buildGenericConfig() &#123;</span><br><span class="line">    genericConfig = genenricapiserver.NewConfig()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面三行代码，构造了一个StorageFactoryConfig，给它的各个属性赋值</span></span><br><span class="line">    storageFactoryConfig := kubeapiserver.NewStorageFactoryConfig()</span><br><span class="line">    storageFactoryConfig.APIResourceConfig = genericConfig.MergedResourceConfig</span><br><span class="line">    completedStorageFactoryConfig, err := storageFactoryConfig.Complete(s.Etcd)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从StorageFactoryConfig New了一个DefaultStorageFactory</span></span><br><span class="line">    storageFactory, lastErr = completedStorageFactoryConfig.New()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用storageFactory构造了一个StorageFactoryRestOptionsFactory，赋值给genericConfig的RESTOptionsGetter属性</span></span><br><span class="line">    s.Etcd.ApplyWithStorageFactoryTo(storageFactory, genericConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>buildGenericConfig()</code>就是在<a href="kube-apiserver-storage-overview">Kubernetes APIServer 机制概述</a>中介绍过的<code>CreateServerChain</code>阶段，构建的配置项，将和APIServer相关的很多通用的配置项都集合在这个里面，这里我们只关注和存储相关的配置项，即上面列出的那几行代码，其实这几行代码，体现了两个在Kubernetes中非常常见的设计模式，一个是<code>Config-&gt;Complete-&gt;New</code>模式，一个是<code>Factory</code>工厂模式。</p>
<p>所谓<code>Config-&gt;Complete-&gt;New</code>模式，即首先构建一个Config，即配置项，然后通过Complete()方法进一步补充完善该Config，然后从该Config创建出真正的实体，创建该实体相关的信息，都在该Config中。在上面的例子中，StorageFactoryConfig，就是Config，然后通过Complete()方法，从s.Etcd中再进一步获取相关信息，补充完善该Config，得到completedStorageFactoryConfig，然后再调用New()方法，就可以得到真正的实体，这里就是storageFactory。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># kubernetes/cmd/kube-apiserver/app/options/options.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">s.Etcd = genericoptions.NewEtcdOptions(storagebackend.NewDefaultConfig(kubeoptions.DefaultEtcdPathPrefix, <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line"># k8s.io/apiserver/pkg/server/options/etcd.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EtcdOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    StorageConfig  storagebackend.Config  <span class="comment">// 在newEtcdOptions时就赋值进去的</span></span><br><span class="line">    EncryptionProviderConfigFilepath <span class="type">string</span></span><br><span class="line">    EtcdServersOverrides []<span class="type">string</span></span><br><span class="line">    DefaultStorageMediaType <span class="type">string</span></span><br><span class="line">    DeleteCollectionWorkers <span class="type">int</span></span><br><span class="line">    EnableGarbageCollection <span class="type">bool</span></span><br><span class="line">    EnableWatchCache <span class="type">bool</span></span><br><span class="line">    DefaultWatchCacheSize <span class="type">int</span></span><br><span class="line">    WatchCacheSizes []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># kubernetes/pkg/kubeapiserver/default_storage_factory_builder.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewStorageFactoryConfig returns a new StorageFactoryConfig set up with necessary resource overrides.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStorageFactoryConfig</span><span class="params">()</span></span> *StorageFactoryConfig &#123;</span><br><span class="line"></span><br><span class="line">    resources := []schema.GroupVersionResource&#123;</span><br><span class="line">        batch.Resource(<span class="string">&quot;cronjobs&quot;</span>).WithVersion(<span class="string">&quot;v1beta1&quot;</span>),</span><br><span class="line">        networking.Resource(<span class="string">&quot;ingresses&quot;</span>).WithVersion(<span class="string">&quot;v1beta1&quot;</span>),</span><br><span class="line">        networking.Resource(<span class="string">&quot;ingressclasses&quot;</span>).WithVersion(<span class="string">&quot;v1beta1&quot;</span>),</span><br><span class="line">        apisstorage.Resource(<span class="string">&quot;csidrivers&quot;</span>).WithVersion(<span class="string">&quot;v1beta1&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;StorageFactoryConfig&#123;</span><br><span class="line">        Serializer:                legacyscheme.Codecs,</span><br><span class="line">        DefaultResourceEncoding:   serverstorage.NewDefaultResourceEncodingConfig(legacyscheme.Scheme),</span><br><span class="line">        ResourceEncodingOverrides: resources,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StorageFactoryConfig is a configuration for creating storage factory.</span></span><br><span class="line"><span class="keyword">type</span> StorageFactoryConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">    StorageConfig                    storagebackend.Config</span><br><span class="line">    APIResourceConfig                *serverstorage.ResourceConfig</span><br><span class="line">    DefaultResourceEncoding          *serverstorage.DefaultResourceEncodingConfig</span><br><span class="line">    DefaultStorageMediaType          <span class="type">string</span></span><br><span class="line">    Serializer                       runtime.StorageSerializer</span><br><span class="line">    ResourceEncodingOverrides        []schema.GroupVersionResource</span><br><span class="line">    EtcdServersOverrides             []<span class="type">string</span></span><br><span class="line">    EncryptionProviderConfigFilepath <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Complete completes the StorageFactoryConfig with provided etcdOptions returning completedStorageFactoryConfig.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *StorageFactoryConfig)</span></span> Complete(etcdOptions *serveroptions.EtcdOptions) (*completedStorageFactoryConfig, <span class="type">error</span>) &#123;</span><br><span class="line">    c.StorageConfig = etcdOptions.StorageConfig <span class="comment">// 从etcdOptions获取初始的StorageConfig</span></span><br><span class="line">    c.DefaultStorageMediaType = etcdOptions.DefaultStorageMediaType</span><br><span class="line">    c.EtcdServersOverrides = etcdOptions.EtcdServersOverrides</span><br><span class="line">    c.EncryptionProviderConfigFilepath = etcdOptions.EncryptionProviderConfigFilepath</span><br><span class="line">    <span class="keyword">return</span> &amp;completedStorageFactoryConfig&#123;c&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> completedStorageFactoryConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">    *StorageFactoryConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns a new storage factory created from the completed storage factory configuration.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *completedStorageFactoryConfig)</span></span> New() (*serverstorage.DefaultStorageFactory, <span class="type">error</span>) &#123;</span><br><span class="line">    resourceEncodingConfig := resourceconfig.MergeResourceEncodingConfigs(c.DefaultResourceEncoding, c.ResourceEncodingOverrides)</span><br><span class="line">    storageFactory := serverstorage.NewDefaultStorageFactory(</span><br><span class="line">        c.StorageConfig,</span><br><span class="line">        c.DefaultStorageMediaType,</span><br><span class="line">        c.Serializer,</span><br><span class="line">        resourceEncodingConfig,</span><br><span class="line">        c.APIResourceConfig,</span><br><span class="line">        SpecialDefaultResourcePrefixes)</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storageFactory, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的方式，创建出来<code>DefaultStorageFactory</code>实例，然后就到了上面说到的<code>Factory</code>工厂模式，顾名思义，就是从工厂中生产出类似的实体，而它生产的实体，就是针对某个资源<code>resource</code>的存储配置<code>StorageConfig</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"># k8s.io/apiserver/pkg/server/storage/storage_factory.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StorageFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">    NewConfig(groupResource schema.GroupResource) (*storagebackend.Config, <span class="type">error</span>)</span><br><span class="line">    ResourcePrefix(groupResource schema.GroupResource) <span class="type">string</span></span><br><span class="line">    Backends() []Backend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##  DefaultStorageFactory实现了StorageFactory Interface</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DefaultStorageFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">    StorageConfig   storagebackend.Config</span><br><span class="line">    Overrides <span class="keyword">map</span>[schema.GroupResource]groupResourceOverrides</span><br><span class="line">    DefaultResourcePrefixes <span class="keyword">map</span>[schema.GroupResource]<span class="type">string</span></span><br><span class="line">    DefaultMediaType <span class="type">string</span></span><br><span class="line">    DefaultSerializer runtime.StorageSerializer</span><br><span class="line">    ResourceEncodingConfig ResourceEncodingConfig</span><br><span class="line">    APIResourceConfigSource APIResourceConfigSource</span><br><span class="line">    newStorageCodecFn <span class="function"><span class="keyword">func</span><span class="params">(opts StorageCodecConfig)</span></span> (codec runtime.Codec, encodeVersioner runtime.GroupVersioner, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultStorageFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    config storagebackend.Config,</span></span></span><br><span class="line"><span class="params"><span class="function">    defaultMediaType <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    defaultSerializer runtime.StorageSerializer,</span></span></span><br><span class="line"><span class="params"><span class="function">    resourceEncodingConfig ResourceEncodingConfig,</span></span></span><br><span class="line"><span class="params"><span class="function">    resourceConfig APIResourceConfigSource,</span></span></span><br><span class="line"><span class="params"><span class="function">    specialDefaultResourcePrefixes <span class="keyword">map</span>[schema.GroupResource]<span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> *DefaultStorageFactory &#123;</span><br><span class="line">    config.Paging = utilfeature.DefaultFeatureGate.Enabled(features.APIListChunking)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(defaultMediaType) == <span class="number">0</span> &#123;</span><br><span class="line">        defaultMediaType = runtime.ContentTypeJSON</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;DefaultStorageFactory&#123;</span><br><span class="line">        StorageConfig:           config,</span><br><span class="line">        Overrides:               <span class="keyword">map</span>[schema.GroupResource]groupResourceOverrides&#123;&#125;,</span><br><span class="line">        DefaultMediaType:        defaultMediaType,</span><br><span class="line">        DefaultSerializer:       defaultSerializer,</span><br><span class="line">        ResourceEncodingConfig:  resourceEncodingConfig,</span><br><span class="line">        APIResourceConfigSource: resourceConfig,</span><br><span class="line">        DefaultResourcePrefixes: specialDefaultResourcePrefixes,</span><br><span class="line"></span><br><span class="line">        newStorageCodecFn: NewStorageCodec,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DefaultStorageFactory)</span></span> NewConfig(groupResource schema.GroupResource) (*storagebackend.Config, <span class="type">error</span>) &#123;</span><br><span class="line">    chosenStorageResource := s.getStorageGroupResource(groupResource)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operate on copy</span></span><br><span class="line">    storageConfig := s.StorageConfig</span><br><span class="line">    codecConfig := StorageCodecConfig&#123;</span><br><span class="line">        StorageMediaType:  s.DefaultMediaType,</span><br><span class="line">        StorageSerializer: s.DefaultSerializer,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> override, ok := s.Overrides[getAllResourcesAlias(chosenStorageResource)]; ok &#123;</span><br><span class="line">        override.Apply(&amp;storageConfig, &amp;codecConfig)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> override, ok := s.Overrides[chosenStorageResource]; ok &#123;</span><br><span class="line">        override.Apply(&amp;storageConfig, &amp;codecConfig)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    codecConfig.StorageVersion, err = s.ResourceEncodingConfig.StorageEncodingFor(chosenStorageResource)</span><br><span class="line">    codecConfig.MemoryVersion, err = s.ResourceEncodingConfig.InMemoryEncodingFor(groupResource)</span><br><span class="line">    codecConfig.Config = storageConfig</span><br><span class="line"></span><br><span class="line">    storageConfig.Codec, storageConfig.EncodeVersioner, err = s.newStorageCodecFn(codecConfig)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;storageConfig, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>NewConfig()</code>是为某个<code>resource</code>创建出对应的存储配置，即<code>StorageConfig</code>，该配置中包含了etcd的连接、序列化等信息，即每种资源<code>resource</code>都有自己的一套存储配置，例如可以通过<code>--etcd-servers-overrides</code>配置项，来给某个单独的<code>resource</code>指定不同的后端存储，这种机制跟常规的应用很不一样，一般的应用访问数据库，都会有一个集中的数据库配置，所有的资源都是使用的一套配置，但是这里却细化到了按照资源种类去配置存储，这虽然看起来很灵活强大，但是不免有过度设计的嫌疑，谁会去把同一个集群里的资源分开存放到不同的数据库呢？或者有什么资源是需要有特殊的编解码方式的？至少我没有见过这种使用场景，Anyway，稍微吐槽下，还是转入正题吧。<code>StorageConfig</code> 即 <code>storagebackend.Config</code>，其初始值是来自于 <code>EtcdOptions</code>，然后传给 <code>StorageFactoryConfig</code>，<code>StorageFactoryConfig</code> 再传给 <code>StorageFactory</code>，<code>StorageFactory</code>在给某个<code>resource</code>创建存储配置时，把<code>StorageFactory</code>中的<code>StorageConfig</code>复制了一份，再给它赋值了其他一些属性，比如负责编解码的Codec等，构成了针对某种资源特定的配置，<code>StorageConfig</code>对应的结构体定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># k8s.io/apiserver/pkg/storage/storagebackend/config.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type <span class="type">string</span></span><br><span class="line">    Prefix <span class="type">string</span></span><br><span class="line">    Transport TransportConfig</span><br><span class="line">    Paging <span class="type">bool</span></span><br><span class="line">    Codec runtime.Codec</span><br><span class="line">    EncodeVersioner runtime.GroupVersioner</span><br><span class="line">    CompactionInterval time.Duration</span><br><span class="line">    CountMetricPollPeriod time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，<code>s.Etcd.ApplyWithStorageFactoryTo()</code>则是将上面构建出来的<code>storageFactory</code>构建出另外一个结构体<code>StorageFactoryRestOptionsFactory</code>，然后将其赋值给<code>genericConfig</code>的<code>RESTOptionsGetter</code>属性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/server/options/etcd.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">(s *EtcdOptions)ApplyWithStorageFactoryTo(factory serverstorage.StorageFactory, c *server.Config)&#123;</span><br><span class="line">    c.RESTOptionsGetter = &amp;StorageFactoryRestOptionsFactory&#123;Options: *s, StorageFactory: factory&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StorageFactoryRestOptionsFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">    Options        EtcdOptions</span><br><span class="line">    StorageFactory serverstorage.StorageFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(f *StorageFactoryRestOptionsFactory) GetRESTOptions(resource schema.GroupResource) (generic.RESTOptions, <span class="type">error</span>)&#123;</span><br><span class="line">    <span class="comment">// 拿到该resource对应的storageconfig，每个resource可以有不同的storage配置，主要设置上storageConfig的codec和encodeversioner</span></span><br><span class="line">    storageConfig, err := f.StorageFactory.NewConfig(resource)</span><br><span class="line">    ret := generic.RESTOptions&#123;</span><br><span class="line">        StorageConfig: storageConfig,</span><br><span class="line">        Decorator:     generic.UndecoratedStorage, <span class="comment">// decorator-&gt;factory-&gt;store 最终拿到了Storage.Interface</span></span><br><span class="line">        ResourcePrefix: f.StorageFactory.ResourcePrefix(resource),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StorageFactoryRestOptionsFactory</code>实现了一个非常重要的方法：<code>GetRESTOptions()</code>，在这个里面，首先通过上面介绍到的<code>StorageFactory</code>的<code>NewConfig()</code>方法来创建出针对某一种resource的存储配置项，然后构建了一个<code>RESTOptions</code>的结构体，里面包含了另外一个重要的成员：<code>Decorator</code>，其定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/registry/generic/storage_decorator.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UndecoratedStorage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    config *storagebackend.Config,</span></span></span><br><span class="line"><span class="params"><span class="function">    resourcePrefix <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    keyFunc <span class="keyword">func</span>(obj runtime.Object)</span></span> (<span class="type">string</span>, <span class="type">error</span>),</span><br><span class="line">    newFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span> runtime.Object,</span><br><span class="line">    newListFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span> runtime.Object,</span><br><span class="line">    getAttrsFunc storage.AttrFunc,</span><br><span class="line">    trigger storage.IndexerFuncs,</span><br><span class="line">    indexers *cache.Indexers) (storage.Interface, factory.DestroyFunc, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NewRawStorage(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRawStorage</span><span class="params">(config *storagebackend.Config)</span></span> (storage.Interface, factory.DestroyFunc, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.Create(*config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>UndecoratedStorage</code>是一个方法，所以 <code>Decorator</code>也是一个方法，该方法的作用就是要使用前面创建出来的<code>StorageConfig</code>来创建一个<code>etcd store</code>出来，可以看到这里传了很多参数进去，但是实际上只用了 <code>config</code> 这一个参数，其他参数可能以后会用到，在 <code>NewRawStorage()</code> 方法中又用到工厂模式，使用<code>StorageConfig</code>中的信息，来创建最终的<code>Store</code>，其流程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/storage/storagebackend/factory/factory.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(c storagebackend.Config)</span></span> (storage.Interface, DestroyFunc, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> c.Type &#123;</span><br><span class="line">    <span class="keyword">case</span> storagebackend.StorageTypeUnset, storagebackend.StorageTypeETCD3:</span><br><span class="line">        <span class="keyword">return</span> newETCD3Storage(c)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unknown storage type: %s&quot;</span>, c.Type)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># apiserver/pkg/storage/storagebackend/factory/etcd3.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newETCD3Storage</span><span class="params">(c storagebackend.Config)</span></span> (storage.Interface, DestroyFunc, <span class="type">error</span>) &#123;</span><br><span class="line">        client, err := newETCD3Client(c.Transport)</span><br><span class="line">    <span class="keyword">return</span> etcd3.New(client, c.Codec, c.Prefix, transformer, c.Paging), destroyFunc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newETCD3Client</span><span class="params">(c storagebackend.TransportConfig)</span></span> (*clientv3.Client, <span class="type">error</span>) &#123;</span><br><span class="line">    cfg := clientv3.Config&#123;</span><br><span class="line">        DialTimeout:          dialTimeout,</span><br><span class="line">        DialKeepAliveTime:    keepaliveTime,</span><br><span class="line">        DialKeepAliveTimeout: keepaliveTimeout,</span><br><span class="line">        DialOptions:          dialOptions,</span><br><span class="line">        Endpoints:            c.ServerList,</span><br><span class="line">        TLS:                  tlsConfig,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clientv3.New(cfg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># apiserver/pkg/storage/etcd3/store.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement storage.Interface in apiserver/pkg/storage/interfaces.go</span></span><br><span class="line"><span class="keyword">type</span> store <span class="keyword">struct</span> &#123;</span><br><span class="line">    client *clientv3.Client</span><br><span class="line">    getOps        []clientv3.OpOption</span><br><span class="line">    codec         runtime.Codec</span><br><span class="line">    versioner     storage.Versioner</span><br><span class="line">    transformer   value.Transformer</span><br><span class="line">    pathPrefix    <span class="type">string</span></span><br><span class="line">    watcher       *watcher</span><br><span class="line">    pagingEnabled <span class="type">bool</span></span><br><span class="line">    leaseManager  *leaseManager</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(c *clientv3.Client, codec runtime.Codec, prefix <span class="type">string</span>, transformer value.Transformer, pagingEnabled <span class="type">bool</span>)</span></span> storage.Interface &#123;</span><br><span class="line">    <span class="keyword">return</span> newStore(c, pagingEnabled, codec, prefix, transformer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newStore</span><span class="params">(c *clientv3.Client, pagingEnabled <span class="type">bool</span>, codec runtime.Codec, prefix <span class="type">string</span>, transformer value.Transformer)</span></span> *store &#123;</span><br><span class="line">    versioner := APIObjectVersioner&#123;&#125;</span><br><span class="line">    result := &amp;store&#123;</span><br><span class="line">        client:        c,</span><br><span class="line">        codec:         codec,</span><br><span class="line">        versioner:     versioner,</span><br><span class="line">        transformer:   transformer,</span><br><span class="line">        pagingEnabled: pagingEnabled,</span><br><span class="line">        pathPrefix:   path.Join(<span class="string">&quot;/&quot;</span>, prefix),</span><br><span class="line">        watcher:      newWatcher(c, codec, versioner, transformer),</span><br><span class="line">        leaseManager: newDefaultLeaseManager(c),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过了山路十八弯，终于看到创建出来了<code>etcd store</code>，即上面<code>newETCD3Storage()</code>方法内的逻辑，先创建了一个<code>etcd client</code>，然后将该client传给<code>newStore()</code>，构建出<code>etcd store</code>结构体，可以通过<code>client</code>跟<code>etcd</code>打交道，同时序列化等信息存在<code>codec</code>等变量里。</p>
<p>综上，可以看到，虽然实现非常复杂，但是使用起来还是很简单的，因为实际上构建出来的<code>StorageFactory</code>是放到了<code>GenericConfig</code>中的<code>RESTOptionsGetter</code>，而<code>GenericConfig</code>是在<code>CreateServerChain</code>阶段就提前构建好的，因此，只需要向下面这样使用，就可以得到一个<code>etcd store</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">opts := genericConfig.RESTOptionsGetter.GetRESTOptions(resource)</span><br><span class="line">store := opts.Decorator(</span><br><span class="line">    opts.StorageConfig,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="REST存储"><a href="#REST存储" class="headerlink" title="REST存储"></a>REST存储</h3><p>在APIServer中，每一个API对象，都有一个<code>REST Store</code>与之对应，Kubernetes内置的API对象的<code>REST store</code>的相关逻辑，都位于<code>kubernetes/pkg/registry/</code>目录下，我们以<code>pod</code>为例，来说明下<code>REST Store</code>是如何构建出来的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># pkg/registry/core/pod/storage/storage.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    genericregistry <span class="string">&quot;k8s.io/apiserver/pkg/registry/generic/registry&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> REST <span class="keyword">struct</span> &#123;</span><br><span class="line">    *genericregistry.Store</span><br><span class="line">    proxyTransport http.RoundTripper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BindingREST <span class="keyword">struct</span> &#123;</span><br><span class="line">    store *genericregistry.Store</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StatusREST <span class="keyword">struct</span> &#123;</span><br><span class="line">    store *genericregistry.Store</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStorage</span><span class="params">(optsGetter generic.RESTOptionsGetter, k client.ConnectionInfoGetter...)</span></span> &#123;</span><br><span class="line">    store := &amp;genericregistry.Store&#123;</span><br><span class="line">        NewFunc:                <span class="function"><span class="keyword">func</span><span class="params">()</span></span> runtime.Object &#123; <span class="keyword">return</span> &amp;api.Pod&#123;&#125; &#125;,</span><br><span class="line">        NewListFunc:            <span class="function"><span class="keyword">func</span><span class="params">()</span></span> runtime.Object &#123; <span class="keyword">return</span> &amp;api.PodList&#123;&#125; &#125;,</span><br><span class="line">        ......</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    options := &amp;generic.StoreOptions&#123;</span><br><span class="line">        RESTOptions: optsGetter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    store.CompleteWithOptions(options)</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    statusStore := *store</span><br><span class="line">    statusStore.UpdateStrategy = registrypod.StatusStrategy</span><br><span class="line">    statusStore.ResetFieldsStrategy = registrypod.StatusStrategy</span><br><span class="line"></span><br><span class="line">    bindingREST := &amp;BindingREST&#123;store: store&#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PodStorage&#123;</span><br><span class="line">        Pod:                 &amp;REST&#123;store, proxyTransport&#125;,</span><br><span class="line">        Binding:             &amp;BindingREST&#123;store: store&#125;,</span><br><span class="line">        ......</span><br><span class="line">        Status:              &amp;StatusREST&#123;store: &amp;statusStore&#125;,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>genericregistry.Store</code> 就是 <code>REST存储接口实现</code> 介绍到的 <code>REST store</code>，一个Pod有很多种 <code>REST store</code>，比如上例中的 <code>REST</code>, <code>BindingREST</code>, <code>StatusREST</code>都是，这些类型都继承自 <code>genericregistry.Store</code>，注意该方法接受了一个参数<code>optsGetter generic.RESTOptionsGetter</code>，这个就是在上面<code>etcd 存储</code>应用中，介绍到的存储到<code>genericConfig</code>的<code>RESTOptionsGetter</code>，我们来看看这里是怎么使用这个<code>genericConfig.RESTOptionsGetter</code>的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一种resource都是由这个Store组成的，它实现了rest的各种接口，而它里面又包含了一个Storage属性，是对etcd的一个封装，实现了在数据库层面的各种增删查改的接口，即实现了storage.Interface</span></span><br><span class="line"><span class="comment">// Implement rest Interfaces in apiserver/pkg/registry/rest/rest.go</span></span><br><span class="line"><span class="comment">// like Getter, Lister, Creater, Updater, Patcher, Watcher etc.</span></span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">struct</span> &#123;</span><br><span class="line">    NewFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span> runtime.Object</span><br><span class="line">    NewListFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span> runtime.Object</span><br><span class="line">    KeyFunc <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, name <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">    ObjectNameFunc <span class="function"><span class="keyword">func</span><span class="params">(obj runtime.Object)</span></span> (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    Storage DryRunnableStorage  <span class="comment">// etcd3.store, implement the storage.Interface</span></span><br><span class="line">    DestroyFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    StorageVersioner runtime.GroupVersioner</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(e *Store) CompleteWithOptions(options *generic.StoreOptions)&#123;</span><br><span class="line">    opts, err := options.RESTOptions.GetRESTOptions(e.DefaultQualifiedResource)</span><br><span class="line">    e.Storage.Codec = opts.StorageConfig.Codec</span><br><span class="line">    e.Storage.Storage, e.DestroyFunc, err = opts.Decorator(</span><br><span class="line">            opts.StorageConfig,</span><br><span class="line">            prefix,</span><br><span class="line">            keyFunc,</span><br><span class="line">            e.NewFunc,</span><br><span class="line">            e.NewListFunc,</span><br><span class="line">            attrFunc,</span><br><span class="line">            options.TriggerFunc,</span><br><span class="line">            options.Indexers,</span><br><span class="line">        )</span><br><span class="line">    e.StorageVersioner = opts.StorageConfig.EncodeVersioner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即在<code>store.CompleteWithOptions(options)</code>方法中，调用了<code>GetRESTOptions()</code>方法获取到存储配置信息，然后再调用<code>Decorator()</code>方法创建出<code>etcd store</code>实体，存储到<code>DryRunnableStorage</code>中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要梳理了API对象存储相关的两个层面的存储接口以及其实现和应用，即<code>REST store</code>和<code>etcd store</code>，在脑海中建立起来的整体画像应该是，每一个API对象，都有对应的<code>REST store</code>和<code>etcd store</code>，这两者之间是引用的关系，<code>REST store</code>引用<code>etcd store</code>来操作数据库etcd，<code>REST store</code>是面向<code>RESTful api</code>侧， <code>etcd store</code>则面向数据库侧。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Kubernetes APIServer Storage 框架解析</p><p><a href="https://hackerain.me/2020/09/19/kubernetes/kube-apiserver-storage-overview.html">https://hackerain.me/2020/09/19/kubernetes/kube-apiserver-storage-overview.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>hackerain</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-09-19</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-11-05</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/kubernetes/">kubernetes</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/09/28/golang/go-restful-overview.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">go-restful简析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/08/09/kubernetes/kube-apiserver-overview.html"><span class="level-item">Kubernetes APIServer 机制概述</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/assets/avatar.jpg" alt="开心BOY"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">开心BOY</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">45</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="/about" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/hackerain"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="知识星球" href="https://t.zsxq.com/0bWmBFDpu"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#顶层抽象"><span class="level-left"><span class="level-item">1</span><span class="level-item">顶层抽象</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#资源、类别以及对象"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">资源、类别以及对象</span></span></a></li><li><a class="level is-mobile" href="#etcd存储接口"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">etcd存储接口</span></span></a></li><li><a class="level is-mobile" href="#REST存储接口"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">REST存储接口</span></span></a></li></ul></li><li><a class="level is-mobile" href="#底层实现"><span class="level-left"><span class="level-item">2</span><span class="level-item">底层实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#etcd存储接口实现"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">etcd存储接口实现</span></span></a></li><li><a class="level is-mobile" href="#REST存储接口实现"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">REST存储接口实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#上层应用"><span class="level-left"><span class="level-item">3</span><span class="level-item">上层应用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#etcd存储"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">etcd存储</span></span></a></li><li><a class="level is-mobile" href="#REST存储"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">REST存储</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">4</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-18T00:00:00.000Z">2023-11-18</time></p><p class="title"><a href="/2023/11/18/kubernetes/kube-controller-runtime.html">Kubernetes controller-runtime 介绍</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-12T00:00:00.000Z">2023-11-12</time></p><p class="title"><a href="/2023/11/12/kubernetes/kube-versioning-codec.html">Kubernetes API Codec 解析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-11T00:00:00.000Z">2023-11-11</time></p><p class="title"><a href="/2023/11/11/kubernetes/kube-versioning-scheme.html">Kubernetes API Scheme 解析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-28T00:00:00.000Z">2023-10-28</time></p><p class="title"><a href="/2023/10/28/kubernetes/kube-versioning.html">Kubernetes API 多版本和序列化</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-26T00:00:00.000Z">2022-09-26</time></p><p class="title"><a href="/2022/09/26/elasticsearch/elasticsearch_large_text_field.html">Elasticsearch大文本字段(large text field)优化方案</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/"><span class="level-start"><span class="level-item">2017</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ceph/"><span class="tag">ceph</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/elasticsearch/"><span class="tag">elasticsearch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kubernetes/"><span class="tag">kubernetes</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/openstack/"><span class="tag">openstack</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/operations/"><span class="tag">operations</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/umi/"><span class="tag">umi</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/assets/logo.jpg" alt="开心BOY" height="28"></a><p class="is-size-7"><span>&copy; 2024 hackerain</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hackerain"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
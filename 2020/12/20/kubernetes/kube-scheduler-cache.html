<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Kubernetes Scheduler性能优化之Cache - 开心BOY</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="开心BOY"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="开心BOY"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="背景在Kubernetes Scheduler机制概览中就介绍过Cache的作用，它的主要作用是加速调度过程中查询pod和node等信息的速度，此外，还有Snapshot机制，即为了保持调度时数据的一致性，对缓存打的快照。"><meta property="og:type" content="blog"><meta property="og:title" content="Kubernetes Scheduler性能优化之Cache"><meta property="og:url" content="https://hackerain.me/2020/12/20/kubernetes/kube-scheduler-cache.html"><meta property="og:site_name" content="开心BOY"><meta property="og:description" content="背景在Kubernetes Scheduler机制概览中就介绍过Cache的作用，它的主要作用是加速调度过程中查询pod和node等信息的速度，此外，还有Snapshot机制，即为了保持调度时数据的一致性，对缓存打的快照。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hackerain.me/assets/kubernetes_scheduler_cache_snapshot.png"><meta property="article:published_time" content="2020-12-20T00:00:00.000Z"><meta property="article:modified_time" content="2023-10-26T16:17:25.300Z"><meta property="article:author" content="hackerain"><meta property="article:tag" content="kubernetes"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hackerain.me/assets/kubernetes_scheduler_cache_snapshot.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hackerain.me/2020/12/20/kubernetes/kube-scheduler-cache.html"},"headline":"Kubernetes Scheduler性能优化之Cache","image":["https://hackerain.me/assets/kubernetes_scheduler_cache_snapshot.png"],"datePublished":"2020-12-20T00:00:00.000Z","dateModified":"2023-10-26T16:17:25.300Z","author":{"@type":"Person","name":"hackerain"},"publisher":{"@type":"Organization","name":"开心BOY","logo":{"@type":"ImageObject","url":"https://hackerain.me/assets/logo.jpg"}},"description":"背景在Kubernetes Scheduler机制概览中就介绍过Cache的作用，它的主要作用是加速调度过程中查询pod和node等信息的速度，此外，还有Snapshot机制，即为了保持调度时数据的一致性，对缓存打的快照。"}</script><link rel="canonical" href="https://hackerain.me/2020/12/20/kubernetes/kube-scheduler-cache.html"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="开心BOY" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/assets/logo.jpg" alt="开心BOY" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-12-20T00:00:00.000Z" title="12/20/2020, 12:00:00 AM">2020-12-20</time>发表</span><span class="level-item"><time dateTime="2023-10-26T16:17:25.300Z" title="10/26/2023, 4:17:25 PM">2023-10-26</time>更新</span><span class="level-item">21 分钟读完 (大约3203个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Kubernetes Scheduler性能优化之Cache</h1><div class="content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/12/19/kubernetes/kube-scheduler-overview.html">Kubernetes Scheduler机制概览</a>中就介绍过Cache的作用，它的主要作用是加速调度过程中查询pod和node等信息的速度，此外，还有Snapshot机制，即为了保持调度时数据的一致性，对缓存打的快照。</p>
<span id="more"></span>

<p>在查看Cache相关的代码时，发现Cache中有一些很奇怪的数据结构，看不明白为什么要做这样的设计，于是就追根溯源去查了下相关的issue和pr，了解了下当时的设计背景，发现针对scheduler的性能优化，还真是一个漫长的演进过程，从2015年就开始了，逐渐变成了现在这个样子，本篇文章就盘点一下，当年为提升scheduler性能而做的一些优化，顺便解释下Cache中那些奇怪的数据结构设计。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>我们先来看看现在cache和snapshot数据结构长什么样子：</p>
<p>Cache相关的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedulerCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    stop   &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    ttl    time.Duration</span><br><span class="line">    period time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This mutex guards all fields within this cache struct.</span></span><br><span class="line">    mu sync.RWMutex</span><br><span class="line">    <span class="comment">// a set of assumed pod keys.</span></span><br><span class="line">    <span class="comment">// The key could further be used to get an entry in podStates.</span></span><br><span class="line">    assumedPods <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">    <span class="comment">// a map from pod key to podState.</span></span><br><span class="line">    podStates <span class="keyword">map</span>[<span class="type">string</span>]*podState</span><br><span class="line">    nodes     <span class="keyword">map</span>[<span class="type">string</span>]*nodeInfoListItem</span><br><span class="line">    <span class="comment">// headNode points to the most recently updated NodeInfo in &quot;nodes&quot;. It is the</span></span><br><span class="line">    <span class="comment">// head of the linked list.</span></span><br><span class="line">    headNode *nodeInfoListItem</span><br><span class="line">    nodeTree *nodeTree</span><br><span class="line">    <span class="comment">// A map from image name to its imageState.</span></span><br><span class="line">    imageStates <span class="keyword">map</span>[<span class="type">string</span>]*imageState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> nodeInfoListItem <span class="keyword">struct</span> &#123;</span><br><span class="line">    info *framework.NodeInfo</span><br><span class="line">    next *nodeInfoListItem</span><br><span class="line">    prev *nodeInfoListItem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是为什么要有Cache？Informer中不是已经有了缓存了吗？难道那个还不能满足需求？其次，既然cache是做pod和node的缓存的，那么schedulerCache中podStates和nodes就很好理解了，使用Map来作为缓存的结构，通过哈希可以快速的找到某一个具体的node或者pod，但是令人迷惑的是headNode和nodeTree这两个结构，headNode是一个双向列表的第一个元素，通过next和prev指向下一个和前一个元素，这里竟然使用nodeInfo构造了一个双向链表，有map还不够吗？用意为何？此外nodeTree里面只保存了node的name，从map到slice的映射，这个又是做什么用的？</p>
<p>Snaphost相关的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Snapshot <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// nodeInfoMap a map of node name to a snapshot of its NodeInfo.</span></span><br><span class="line">    nodeInfoMap <span class="keyword">map</span>[<span class="type">string</span>]*framework.NodeInfo</span><br><span class="line">    <span class="comment">// nodeInfoList is the list of nodes as ordered in the cache&#x27;s nodeTree.</span></span><br><span class="line">    nodeInfoList []*framework.NodeInfo</span><br><span class="line">    <span class="comment">// havePodsWithAffinityNodeInfoList is the list of nodes with at least one pod declaring affinity terms.</span></span><br><span class="line">    havePodsWithAffinityNodeInfoList []*framework.NodeInfo</span><br><span class="line">    generation                       <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Snapshot是用来给Cache打快照的，那nodeInfoMap这个map还不够吗？为什么还有个nodeInfoList这样一个list？</p>
<h2 id="原因探究"><a href="#原因探究" class="headerlink" title="原因探究"></a>原因探究</h2><h3 id="1-为什么要引入Cache"><a href="#1-为什么要引入Cache" class="headerlink" title="1. 为什么要引入Cache"></a>1. 为什么要引入Cache</h3><p>带着这些疑问，我们将历史的年轮拨回2015年，先来看看为什么要引入Cache，相关的issue和pr如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/issues/18831">https://github.com/kubernetes/kubernetes/issues/18831</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/20669">https://github.com/kubernetes/kubernetes/pull/20669</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/21016">https://github.com/kubernetes/kubernetes/pull/21016</a></li>
</ul>
<p>在该issue中，作者说的很明白，是因为当前的调度算法的复杂度是O(containers)，甚至都不是O(pods)的，更别提O(nodes)了，在每一次调度时，都会遍历一遍该node上所有的containers，目的是为了计算出已有pod的request值，然后跟当前被调度的pod的request值进行比较，时间大部分被浪费在了遍历containers计算request值上了，因此改进的方法就是依赖informer的事件机制，动态的在本地再维护一份聚合之后的缓存，这样调度时，就可以直接获取到对应的数据，而不用实时计算了，可以看下缓存的node聚合之后的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeInfo is node level aggregated information.</span></span><br><span class="line"><span class="keyword">type</span> NodeInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Overall node information.</span></span><br><span class="line">    node *v1.Node</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pods running on the node.</span></span><br><span class="line">    Pods []*PodInfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The subset of pods with affinity.</span></span><br><span class="line">    PodsWithAffinity []*PodInfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ports allocated on the node.</span></span><br><span class="line">    UsedPorts HostPortInfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Total requested resources of all pods on this node. This includes assumed</span></span><br><span class="line">    <span class="comment">// pods, which scheduler has sent for binding, but may not be scheduled yet.</span></span><br><span class="line">    Requested *Resource</span><br><span class="line">    <span class="comment">// Total requested resources of all pods on this node with a minimum value</span></span><br><span class="line">    <span class="comment">// applied to each container&#x27;s CPU and memory requests. This does not reflect</span></span><br><span class="line">    <span class="comment">// the actual resource requests for this node, but is used to avoid scheduling</span></span><br><span class="line">    <span class="comment">// many zero-request pods onto one node.</span></span><br><span class="line">    NonZeroRequested *Resource</span><br><span class="line">    <span class="comment">// We store allocatedResources (which is Node.Status.Allocatable.*) explicitly</span></span><br><span class="line">    <span class="comment">// as int64, to avoid conversions and accessing map.</span></span><br><span class="line">    Allocatable *Resource</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ImageStates holds the entry of an image if and only if this image is on the node. The entry can be used for</span></span><br><span class="line">    <span class="comment">// checking an image&#x27;s existence and advanced usage (e.g., image locality scheduling policy) based on the image</span></span><br><span class="line">    <span class="comment">// state information.</span></span><br><span class="line">    ImageStates <span class="keyword">map</span>[<span class="type">string</span>]*ImageStateSummary</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TransientInfo holds the information pertaining to a scheduling cycle. This will be destructed at the end of</span></span><br><span class="line">    <span class="comment">// scheduling cycle.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> @ravig. Remove this once we have a clear approach for message passing across predicates and priorities.</span></span><br><span class="line">    TransientInfo *TransientSchedulerInfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Whenever NodeInfo changes, generation is bumped.</span></span><br><span class="line">    <span class="comment">// This is used to avoid cloning it if the object didn&#x27;t change.</span></span><br><span class="line">    Generation <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，聚合的数据包括该节点上已经分配的ports信息，以及该节点所有pod的request之和，还有已经分配出去的cpu/memory资源之和等。</p>
<p>下面两个pr就是cache的实现，优化之后，30K个pod的调度延迟从200ms缩小到20ms，大大提高了性能，算法复杂度从O(containers)变成了O(nodes)，即调度效率跟containers个数无关，跟nodes节点个数有关。</p>
<h3 id="2-为什么要引入Snapshot"><a href="#2-为什么要引入Snapshot" class="headerlink" title="2. 为什么要引入Snapshot"></a>2. 为什么要引入Snapshot</h3><p>Snapshot是对Cache打的快照，这个机制最早是在下面的PR中引入：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/67308">https://github.com/kubernetes/kubernetes/pull/67308</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/issues/67260">https://github.com/kubernetes/kubernetes/issues/67260</a></li>
</ul>
<p>通过查看issue可以知道，这是在跑测试的时候，发现的缓存不同步，导致的调度失败，究其本质原因，是因为在某一个Pod调度过程中，其使用的cache发生了变化，尤其是在pod和node发生变更时，cache会实时更新，导致调度前后获取的信息不一致，才出现了问题。因此解决办法就是给Cache打一个快照，将Cache中的数据clone一份到Snapshot中，并且使用一个单调递增的值来标识这个快照的版本，即Snapshot中的generation字段，某个版本的Snapshot中的数据是不会发生变化的。</p>
<p>Snapshot发展到现在，已经将调度过程中，需要查询node和pod信息的地方，全都切换到了snaphost：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/issues/83922">https://github.com/kubernetes/kubernetes/issues/83922</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/83921">https://github.com/kubernetes/kubernetes/pull/83921</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/84293">https://github.com/kubernetes/kubernetes/pull/84293</a></li>
</ul>
<p>切换到Snaphost之后，对性能有一个明显的好处，就是因为Snapshot是只读的，访问它的数据是不需要加锁的，这样在调度过程中，将很多地方实现了“无锁化”，将性能又提升了2倍。</p>
<h3 id="3-Cache中为什么要用双向链表"><a href="#3-Cache中为什么要用双向链表" class="headerlink" title="3. Cache中为什么要用双向链表"></a>3. Cache中为什么要用双向链表</h3><p>所谓双向链表，就是schedulerCache结构中的成员变量：<code>headNode *nodeInfoListItem</code>所表示的结构，headNode只存储链表中的第一个元素，通过next和prev指针，来指向下一个和前一个元素，但是需要注意的是链表中存储的实际是nodeInfo的地址，并不是实际的数据。我们在上大学的时候，在数据结构课程上，就学习过双向链表这个结构，知道它的主要特点是体现在遍历上，即可以后序遍历，又可以前序遍历，并且插入删除节点，只是改变指针的指向，并没有实际移动数据，那这里引入双向链表又是为何呢？来看看引入双向链表的pr：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/74041">https://github.com/kubernetes/kubernetes/pull/74041</a></li>
</ul>
<p>这个pr说，通过测试发现，在给cache打snapshot时，花费了较多的CPU时间，通过引入双向列表，将最近更新的node放到双向列表的列表头，再结合Snapshot Generation机制，大大缩减了给Cache打快照的时间，我们来看下给Cache打快照的核心代码逻辑变化：</p>
<p><img src="/assets/kubernetes_scheduler_cache_snapshot.png"></p>
<p>以前是遍历cache中的nodes列表，现在变成了遍历这个双向列表，而一但发现node中的generation值比snapshot中的generation值小的时候，就退出遍历，之所以能退出遍历，是因为所有对node的最近更新都被放到了链表头，而每次更新node，node中的generation值都会单调递增，如果在向后遍历node链表时，发现generation值比打快照时的值低了，那说明后面的node没有被更新过，就不需要再往后去更新了，只更新打快照之后，更新过的node就可以了。所以这里引入双链表，就是为了能够将“最近更新”过的Node放到一起，遍历时，只遍历这些更新过的node即可，而不用向以前一样，全量遍历整列表。当pod或者node有更新时，会将对应的更新之后的node节点放到链表头部位置，来看下这个移动的过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span></span> moveNodeInfoToHead(name <span class="type">string</span>) &#123;</span><br><span class="line">    ni, ok := cache.nodes[name]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        klog.Errorf(<span class="string">&quot;No NodeInfo with name %v found in the cache&quot;</span>, name)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if the node info list item is already at the head, we are done.</span></span><br><span class="line">    <span class="keyword">if</span> ni == cache.headNode &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ni.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">        ni.prev.next = ni.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ni.next != <span class="literal">nil</span> &#123;</span><br><span class="line">        ni.next.prev = ni.prev</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> cache.headNode != <span class="literal">nil</span> &#123;</span><br><span class="line">        cache.headNode.prev = ni</span><br><span class="line">    &#125;</span><br><span class="line">    ni.next = cache.headNode</span><br><span class="line">    ni.prev = <span class="literal">nil</span></span><br><span class="line">    cache.headNode = ni</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过局部遍历代替全量遍历，加快了Cache打快照的时间，性能提升了20%，在5000个node的规模下，调度10000个pod，延迟从8.5ms降低到了6.7ms。</p>
<p>不过，One more thing，还有一个未解之谜，就是为什么是“双向”列表？看代码这里遍历只用到了后序遍历，并没有找到在哪用到了前序遍历。如果只是后序遍历的话，那单向列表完全就满足需求了啊，用双向列表不是增加了复杂度吗？难道是作者在炫技？或者是后序可能还会用到后序遍历，这里只是留下了口子？迷惑的行为又增加了。。。</p>
<h3 id="4-Cache中的nodeTree是做什么用的"><a href="#4-Cache中的nodeTree是做什么用的" class="headerlink" title="4. Cache中的nodeTree是做什么用的"></a>4. Cache中的nodeTree是做什么用的</h3><p>nodeTree主要是考虑到node跨<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/setup/best-practices/multiple-zones/">多zone</a>而设计的，甚至还有pod针对zone的亲和性和反亲和性，所以在给某个pod选择合适的node时，node的遍历顺序还是很重要的，nodeTree主要决定了node的遍历顺序，其结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodeTree is a tree-like data structure that holds node names in each zone. Zone names are</span></span><br><span class="line"><span class="comment">// keys to &quot;NodeTree.tree&quot; and values of &quot;NodeTree.tree&quot; are arrays of node names.</span></span><br><span class="line"><span class="comment">// NodeTree is NOT thread-safe, any concurrent updates/reads from it must be synchronized by the caller.</span></span><br><span class="line"><span class="comment">// It is used only by schedulerCache, and should stay as such.</span></span><br><span class="line"><span class="keyword">type</span> nodeTree <span class="keyword">struct</span> &#123;</span><br><span class="line">    tree      <span class="keyword">map</span>[<span class="type">string</span>]*nodeArray <span class="comment">// a map from zone (region-zone) to an array of nodes in the zone.</span></span><br><span class="line">    zones     []<span class="type">string</span>              <span class="comment">// a list of all the zones in the tree (keys)</span></span><br><span class="line">    zoneIndex <span class="type">int</span></span><br><span class="line">    numNodes  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nodeArray is a struct that has nodes that are in a zone.</span></span><br><span class="line"><span class="comment">// We use a slice (as opposed to a set/map) to store the nodes because iterating over the nodes is</span></span><br><span class="line"><span class="comment">// a lot more frequent than searching them by name.</span></span><br><span class="line"><span class="keyword">type</span> nodeArray <span class="keyword">struct</span> &#123;</span><br><span class="line">    nodes     []<span class="type">string</span></span><br><span class="line">    lastIndex <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓tree，其实就是zone到该zone所包含node列表的一个映射，遍历node列表时，是以轮询zone的方式进行遍历的，以Index来标识当前遍历到哪个zone或者node了，比如<code>zone1(node1, node2, node3), zone2(node4, node5, node6)</code>，那么所谓”轮询zone”的遍历方式，就是以<code>node1, node4, node2, node5, node3, node6</code>的顺序进行遍历。</p>
<p>而因为调度时，都需要切换到使用snapshot里的信息，所以nodeTree也需要被打快照到Snapshot中，相关逻辑在下面的pr中实现：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/84014">https://github.com/kubernetes/kubernetes/pull/84014</a></li>
</ul>
<p>但是该快照没有直接使用nodeTree这个结构，而是按照nodeTree的遍历顺序，将其变换成了一维的数组，即Snapshot结构体中的nodeInfoList，这样，在调度时，就可以直接遍历这个nodeInfoList了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allNodes, err := g.nodeInfoSnapshot.NodeInfos().List()</span><br></pre></td></tr></table></figure>

<p>通过将nodeTree打快照到Snapshot中，就可以进一步“无锁化”，将性能又提高了3%。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的性能优化过程可以看出来，引入Cache将性能提升了一个大台阶，在Cache基础上，又引入了Snapshot，逐步实现了“无锁化”的调度过程，将调度延迟从200ms降低到了6.7ms，满足了大多数集群规模对调度性能的要求。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Kubernetes Scheduler性能优化之Cache</p><p><a href="https://hackerain.me/2020/12/20/kubernetes/kube-scheduler-cache.html">https://hackerain.me/2020/12/20/kubernetes/kube-scheduler-cache.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>hackerain</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-12-20</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-10-26</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/kubernetes/">kubernetes</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/12/21/kubernetes/kube-scheduler-framework.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Kubernetes Scheduler Scheduling Framework</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/12/19/kubernetes/kube-scheduler-overview.html"><span class="level-item">Kubernetes Scheduler机制概览</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/assets/avatar.jpg" alt="开心BOY"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">开心BOY</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">45</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="/about" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/hackerain"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="知识星球" href="https://t.zsxq.com/0bWmBFDpu"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#背景"><span class="level-left"><span class="level-item">1</span><span class="level-item">背景</span></span></a></li><li><a class="level is-mobile" href="#数据结构"><span class="level-left"><span class="level-item">2</span><span class="level-item">数据结构</span></span></a></li><li><a class="level is-mobile" href="#原因探究"><span class="level-left"><span class="level-item">3</span><span class="level-item">原因探究</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-为什么要引入Cache"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">1. 为什么要引入Cache</span></span></a></li><li><a class="level is-mobile" href="#2-为什么要引入Snapshot"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">2. 为什么要引入Snapshot</span></span></a></li><li><a class="level is-mobile" href="#3-Cache中为什么要用双向链表"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">3. Cache中为什么要用双向链表</span></span></a></li><li><a class="level is-mobile" href="#4-Cache中的nodeTree是做什么用的"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">4. Cache中的nodeTree是做什么用的</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">4</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-18T00:00:00.000Z">2023-11-18</time></p><p class="title"><a href="/2023/11/18/kubernetes/kube-controller-runtime.html">Kubernetes controller-runtime 介绍</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-12T00:00:00.000Z">2023-11-12</time></p><p class="title"><a href="/2023/11/12/kubernetes/kube-versioning-codec.html">Kubernetes API Codec 解析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-11T00:00:00.000Z">2023-11-11</time></p><p class="title"><a href="/2023/11/11/kubernetes/kube-versioning-scheme.html">Kubernetes API Scheme 解析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-28T00:00:00.000Z">2023-10-28</time></p><p class="title"><a href="/2023/10/28/kubernetes/kube-versioning.html">Kubernetes API 多版本和序列化</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-26T00:00:00.000Z">2022-09-26</time></p><p class="title"><a href="/2022/09/26/elasticsearch/elasticsearch_large_text_field.html">Elasticsearch大文本字段(large text field)优化方案</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/"><span class="level-start"><span class="level-item">2017</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ceph/"><span class="tag">ceph</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/elasticsearch/"><span class="tag">elasticsearch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kubernetes/"><span class="tag">kubernetes</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/openstack/"><span class="tag">openstack</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/operations/"><span class="tag">operations</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/umi/"><span class="tag">umi</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/assets/logo.jpg" alt="开心BOY" height="28"></a><p class="is-size-7"><span>&copy; 2023 hackerain</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hackerain"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
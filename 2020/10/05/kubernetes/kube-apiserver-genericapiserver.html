<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Kubernetes APIServer GenericAPIServer - 开心BOY</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="开心BOY"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="开心BOY"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="在Kubernetes APIServer 机制概述中我们介绍到了APIServer的本质其实是一个实现了RESTful API的WebServer，它使用golang的net&amp;#x2F;http的Server构建，并且Handler是其中非常重要的概念，此外，又简单介绍了APIServer的扩展机制，即Aggregator, APIExtensions以及KubeAPIServer这三者之间通过Deleg"><meta property="og:type" content="blog"><meta property="og:title" content="Kubernetes APIServer GenericAPIServer"><meta property="og:url" content="https://hackerain.me/2020/10/05/kubernetes/kube-apiserver-genericapiserver.html"><meta property="og:site_name" content="开心BOY"><meta property="og:description" content="在Kubernetes APIServer 机制概述中我们介绍到了APIServer的本质其实是一个实现了RESTful API的WebServer，它使用golang的net&amp;#x2F;http的Server构建，并且Handler是其中非常重要的概念，此外，又简单介绍了APIServer的扩展机制，即Aggregator, APIExtensions以及KubeAPIServer这三者之间通过Deleg"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hackerain.me/img/og_image.png"><meta property="article:published_time" content="2020-10-05T00:00:00.000Z"><meta property="article:modified_time" content="2023-10-28T14:12:29.408Z"><meta property="article:author" content="hackerain"><meta property="article:tag" content="kubernetes"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hackerain.me/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hackerain.me/2020/10/05/kubernetes/kube-apiserver-genericapiserver.html"},"headline":"Kubernetes APIServer GenericAPIServer","image":["https://hackerain.me/img/og_image.png"],"datePublished":"2020-10-05T00:00:00.000Z","dateModified":"2023-10-28T14:12:29.408Z","author":{"@type":"Person","name":"hackerain"},"publisher":{"@type":"Organization","name":"开心BOY","logo":{"@type":"ImageObject","url":"https://hackerain.me/assets/logo.jpg"}},"description":"在Kubernetes APIServer 机制概述中我们介绍到了APIServer的本质其实是一个实现了RESTful API的WebServer，它使用golang的net&#x2F;http的Server构建，并且Handler是其中非常重要的概念，此外，又简单介绍了APIServer的扩展机制，即Aggregator, APIExtensions以及KubeAPIServer这三者之间通过Deleg"}</script><link rel="canonical" href="https://hackerain.me/2020/10/05/kubernetes/kube-apiserver-genericapiserver.html"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="开心BOY" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/assets/logo.jpg" alt="开心BOY" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-10-05T00:00:00.000Z" title="10/5/2020, 12:00:00 AM">2020-10-05</time>发表</span><span class="level-item"><time dateTime="2023-10-28T14:12:29.408Z" title="10/28/2023, 2:12:29 PM">2023-10-28</time>更新</span><span class="level-item">32 分钟读完 (大约4829个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Kubernetes APIServer GenericAPIServer</h1><div class="content"><p>在<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/08/09/kubernetes/kube-apiserver-overview.html">Kubernetes APIServer 机制概述</a>中我们介绍到了APIServer的本质其实是一个实现了RESTful API的WebServer，它使用golang的<a target="_blank" rel="noopener" href="https://golang.org/pkg/net/http/">net/http</a>的Server构建，并且Handler是其中非常重要的概念，此外，又简单介绍了APIServer的扩展机制，即Aggregator, APIExtensions以及KubeAPIServer这三者之间通过Delegation的方式实现了扩展。</p>
<span id="more"></span>

<p>在<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/09/19/kubernetes/kube-apiserver-storage-overview.html">Kubernetes APIServer Storage 框架解析</a>中，我们介绍了APIServer相关的存储框架，每个API对象，都有对应的<code>REST store</code>以及<code>etcd store</code>。</p>
<p>而本篇文章介绍到的<code>GenericAPIServer</code>跟上面两个内容紧密相关，它是APIServer的基础，Aggregator, APIExtensions以及KubeAPIServer每个都包含一个GenericAPIServer，他们各自的API对象都以Group的形式，注册进GenericAPIServer中，并且组织成最终的Handler，然后结合<code>net/http Server</code>，将APIServer运行起来，因此，掌握<code>GenericAPIServer</code>有助于理解APIServer的扩展机制以及运行原理，本篇文章重点介绍<code>GenericAPIServer</code>的以下四方面内容：</p>
<ul>
<li>Handler的构建</li>
<li>API对象的注册</li>
<li>Handler的处理</li>
<li>PostStartHook</li>
</ul>
<p>其相关的代码在<a target="_blank" rel="noopener" href="https://github.com/kubernetes/apiserver">apiserver</a>库中的<code>apiserver/pkg/server/</code>目录下。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="APIGroupInfo"><a href="#APIGroupInfo" class="headerlink" title="APIGroupInfo"></a>APIGroupInfo</h3><p>在API对象进行注册时，都被组织成<code>APIGroupInfo</code>的结构体形式，这里面包含了所有注册需要的信息，其定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># apiserver/pkg/server/genericapiserver.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> APIGroupInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    PrioritizedVersions []schema.GroupVersion</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Info about the resources in this group. It&#x27;s a map from version to resource to the storage.</span></span><br><span class="line">    VersionedResourcesStorageMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]rest.Storage</span><br><span class="line"></span><br><span class="line">    OptionsExternalVersion *schema.GroupVersion</span><br><span class="line">    MetaGroupVersion *schema.GroupVersion</span><br><span class="line"></span><br><span class="line">    Scheme *runtime.Scheme</span><br><span class="line">    NegotiatedSerializer runtime.NegotiatedSerializer</span><br><span class="line">    ParameterCodec runtime.ParameterCodec</span><br><span class="line"></span><br><span class="line">    StaticOpenAPISpec *spec.Swagger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面最关键的信息就是<code>VersionedResourcesStorageMap</code>这个属性，如注释所说，它是一个从<code>version</code>映射到<code>resource</code>，然后再从<code>resource</code>映射到<code>rest storage</code>的两层映射，比如<code>batch</code>组中的<code>cronjobs</code>资源，有<code>v1beta1</code>和<code>v2alpha1</code>两个版本，则在该map中，则分别有两个映射，<code>v1beta1</code> -&gt; <code>cronjobs</code> -&gt; <code>cronjobs rest storage</code>，以及<code>v2alpha1</code> -&gt; <code>cronjobs</code> -&gt; <code>cronjobs rest storage</code>，这里说的<code>rest storage</code>就是之前介绍到的<code>rest store</code>，每一个版本的API对象，都会有自己的一个<code>rest store</code>，从这里就可以看到，Kubernetes对多版本是如何管理的，本质上，它把不同版本的API对象，其实当成不同的对象，有自己独立的存储。</p>
<h3 id="go-restful"><a href="#go-restful" class="headerlink" title="go-restful"></a>go-restful</h3><p>Kubernetes使用<code>go-restful</code>这个第三方库对核心的RESTful API进行了实现，其基础知识以及在Kubernetes中的用法，可阅读这篇文章：<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/09/28/golang/go-restful-overview.html">go-restful简析</a>，这里不再介绍。</p>
<h3 id="NonGoRestfulMux"><a href="#NonGoRestfulMux" class="headerlink" title="NonGoRestfulMux"></a>NonGoRestfulMux</h3><p>NonGoRestfulMux是Kubernetes APIServer中非核心API使用的RESTful框架，因为没有使用go-restful实现，因此称之为NonGoRestfulMux，其详细介绍，见<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/10/04/kubernetes/kube-apiserver-nongorestfulmux.html">Kubernetes APIServer NonGoRestfulMux</a>。</p>
<h2 id="Handler的构建"><a href="#Handler的构建" class="headerlink" title="Handler的构建"></a>Handler的构建</h2><p>这里说的Handler指的是最终<code>net/http Server</code>要运行的Handler，它在GenericAPIServer中被构建出来，首先我们来看下GenericAPIServer的结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/server/genericapiserver.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GenericAPIServer <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// SecureServingInfo holds configuration of the TLS server.</span></span><br><span class="line">    SecureServingInfo *SecureServingInfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;Outputs&quot;</span></span><br><span class="line">    <span class="comment">// Handler holds the handlers being used by this API server</span></span><br><span class="line">    Handler *APIServerHandler</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegationTarget is the next delegate in the chain. This is never nil.</span></span><br><span class="line">    delegationTarget DelegationTarget</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个GenericAPIServer包含的信息非常的多，上面结构体并没有列出全部属性，在这里我们只关注几个重点信息就行：</p>
<ul>
<li><code>SecureServingInfo *SecureServingInfo</code>: 这里面包含的是运行APIServer需要的TLS相关的信息</li>
<li><code>Handler *APIServerHandler</code>: 这个就是要运行APIServer需要使用到的Handler，各个API对象向APIServer中注册，说的就是向Handler注册，它是最重要的信息</li>
<li><code>delegationTarget DelegationTarget</code>: 这个是扩展机制中用到的，指定该GenericAPIServer的delegation是谁</li>
</ul>
<p>再来看下<code>Handler *APIServerHandler</code>的结构体信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/server/handler.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> APIServerHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// FullHandlerChain is the one that is eventually served with.  It should include the full filter</span></span><br><span class="line">    <span class="comment">// chain and then call the Director.</span></span><br><span class="line">    FullHandlerChain http.Handler</span><br><span class="line">    <span class="comment">// The registered APIs.  InstallAPIs uses this.  Other servers probably shouldn&#x27;t access this directly.</span></span><br><span class="line">    GoRestfulContainer *restful.Container</span><br><span class="line">    <span class="comment">// NonGoRestfulMux is the final HTTP handler in the chain.</span></span><br><span class="line">    <span class="comment">// It comes after all filters and the API handling</span></span><br><span class="line">    <span class="comment">// This is where other servers can attach handler to various parts of the chain.</span></span><br><span class="line">    NonGoRestfulMux *mux.PathRecorderMux</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Director is here so that we can properly handle fall through and proxy cases.</span></span><br><span class="line">    <span class="comment">// This looks a bit bonkers, but here&#x27;s what&#x27;s happening.  We need to have /apis handling registered in gorestful in order to have</span></span><br><span class="line">    <span class="comment">// swagger generated for compatibility.  Doing that with `/apis` as a webservice, means that it forcibly 404s (no defaulting allowed)</span></span><br><span class="line">    <span class="comment">// all requests which are not /apis or /apis/.  We need those calls to fall through behind goresful for proper delegation.  Trying to</span></span><br><span class="line">    <span class="comment">// register for a pattern which includes everything behind it doesn&#x27;t work because gorestful negotiates for verbs and content encoding</span></span><br><span class="line">    <span class="comment">// and all those things go crazy when gorestful really just needs to pass through.  In addition, openapi enforces unique verb constraints</span></span><br><span class="line">    <span class="comment">// which we don&#x27;t fit into and it still muddies up swagger.  Trying to switch the webservices into a route doesn&#x27;t work because the</span></span><br><span class="line">    <span class="comment">//  containing webservice faces all the same problems listed above.</span></span><br><span class="line">    <span class="comment">// This leads to the crazy thing done here.  Our mux does what we need, so we&#x27;ll place it in front of gorestful.  It will introspect to</span></span><br><span class="line">    <span class="comment">// decide if the route is likely to be handled by goresful and route there if needed.  Otherwise, it goes to PostGoRestful mux in</span></span><br><span class="line">    <span class="comment">// order to handle &quot;normal&quot; paths and delegation. Hopefully no API consumers will ever have to deal with this level of detail.  I think</span></span><br><span class="line">    <span class="comment">// we should consider completely removing gorestful.</span></span><br><span class="line">    <span class="comment">// Other servers should only use this opaquely to delegate to an API server.</span></span><br><span class="line">    Director http.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAPIServerHandler</span><span class="params">(name <span class="type">string</span>, s runtime.NegotiatedSerializer, handlerChainBuilder HandlerChainBuilderFn, notFoundHandler http.Handler)</span></span> *APIServerHandler &#123;</span><br><span class="line">    nonGoRestfulMux := mux.NewPathRecorderMux(name)</span><br><span class="line">    <span class="keyword">if</span> notFoundHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">        nonGoRestfulMux.NotFoundHandler(notFoundHandler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gorestfulContainer := restful.NewContainer()</span><br><span class="line">    gorestfulContainer.ServeMux = http.NewServeMux()</span><br><span class="line">    gorestfulContainer.Router(restful.CurlyRouter&#123;&#125;) <span class="comment">// e.g. for proxy/&#123;kind&#125;/&#123;name&#125;/&#123;*&#125;</span></span><br><span class="line">    gorestfulContainer.RecoverHandler(<span class="function"><span class="keyword">func</span><span class="params">(panicReason <span class="keyword">interface</span>&#123;&#125;, httpWriter http.ResponseWriter)</span></span> &#123;</span><br><span class="line">        logStackOnRecover(s, panicReason, httpWriter)</span><br><span class="line">    &#125;)</span><br><span class="line">    gorestfulContainer.ServiceErrorHandler(<span class="function"><span class="keyword">func</span><span class="params">(serviceErr restful.ServiceError, request *restful.Request, response *restful.Response)</span></span> &#123;</span><br><span class="line">        serviceErrorHandler(s, serviceErr, request, response)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    director := director&#123;</span><br><span class="line">        name:               name,</span><br><span class="line">        goRestfulContainer: gorestfulContainer,</span><br><span class="line">        nonGoRestfulMux:    nonGoRestfulMux,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;APIServerHandler&#123;</span><br><span class="line">        FullHandlerChain:   handlerChainBuilder(director),</span><br><span class="line">        GoRestfulContainer: gorestfulContainer,</span><br><span class="line">        NonGoRestfulMux:    nonGoRestfulMux,</span><br><span class="line">        Director:           director,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，APIServerHandler中包含一个go-restful构建出来的Container，<code>GoRestfulContainer</code>，以及一个PathRecorderMux构建出来的<code>NonGoRestfulMux</code>，注意，他们都是指针类型的，此外还有一个<code>FullHandlerChain</code>以及<code>Director</code>，都是对一个director结构体的引用，来看看这个结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/server/handler.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> director <span class="keyword">struct</span> &#123;</span><br><span class="line">    name               <span class="type">string</span></span><br><span class="line">    goRestfulContainer *restful.Container</span><br><span class="line">    nonGoRestfulMux    *mux.PathRecorderMux</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d director)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它里面又包含了<code>goRestfulContainer</code>和<code>nonGoRestfulMux</code>，但是注意他们也是以指针的形式作为成员变量的，并且该director还实现了ServeHTTP()方法，即director还是一个Handler。上面的APIServerHandler中也包含了<code>GoRestfulContainer</code>, <code>NonGoRestfulMux</code>的指针类型的成员变量，他们指针指向的其实是同一个实体，即在NewAPIServerHandler()方法中New出来的实体。为什么在APIServerHandler中已经有这两个变量了，还要再单独生成一个director结构体来引用这两个变量，其实这跟他们的用法有关，下面会讲到。</p>
<p>现在先来说下<code>FullHandlerChain</code>和<code>Director</code>的区别，他们两个都是对director的引用，区别是FullHandlerChain在director外面还包围了一层Chain，我们来看看这个Chain是什么：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/server/config.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">handlerChainBuilder := <span class="function"><span class="keyword">func</span><span class="params">(handler http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">    <span class="keyword">return</span> c.BuildHandlerChainFunc(handler, c.Config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apiServerHandler := NewAPIServerHandler(name, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultBuildHandlerChain</span><span class="params">(apiHandler http.Handler, c *Config)</span></span> http.Handler &#123;</span><br><span class="line">    handler := genericapifilters.WithAuthorization(apiHandler, c.Authorization.Authorizer, c.Serializer)</span><br><span class="line">    <span class="keyword">if</span> c.FlowControl != <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = genericfilters.WithPriorityAndFairness(handler, c.LongRunningFunc, c.FlowControl)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler = genericfilters.WithMaxInFlightLimit(handler, c.MaxRequestsInFlight, c.MaxMutatingRequestsInFlight, c.LongRunningFunc)</span><br><span class="line">    &#125;</span><br><span class="line">    handler = genericapifilters.WithImpersonation(handler, c.Authorization.Authorizer, c.Serializer)</span><br><span class="line">    handler = genericapifilters.WithAudit(handler, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)</span><br><span class="line">    failedHandler := genericapifilters.Unauthorized(c.Serializer)</span><br><span class="line">    failedHandler = genericapifilters.WithFailedAuthenticationAudit(failedHandler, c.AuditBackend, c.AuditPolicyChecker)</span><br><span class="line">    handler = genericapifilters.WithAuthentication(handler, c.Authentication.Authenticator, failedHandler, c.Authentication.APIAudiences)</span><br><span class="line">    handler = genericfilters.WithCORS(handler, c.CorsAllowedOriginList, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">    handler = genericfilters.WithTimeoutForNonLongRunningRequests(handler, c.LongRunningFunc, c.RequestTimeout)</span><br><span class="line">    handler = genericfilters.WithWaitGroup(handler, c.LongRunningFunc, c.HandlerChainWaitGroup)</span><br><span class="line">    handler = genericapifilters.WithRequestInfo(handler, c.RequestInfoResolver)</span><br><span class="line">    <span class="keyword">if</span> c.SecureServing != <span class="literal">nil</span> &amp;&amp; !c.SecureServing.DisableHTTP2 &amp;&amp; c.GoawayChance &gt; <span class="number">0</span> &#123;</span><br><span class="line">        handler = genericfilters.WithProbabilisticGoaway(handler, c.GoawayChance)</span><br><span class="line">    &#125;</span><br><span class="line">    handler = genericapifilters.WithAuditAnnotations(handler, c.AuditBackend, c.AuditPolicyChecker)</span><br><span class="line">    handler = genericapifilters.WithCacheControl(handler)</span><br><span class="line">    handler = genericfilters.WithPanicRecovery(handler)</span><br><span class="line">    <span class="keyword">return</span> handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>BuildHandlerChainFunc</code>默认为<code>DefaultBuildHandlerChain()</code>，看到该方法中传入一个Handler，然后在该Handler外面，像包洋葱一样，包了一层又一层的filter，这些filter的作用其实就是在请求到来时，在Handler真正处理之前，先要经过的一系列认证，授权，审计等等检查，如果通过了，才会由最终的Handler来处理该请求，没通过，则会报相应的错误，可见，认证授权等操作，就是在这个阶段生效的，经过一系列filter的包装，最终构建出来的Handler，就是<code>FullHandlerChain</code>，而director就是这个被层层包装的Handler。而Director这个成员变量，没有被filter包装，这样通过Director就可以绕过认证授权这些filter，直接由Handler进行处理。那么问题来了，难道还有请求不需要认证授权的？这个Director存在的意义是什么？的确是有请求不需要认证授权，这就涉及到APIServer的扩展机制了，后面会介绍到。</p>
<p>小结一下，APIServerHandler中包含4个成员变量，FullHandlerChain和Director其实是两个Handler，一个是带认证授权这些filter的，一个是不带的，都是对director的引用，而GoRestfulContainer和NonGoRestfulMux则分别是指针类型的引用，指向真正的goRestfulContainer和nonGoRestfulMux实体，同时这两个实体，又被director所引用。</p>
<p>从这里就大概可以看出GoRestfulContainer和NonGoRestfulMux这两个变量在这里的作用了，在上层向goRestfulContainer和nonGoRestfulMux实体中注册API对象时，就是通过调用这两个变量来对真正的实体进行操作的，如下面的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apiGroupVersion.InstallREST(s.Handler.GoRestfulContainer)</span><br></pre></td></tr></table></figure>

<p>因为是指针，都指向同一个实体，这样director作为Handler也就能用到注册进来的API对象了。</p>
<h2 id="API对象的注册"><a href="#API对象的注册" class="headerlink" title="API对象的注册"></a>API对象的注册</h2><p>所谓API对象的注册，其实就是向GenericAPIServer的Handler中添加各个API对象的WebService和Route，GenericAPIServer提供了<code>InstallLegacyAPIGroup(), InstallAPIGroups(), InstallAPIGroup()</code>这三个方法，供外部调用，向其中注册APIGroupInfo，APIGroupInfo在上面基础知识中介绍过，里面存储了这个APIGroup的version, resource以及对应的REST storage实体，上面的三个方法，最后都会调用到同一个内部函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/server/genericapiserver.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span></span> installAPIResources(apiPrefix <span class="type">string</span>, apiGroupInfo *APIGroupInfo, openAPIModels openapiproto.Models) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, groupVersion := <span class="keyword">range</span> apiGroupInfo.PrioritizedVersions &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(apiGroupInfo.VersionedResourcesStorageMap[groupVersion.Version]) == <span class="number">0</span> &#123;</span><br><span class="line">            klog.Warningf(<span class="string">&quot;Skipping API %v because it has no resources.&quot;</span>, groupVersion)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        apiGroupVersion := s.getAPIGroupVersion(apiGroupInfo, groupVersion, apiPrefix)</span><br><span class="line">        <span class="keyword">if</span> apiGroupInfo.OptionsExternalVersion != <span class="literal">nil</span> &#123;</span><br><span class="line">            apiGroupVersion.OptionsExternalVersion = apiGroupInfo.OptionsExternalVersion</span><br><span class="line">        &#125;</span><br><span class="line">        apiGroupVersion.OpenAPIModels = openAPIModels</span><br><span class="line">        apiGroupVersion.MaxRequestBodyBytes = s.maxRequestBodyBytes</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := apiGroupVersion.InstallREST(s.Handler.GoRestfulContainer); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to setup API %v: %v&quot;</span>, apiGroupInfo, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span></span> getAPIGroupVersion(apiGroupInfo *APIGroupInfo, groupVersion schema.GroupVersion, apiPrefix <span class="type">string</span>) (*genericapi.APIGroupVersion, <span class="type">error</span>) &#123;</span><br><span class="line">    storage := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]rest.Storage)</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> apiGroupInfo.VersionedResourcesStorageMap[groupVersion.Version] &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.ToLower(k) != k &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;resource names must be lowercase only, not %q&quot;</span>, k)</span><br><span class="line">        &#125;</span><br><span class="line">        storage[k] = v</span><br><span class="line">    &#125;</span><br><span class="line">    version := s.newAPIGroupVersion(apiGroupInfo, groupVersion)</span><br><span class="line">    version.Root = apiPrefix</span><br><span class="line">    version.Storage = storage</span><br><span class="line">    <span class="keyword">return</span> version, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span></span> newAPIGroupVersion(apiGroupInfo *APIGroupInfo, groupVersion schema.GroupVersion) *genericapi.APIGroupVersion &#123;</span><br><span class="line"></span><br><span class="line">    allServedVersionsByResource := <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> version, resourcesInVersion := <span class="keyword">range</span> apiGroupInfo.VersionedResourcesStorageMap &#123;</span><br><span class="line">        <span class="keyword">for</span> resource := <span class="keyword">range</span> resourcesInVersion &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(groupVersion.Group) == <span class="number">0</span> &#123;</span><br><span class="line">                allServedVersionsByResource[resource] = <span class="built_in">append</span>(allServedVersionsByResource[resource], version)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                allServedVersionsByResource[resource] = <span class="built_in">append</span>(allServedVersionsByResource[resource], fmt.Sprintf(<span class="string">&quot;%s/%s&quot;</span>, groupVersion.Group, version))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;genericapi.APIGroupVersion&#123;</span><br><span class="line">        GroupVersion:                groupVersion,</span><br><span class="line">        AllServedVersionsByResource: allServedVersionsByResource,</span><br><span class="line">        MetaGroupVersion:            apiGroupInfo.MetaGroupVersion,</span><br><span class="line"></span><br><span class="line">        ParameterCodec:        apiGroupInfo.ParameterCodec,</span><br><span class="line">        Serializer:            apiGroupInfo.NegotiatedSerializer,</span><br><span class="line">        Creater:               apiGroupInfo.Scheme,</span><br><span class="line">        Convertor:             apiGroupInfo.Scheme,</span><br><span class="line">        ConvertabilityChecker: apiGroupInfo.Scheme,</span><br><span class="line">        UnsafeConvertor:       runtime.UnsafeObjectConvertor(apiGroupInfo.Scheme),</span><br><span class="line">        Defaulter:             apiGroupInfo.Scheme,</span><br><span class="line">        Typer:                 apiGroupInfo.Scheme,</span><br><span class="line">        Namer:                 runtime.Namer(meta.NewAccessor()),</span><br><span class="line"></span><br><span class="line">        EquivalentResourceRegistry: s.EquivalentResourceRegistry,</span><br><span class="line"></span><br><span class="line">        Admit:             s.admissionControl,</span><br><span class="line">        MinRequestTimeout: s.minRequestTimeout,</span><br><span class="line">        Authorizer:        s.Authorizer,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个函数的逻辑，就是遍历APIGroupInfo中的version，按照version的维度来进行安装API对象，即构建出来一个APIGroupVersion，将该版本的resource和REST storage存储到该结构体中，然后执行安装操作: <code>apiGroupVersion.InstallREST(s.Handler.GoRestfulContainer);</code>，可以看到这里传的就是上面说到的<code>APIServerHandler</code>中的<code>GoRestfulContainer</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/endpoints/groupversion.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *APIGroupVersion)</span></span> InstallREST(container *restful.Container) <span class="type">error</span> &#123;</span><br><span class="line">    prefix := path.Join(g.Root, g.GroupVersion.Group, g.GroupVersion.Version)</span><br><span class="line">    installer := &amp;APIInstaller&#123;</span><br><span class="line">        group:             g,</span><br><span class="line">        prefix:            prefix,</span><br><span class="line">        minRequestTimeout: g.MinRequestTimeout,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apiResources, ws, registrationErrors := installer.Install()</span><br><span class="line">    versionDiscoveryHandler := discovery.NewAPIVersionHandler(g.Serializer, g.GroupVersion, staticLister&#123;apiResources&#125;)</span><br><span class="line">    versionDiscoveryHandler.AddToWebService(ws)</span><br><span class="line">    container.Add(ws)</span><br><span class="line">    <span class="keyword">return</span> utilerrors.NewAggregate(registrationErrors)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，又构造了一个APIInstaller结构体，将APIGroupVersion的指针传给它，由它去执行安装操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/endpoints/installer.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *APIInstaller)</span></span> Install() ([]metav1.APIResource, *restful.WebService, []<span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> apiResources []metav1.APIResource</span><br><span class="line">    <span class="keyword">var</span> errors []<span class="type">error</span></span><br><span class="line">    ws := a.newWebService()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the paths in a deterministic (sorted) order to get a deterministic swagger spec.</span></span><br><span class="line">    paths := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(a.group.Storage))</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> path := <span class="keyword">range</span> a.group.Storage &#123;</span><br><span class="line">        paths[i] = path</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Strings(paths)</span><br><span class="line">    <span class="keyword">for</span> _, path := <span class="keyword">range</span> paths &#123;</span><br><span class="line">        apiResource, err := a.registerResourceHandlers(path, a.group.Storage[path], ws)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            errors = <span class="built_in">append</span>(errors, fmt.Errorf(<span class="string">&quot;error in registering resource: %s, %v&quot;</span>, path, err))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> apiResource != <span class="literal">nil</span> &#123;</span><br><span class="line">            apiResources = <span class="built_in">append</span>(apiResources, *apiResource)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> apiResources, ws, errors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里面New了一个WebService，然后遍历group中的REST storage，将storage中的path取出来，进行排序，然后再遍历这个path数组，针对每一个<code>path: storage</code>向WebService中执行注册操作，即<code>registerResourceHandlers()</code>，这就来到了最关键的地方，这是一个非常长的函数，这里面，对Storage进行类型转换，因为Storage实现了rest store的各种接口，所以首先将其转换成getter, creater, lister, updater等类型，分别对应该API对象在数据库层面的增删查改等操作，然后构造对应的Handler，然后再创建WebService的Route，最后将其添加到WebService中，我们以getter为例，简单看下这个过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/endpoints/installer.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">(a *APIInstaller) registerResourceHandlers(path <span class="type">string</span>, storage rest.Storage, ws *restful.WebService) &#123;</span><br><span class="line">    ......</span><br><span class="line">    getter, isGetter := storage.(rest.Getter)</span><br><span class="line">    ......</span><br><span class="line">    handler = restfulGetResource(getter, exporter, reqScope)</span><br><span class="line">    ......</span><br><span class="line">    route := ws.GET(action.Path).To(handler)</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> _, route := <span class="keyword">range</span> routes &#123;</span><br><span class="line">        ws.Route(route)</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restfulGetResource</span><span class="params">(r rest.Getter, e rest.Exporter, scope handlers.RequestScope)</span></span> restful.RouteFunction &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(req *restful.Request, res *restful.Response)</span></span> &#123;</span><br><span class="line">        handlers.GetResource(r, e, &amp;scope)(res.ResponseWriter, req.Request) <span class="comment">// 直接调用了返回的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># apiserver/pkg/endpoints/handlers/get.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetResource</span><span class="params">(r rest.Getter, e rest.Exporter, scope *RequestScope)</span></span> http.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> getResourceHandler(scope,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, name <span class="type">string</span>, req *http.Request, trace *utiltrace.Trace)</span></span> (runtime.Object, <span class="type">error</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">return</span> r.Get(ctx, name, &amp;options)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getResourceHandler</span><span class="params">(scope *RequestScope, getter getterFunc)</span></span> http.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        namespace, name, err := scope.Namer.Name(req)</span><br><span class="line">        result, err := getter(ctx, name, req, trace)</span><br><span class="line">        ......</span><br><span class="line">        transformResponseObject(ctx, scope, req, w, http.StatusOK, outputMediaType, result) <span class="comment">//对从数据库返回的结果进行转换以及序列化，然后返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在Handler方法中，去调用rest.Getter的Get方法，调用rest storage去数据库中获取对应的name的资源进行返回，然后对从数据库返回的结果进行转换以及序列化，最终返回给用户，需要注意<code>GetResource()</code>返回的是一个方法，而在 <code>restfulGetResource()</code> 方法中，则通过 <code>handlers.GetResource()()</code> 的方式，直接调用了该方法。 在这里，我们就看到了在<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/09/19/kubernetes/kube-apiserver-storage-overview.html">Kubernetes APIServer Storage 框架解析</a>介绍的<code>REST store</code>是如何应用的。</p>
<p>此外，还需要注意一点就是 <code>apiserver/pkg/endpoints/handlers/</code> 这个目录下的都是高度抽象化后的各种handler，除了上例中处理Get请求的handler之外，还有Create, Delete, Watch等操作相关的handler，它们接收各种资源的<code>REST store</code>，调用对应的接口，对数据库相应的进行增删查改，然后执行一些序列化操作，返回给客户端，这些handler可以说是对每个API对象操作的入口。</p>
<h2 id="Handler的处理"><a href="#Handler的处理" class="headerlink" title="Handler的处理"></a>Handler的处理</h2><p>Handler构建出来，并且向其中注册了API对象，最后我们来看下，Handler是如何处理请求的，核心的逻辑，其实在上面已经介绍过，即在director的ServeHTTP()方法中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/server/handler.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d director)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    path := req.URL.Path</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check to see if our webservices want to claim this path</span></span><br><span class="line">    <span class="keyword">for</span> _, ws := <span class="keyword">range</span> d.goRestfulContainer.RegisteredWebServices() &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> ws.RootPath() == <span class="string">&quot;/apis&quot;</span>:</span><br><span class="line">            <span class="comment">// if we are exactly /apis or /apis/, then we need special handling in loop.</span></span><br><span class="line">            <span class="comment">// normally these are passed to the nonGoRestfulMux, but if discovery is enabled, it will go directly.</span></span><br><span class="line">            <span class="comment">// We can&#x27;t rely on a prefix match since /apis matches everything (see the big comment on Director above)</span></span><br><span class="line">            <span class="keyword">if</span> path == <span class="string">&quot;/apis&quot;</span> || path == <span class="string">&quot;/apis/&quot;</span> &#123;</span><br><span class="line">                klog.V(<span class="number">5</span>).Infof(<span class="string">&quot;%v: %v %q satisfied by gorestful with webservice %v&quot;</span>, d.name, req.Method, path, ws.RootPath())</span><br><span class="line">                <span class="comment">// don&#x27;t use servemux here because gorestful servemuxes get messed up when removing webservices</span></span><br><span class="line">                <span class="comment">// TODO fix gorestful, remove TPRs, or stop using gorestful</span></span><br><span class="line">                d.goRestfulContainer.Dispatch(w, req)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> strings.HasPrefix(path, ws.RootPath()):</span><br><span class="line">            <span class="comment">// ensure an exact match or a path boundary match</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(ws.RootPath()) || path[<span class="built_in">len</span>(ws.RootPath())] == <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">                klog.V(<span class="number">5</span>).Infof(<span class="string">&quot;%v: %v %q satisfied by gorestful with webservice %v&quot;</span>, d.name, req.Method, path, ws.RootPath())</span><br><span class="line">                <span class="comment">// don&#x27;t use servemux here because gorestful servemuxes get messed up when removing webservices</span></span><br><span class="line">                <span class="comment">// TODO fix gorestful, remove TPRs, or stop using gorestful</span></span><br><span class="line">                d.goRestfulContainer.Dispatch(w, req)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we didn&#x27;t find a match, then we just skip gorestful altogether</span></span><br><span class="line">    klog.V(<span class="number">5</span>).Infof(<span class="string">&quot;%v: %v %q satisfied by nonGoRestful&quot;</span>, d.name, req.Method, path)</span><br><span class="line">    d.nonGoRestfulMux.ServeHTTP(w, req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *APIServerHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    a.FullHandlerChain.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是APIServerHandler的ServeHTTP()方法，调用了FullHandlerChain的ServeHTTP()方法，经过了层层的filter，最终到了director的ServeHTTP()方法，在该方法中，首先遍历goRestfulContainer中注册的WebService，看path跟哪个WebService中的路径匹配，如果匹配，则调用<code>goRestfulContainer.Dispatch()</code>处理该请求，如果都没有匹配上，则最终调用nonGoRestfulMux来处理该请求。</p>
<h2 id="PostStartHook"><a href="#PostStartHook" class="headerlink" title="PostStartHook"></a>PostStartHook</h2><p>在GenericAPIServer中还有一个重要的机制，就是这个PostStartHook，它是在APIServer启动之后，执行的一些Hook函数，这些Hook函数是在APIServer创建的过程中，注册进去的，在APIServer启动之后，做一些初始化或者周期性循环的任务，来看下相关的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/server/hooks.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span></span> AddPostStartHook(name <span class="type">string</span>, hook PostStartHookFunc) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;missing name&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> hook == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;hook func may not be nil: %q&quot;</span>, name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.disabledPostStartHooks.Has(name) &#123;</span><br><span class="line">        klog.V(<span class="number">1</span>).Infof(<span class="string">&quot;skipping %q because it was explicitly disabled&quot;</span>, name)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.postStartHookLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.postStartHookLock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s.postStartHooksCalled &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to add %q because PostStartHooks have already been called&quot;</span>, name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> postStartHook, exists := s.postStartHooks[name]; exists &#123;</span><br><span class="line">        <span class="comment">// this is programmer error, but it can be hard to debug</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to add %q because it was already registered by: %s&quot;</span>, name, postStartHook.originatingStack)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// done is closed when the poststarthook is finished.  This is used by the health check to be able to indicate</span></span><br><span class="line">    <span class="comment">// that the poststarthook is finished</span></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err := s.AddBootSequenceHealthChecks(postStartHookHealthz&#123;name: <span class="string">&quot;poststarthook/&quot;</span> + name, done: done&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    s.postStartHooks[name] = postStartHookEntry&#123;hook: hook, originatingStack: <span class="type">string</span>(debug.Stack()), done: done&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span></span> RunPostStartHooks(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">    s.postStartHookLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.postStartHookLock.Unlock()</span><br><span class="line">    s.postStartHooksCalled = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    context := PostStartHookContext&#123;</span><br><span class="line">        LoopbackClientConfig: s.LoopbackClientConfig,</span><br><span class="line">        StopCh:               stopCh,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> hookName, hookEntry := <span class="keyword">range</span> s.postStartHooks &#123;</span><br><span class="line">        <span class="keyword">go</span> runPostStartHook(hookName, hookEntry, context)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过AddPostStartHook()方法向GenericAPIServer中添加Hook，然后在APIServer启动时，调用RunPostStartHooks()，遍历postStartHooks列表，使用goroutine运行每一个hook，来看一个添加PostStartHook的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># kubernetes/cmd/kube-apiserver/app/aggregator.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">err = aggregatorServer.GenericAPIServer.AddPostStartHook(<span class="string">&quot;kube-apiserver-autoregistration&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">go</span> crdRegistrationController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// let the CRD controller process the initial set of CRDs before starting the autoregistration controller.</span></span><br><span class="line">            <span class="comment">// this prevents the autoregistration controller&#x27;s initial sync from deleting APIServices for CRDs that still exist.</span></span><br><span class="line">            <span class="comment">// we only need to do this if CRDs are enabled on this server.  We can&#x27;t use discovery because we are the source for discovery.</span></span><br><span class="line">            <span class="keyword">if</span> aggregatorConfig.GenericConfig.MergedResourceConfig.AnyVersionForGroupEnabled(<span class="string">&quot;apiextensions.k8s.io&quot;</span>) &#123;</span><br><span class="line">                crdRegistrationController.WaitForInitialSync()</span><br><span class="line">            &#125;</span><br><span class="line">            autoRegistrationController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>上面就是一个周期循环的Hook，用来将crd对象，不断轮询，转换成aggregator中的apiservices对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析，可以看到，本质上，GenericAPIServer最核心的功能，就是对net/http Handler的构造，为了理解其过程，介绍了go-restful, NonGoRestfulMux, APIGroupInfo等基础知识，Handler构建，API对象注册的过程，以及PostStartHook，还涉及到一些以前介绍过的知识，比如REST store，在这里我们看到了其是如何应用的，除了这些核心内容，还有一些将net/http Server如何Run起来的一些内容，逻辑比较简单，前面也介绍过，这里就不再介绍了。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Kubernetes APIServer GenericAPIServer</p><p><a href="https://hackerain.me/2020/10/05/kubernetes/kube-apiserver-genericapiserver.html">https://hackerain.me/2020/10/05/kubernetes/kube-apiserver-genericapiserver.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>hackerain</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-10-05</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-10-28</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/kubernetes/">kubernetes</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/10/06/kubernetes/kube-apiserver-api-resource-installation.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Kubernetes APIServer API Resource Installation</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/10/04/kubernetes/kube-apiserver-nongorestfulmux.html"><span class="level-item">Kubernetes APIServer NonGoRestfulMux</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/assets/avatar.jpg" alt="开心BOY"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">开心BOY</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">44</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="/about" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/hackerain"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="知识星球" href="https://t.zsxq.com/0bWmBFDpu"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#基础知识"><span class="level-left"><span class="level-item">1</span><span class="level-item">基础知识</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#APIGroupInfo"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">APIGroupInfo</span></span></a></li><li><a class="level is-mobile" href="#go-restful"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">go-restful</span></span></a></li><li><a class="level is-mobile" href="#NonGoRestfulMux"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">NonGoRestfulMux</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Handler的构建"><span class="level-left"><span class="level-item">2</span><span class="level-item">Handler的构建</span></span></a></li><li><a class="level is-mobile" href="#API对象的注册"><span class="level-left"><span class="level-item">3</span><span class="level-item">API对象的注册</span></span></a></li><li><a class="level is-mobile" href="#Handler的处理"><span class="level-left"><span class="level-item">4</span><span class="level-item">Handler的处理</span></span></a></li><li><a class="level is-mobile" href="#PostStartHook"><span class="level-left"><span class="level-item">5</span><span class="level-item">PostStartHook</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">6</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-12T00:00:00.000Z">2023-11-12</time></p><p class="title"><a href="/2023/11/12/kubernetes/kube-versioning-codec.html">Kubernetes API Codec 解析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-11T00:00:00.000Z">2023-11-11</time></p><p class="title"><a href="/2023/11/11/kubernetes/kube-versioning-scheme.html">Kubernetes API Scheme 解析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-28T00:00:00.000Z">2023-10-28</time></p><p class="title"><a href="/2023/10/28/kubernetes/kube-versioning.html">Kubernetes API 多版本和序列化</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-26T00:00:00.000Z">2022-09-26</time></p><p class="title"><a href="/2022/09/26/elasticsearch/elasticsearch_large_text_field.html">Elasticsearch大文本字段(large text field)优化方案</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-08-07T10:52:55.000Z">2022-08-07</time></p><p class="title"><a href="/2022/08/07/umi/umi.html">UMI框架解析</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/"><span class="level-start"><span class="level-item">2017</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ceph/"><span class="tag">ceph</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/elasticsearch/"><span class="tag">elasticsearch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kubernetes/"><span class="tag">kubernetes</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/openstack/"><span class="tag">openstack</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/operations/"><span class="tag">operations</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/umi/"><span class="tag">umi</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/assets/logo.jpg" alt="开心BOY" height="28"></a><p class="is-size-7"><span>&copy; 2023 hackerain</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hackerain"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Kubernetes APIServer扩展机制原理 - 开心BOY</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="开心BOY"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="开心BOY"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="终于来到了这一篇，APIServer的扩展机制，前面介绍的那几篇，可以说都是在给这篇铺平道路，先来回顾下："><meta property="og:type" content="blog"><meta property="og:title" content="Kubernetes APIServer扩展机制原理"><meta property="og:url" content="https://hackerain.me/2020/10/08/kubernetes/kube-apiserver-extensions.html"><meta property="og:site_name" content="开心BOY"><meta property="og:description" content="终于来到了这一篇，APIServer的扩展机制，前面介绍的那几篇，可以说都是在给这篇铺平道路，先来回顾下："><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hackerain.me/assets/kubernetes_apiserver_delegation.png"><meta property="og:image" content="https://hackerain.me/assets/kubernetes_aggregator_autoregistration.png"><meta property="article:published_time" content="2020-10-08T00:00:00.000Z"><meta property="article:modified_time" content="2023-10-28T14:12:29.408Z"><meta property="article:author" content="hackerain"><meta property="article:tag" content="kubernetes"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hackerain.me/assets/kubernetes_apiserver_delegation.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hackerain.me/2020/10/08/kubernetes/kube-apiserver-extensions.html"},"headline":"Kubernetes APIServer扩展机制原理","image":["https://hackerain.me/assets/kubernetes_apiserver_delegation.png","https://hackerain.me/assets/kubernetes_aggregator_autoregistration.png"],"datePublished":"2020-10-08T00:00:00.000Z","dateModified":"2023-10-28T14:12:29.408Z","author":{"@type":"Person","name":"hackerain"},"publisher":{"@type":"Organization","name":"开心BOY","logo":{"@type":"ImageObject","url":"https://hackerain.me/assets/logo.jpg"}},"description":"终于来到了这一篇，APIServer的扩展机制，前面介绍的那几篇，可以说都是在给这篇铺平道路，先来回顾下："}</script><link rel="canonical" href="https://hackerain.me/2020/10/08/kubernetes/kube-apiserver-extensions.html"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="开心BOY" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/assets/logo.jpg" alt="开心BOY" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-10-08T00:00:00.000Z" title="10/8/2020, 12:00:00 AM">2020-10-08</time>发表</span><span class="level-item"><time dateTime="2023-10-28T14:12:29.408Z" title="10/28/2023, 2:12:29 PM">2023-10-28</time>更新</span><span class="level-item">1 小时读完 (大约7859个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Kubernetes APIServer扩展机制原理</h1><div class="content"><p>终于来到了这一篇，APIServer的扩展机制，前面介绍的那几篇，可以说都是在给这篇铺平道路，先来回顾下：</p>
<span id="more"></span>

<ul>
<li>在<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/08/09/kubernetes/kube-apiserver-overview.html">Kubernetes APIServer 机制概述</a>中我们介绍到了APIServer的本质其实是一个实现了RESTful API的WebServer，它使用golang的<a target="_blank" rel="noopener" href="https://golang.org/pkg/net/http/">net/http</a>的Server构建，并且Handler是其中非常重要的概念，此外，又简单介绍了APIServer的扩展机制，即Aggregator, APIExtensions以及KubeAPIServer这三者之间通过Delegation的方式实现了扩展。</li>
<li>在<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/09/19/kubernetes/kube-apiserver-storage-overview.html">Kubernetes APIServer Storage 框架解析</a>中，我们介绍了APIServer相关的存储框架，每个API对象，都有对应的<code>REST store</code>以及<code>etcd store</code>，它们是如何存储进数据库的。</li>
<li>在<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/10/05/kubernetes/kube-apiserver-genericapiserver.html">Kubernetes APIServer GenericAPIServer</a>中介绍了GenericAPIServer的作用，以及它的Handler是如何构建，API对象是如何以APIGroupInfo的形式注册进Handler中的，以及PostStartHook的机制。</li>
<li>在<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/10/06/kubernetes/kube-apiserver-api-resource-installation.html">Kubernetes APIServer API Resource Installation</a>中，介绍了KubeAPIServer, Aggregator, APIExtensions中的API对象资源是如何构建成<code>REST Store</code>，并且组织成<code>APIGroupInfo</code>，然后注册进GenericAPIServer中的，然后又盘点了下当前版本的Kubernetes中都有哪些API对象资源。</li>
</ul>
<p>在上面的基础知识之上，我们来分析下APIServer的扩展机制是如何实现的。之所以要花这么大的力气去分析它实现的原理，主要原因还是在于它的应用实在是太广泛了，尤其是<code>CRD + Operator</code>这种扩展模式，逐渐变成了很多软件在云原生时代运行的标准模式，我们在使用这些机制去扩展它的功能的时候，如果能够理解其实现原理，犹如庖丁解牛，心中是十分有底气的。</p>
<blockquote>
<p>Kubernetes已经逐渐变成这场云原生运动的事实标准，未来的应用可能都在Kubernetes上开发以及运行，未来交付一个软件，除了交付运行时之外，还可以一起打包交付该软件的运维能力，安装/部署/备份/更新/升级等等，仿佛有一个机器人在默默地干着运维的工作，保证软件正常运行，作为一个运维er，这种场景想想就刺激，但是理想是美好的，现实中还得有一段漫长的脚踏实地的发展以及被人们慢慢接受的过程。现在国外的，像红帽的OpenShift，凭借其强大的产品研发和设计能力，走在这场云原生运动的前列，新发布的OpenShift 4.0中，本身就大量使用<code>CRD + Operator</code>，而且将其设计到应用市场中，鼓励开发者使用这种模式发布自己的应用；而国内的，当属阿里云了，在今年7月，发布了<a target="_blank" rel="noopener" href="https://developer.aliyun.com/topic/cn-architecture-paper">云原生架构白皮书</a>，扛起了国内云原生运动的大旗，阿里云大牛如云，又占据了国内云计算市场的半壁江山，有非常大的优势做好这件事情。</p>
</blockquote>
<h2 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h2><p>之前已经简单介绍过多次，APIServer的扩展机制，是由Aggregator, KubeAPIServer, APIExtensions，这三者通过Delegation的方式实现的，这三者本质上都是APIServer，KubeAPIServer是Kubernetes内置的API对象所在的APIServer，而Aggregator和APIExtensions是Kubernetes API的两个扩展机制使用的APIServer，对这两个扩展机制的介绍见<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">官方文档</a>，<a target="_blank" rel="noopener" href="https://github.com/kubernetes/apiextensions-apiserver">APIExtensions</a>就是CRD的实现，而<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kube-aggregator">Aggregator</a>是一种高级扩展，可以让Kubernetes APIServer跟外部的APIServer进行联动，这三者中，每个都包含一个GenericAPIServer，真正delegation的其实是这三个GenericAPIServer，这一小节，我们先来理一下，这三者之间Delegation的关系。</p>
<p>还是先来看下这三个对应的结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># kubernetes/pkg/controlplane/instance.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// KubeAPIServer</span></span><br><span class="line"><span class="keyword">type</span> Instance <span class="keyword">struct</span> &#123;</span><br><span class="line">    GenericAPIServer *genericapiserver.GenericAPIServer</span><br><span class="line"></span><br><span class="line">    ClusterAuthenticationInfo clusterauthenticationtrust.ClusterAuthenticationInfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># kube-aggregator/pkg/apiserver/apiserver.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Aggregator</span></span><br><span class="line"><span class="keyword">type</span> APIAggregator <span class="keyword">struct</span> &#123;</span><br><span class="line">    GenericAPIServer *genericapiserver.GenericAPIServer</span><br><span class="line">    delegateHandler http.Handler</span><br><span class="line">    <span class="comment">// proxyHandlers are the proxy handlers that are currently registered, keyed by apiservice.name</span></span><br><span class="line">    proxyHandlers <span class="keyword">map</span>[<span class="type">string</span>]*proxyHandler</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># apiextensions-apiserver/pkg/apiserver/apiserver.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// APIExtensions</span></span><br><span class="line"><span class="keyword">type</span> CustomResourceDefinitions <span class="keyword">struct</span> &#123;</span><br><span class="line">    GenericAPIServer *genericapiserver.GenericAPIServer</span><br><span class="line">    <span class="comment">// provided for easier embedding</span></span><br><span class="line">    Informers externalinformers.SharedInformerFactory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到每个都包含了一个GenericAPIServer指针类型的成员变量，他们是在<code>Config-&gt;Complete-&gt;New</code>模式的New()方法中被创建出来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># kubernetes/pkg/controlplane/instance.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span></span> New(delegationTarget genericapiserver.DelegationTarget) (*Master, <span class="type">error</span>) &#123;</span><br><span class="line">    s, err := c.GenericConfig.New(<span class="string">&quot;kube-apiserver&quot;</span>, delegationTarget)</span><br><span class="line">    ......</span><br><span class="line">    m := &amp;Instance&#123;</span><br><span class="line">        GenericAPIServer:          s,</span><br><span class="line">        ClusterAuthenticationInfo: c.ExtraConfig.ClusterAuthenticationInfo,</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># kube-aggregator/pkg/apiserver/apiserver.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span></span> NewWithDelegate(delegationTarget genericapiserver.DelegationTarget) (*APIAggregator, <span class="type">error</span>) &#123;</span><br><span class="line">    genericServer, err := c.GenericConfig.New(<span class="string">&quot;kube-aggregator&quot;</span>, delegationTarget)</span><br><span class="line"></span><br><span class="line">    s := &amp;APIAggregator&#123;</span><br><span class="line">        GenericAPIServer:         genericServer,</span><br><span class="line">        delegateHandler:          delegationTarget.UnprotectedHandler(),</span><br><span class="line">        proxyClientCert:          c.ExtraConfig.ProxyClientCert,</span><br><span class="line">        proxyClientKey:           c.ExtraConfig.ProxyClientKey,</span><br><span class="line">        proxyTransport:           c.ExtraConfig.ProxyTransport,</span><br><span class="line">        proxyHandlers:            <span class="keyword">map</span>[<span class="type">string</span>]*proxyHandler&#123;&#125;,</span><br><span class="line">        handledGroups:            sets.String&#123;&#125;,</span><br><span class="line">        lister:                   informerFactory.Apiregistration().V1().APIServices().Lister(),</span><br><span class="line">        APIRegistrationInformers: informerFactory,</span><br><span class="line">        serviceResolver:          c.ExtraConfig.ServiceResolver,</span><br><span class="line">        openAPIConfig:            openAPIConfig,</span><br><span class="line">        egressSelector:           c.GenericConfig.EgressSelector,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># kube-aggregator/pkg/apiserver/apiserver.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span></span> New(delegationTarget genericapiserver.DelegationTarget) (*CustomResourceDefinitions, <span class="type">error</span>) &#123;</span><br><span class="line">    genericServer, err := c.GenericConfig.New(<span class="string">&quot;apiextensions-apiserver&quot;</span>, delegationTarget)</span><br><span class="line">    s := &amp;CustomResourceDefinitions&#123;</span><br><span class="line">        GenericAPIServer: genericServer,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在New()方法中，每一个都通过GenericAPIServer的New()方法创建了一个GenericAPIServer，传了两个参数进去，一个是该GenericAPIServer的name，另外一个是DelegationTarget，即该GenericAPIServer的Delegation是谁，来看下这个New()方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/server/config.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span></span> New(name <span class="type">string</span>, delegationTarget DelegationTarget) (*GenericAPIServer, <span class="type">error</span>) &#123;</span><br><span class="line">    handlerChainBuilder := <span class="function"><span class="keyword">func</span><span class="params">(handler http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">        <span class="keyword">return</span> c.BuildHandlerChainFunc(handler, c.Config)</span><br><span class="line">    &#125;</span><br><span class="line">    apiServerHandler := NewAPIServerHandler(name, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler())</span><br><span class="line"></span><br><span class="line">    s := &amp;GenericAPIServer&#123;</span><br><span class="line">        ......</span><br><span class="line">        delegationTarget:           delegationTarget,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到从参数传进来的delegationTarget被赋值给GenericAPIServer的delegationTarget属性。</p>
<p>再来看下，上面三个APIServer是怎么被创建出来的，是在<code>CreateServerChain()</code>阶段，依次调用了上面的New()方法，创建出来这三个APIServer：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># kubernetes/cmd/kube-apiserver/app/server.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateServerChain creates the apiservers connected via delegation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateServerChain</span><span class="params">(config CompletedConfig)</span></span> (*aggregatorapiserver.APIAggregator, <span class="type">error</span>) &#123;</span><br><span class="line">    notFoundHandler := notfoundhandler.New(config.ControlPlane.GenericConfig.Serializer, genericapifilters.NoMuxAndDiscoveryIncompleteKey)</span><br><span class="line">    apiExtensionsServer, err := config.ApiExtensions.New(genericapiserver.NewEmptyDelegateWithCustomHandler(notFoundHandler))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    crdAPIEnabled := config.ApiExtensions.GenericConfig.MergedResourceConfig.ResourceEnabled(apiextensionsv1.SchemeGroupVersion.WithResource(<span class="string">&quot;customresourcedefinitions&quot;</span>))</span><br><span class="line"></span><br><span class="line">    kubeAPIServer, err := config.ControlPlane.New(apiExtensionsServer.GenericAPIServer)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// aggregator comes last in the chain</span></span><br><span class="line">    aggregatorServer, err := createAggregatorServer(config.Aggregator, kubeAPIServer.GenericAPIServer, apiExtensionsServer.Informers, crdAPIEnabled)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// we don&#x27;t need special handling for innerStopCh because the aggregator server doesn&#x27;t create any go routines</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> aggregatorServer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分别通过各自config的New()方法创建出来APIServer，注意一下这三个APIServer出创建的顺序，以及delegationTarget参数的传递，可以看到，首先创建的是APIExtensionsServer，它的delegationTarget传的是一个空的Delegate，即什么都不做，继而将APIExtensionsServer的GenericAPIServer，作为delegationTarget传给了<code>config.ControlPlane.New()</code>，创建出了KubeAPIServer，再然后，将kubeAPIServer的GenericAPIServer作为delegationTarget传给了createAggregatorServer()，创建出了aggregatorServer，注意，最终<code>CreateServerChain()</code>这个方法返回的也只有aggregatorServer，所以他们之间delegation的关系为: <code>Aggregator -&gt; KubeAPIServer -&gt; APIExtensions</code>，如下图所示：</p>
<p><img src="/assets/kubernetes_apiserver_delegation.png" alt="k8s-apiserver-delegation"></p>
<p>从上面可以看出，Aggregator其实是一个非常重要的存在，CreateServerChain()最终返回的是一个<code>Aggregator APIServer</code>，并且Aggregator是Delegation这个Chain最开头的APIServer，的确，Aggregator有一个内置的API资源，叫做<code>apiservices</code>，用来表示一个外部的API服务，在创建AggregatorServer时，KubeAPIServer和APIExtensions中的资源组，即GroupVersion，会被转换成Aggregator APIService对象，注册到Aggregator中，并且整个APIServer的入口，其实是Aggregator的GenericAPIServer，下面我们来看看这些是怎么实现的。</p>
<h2 id="kube-apiserver-autoregistration"><a href="#kube-apiserver-autoregistration" class="headerlink" title="kube-apiserver-autoregistration"></a>kube-apiserver-autoregistration</h2><p>在aggregator启动的时候，即在createAggregatorServer()方法中，crd和apiserver中定义的资源组(GroupVersion)，会通过<code>kube-apiserver-autoregistration</code> poststarthook，被转换成APIService，然后注册进aggregator中，比如将<code>GroupVersion&#123;Group: &quot;apps&quot;, Version: &quot;v1&quot;&#125;</code>转成<code>APIService&#123;Spec: v1.APIServiceSpec&#123;Group: &quot;apps&quot;, Version&quot; &quot;v1&quot;&#125;&#125;</code>，存进数据库中。apiserver中的对象资源因为是k8s内置的，是固定的，所以只需要在启动的时候，注册一次就可以了，但是CRD中的资源，是用户自定义的，可能随时增删改，所以需要不断的进行更新同步。相关代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># kubernetes/cmd/kube-apiserver/app/aggregator.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createAggregatorServer</span><span class="params">(aggregatorConfig aggregatorapiserver.CompletedConfig, delegateAPIServer genericapiserver.DelegationTarget, apiExtensionInformers apiextensionsinformers.SharedInformerFactory, crdAPIEnabled <span class="type">bool</span>)</span></span> (*aggregatorapiserver.APIAggregator, <span class="type">error</span>) &#123;</span><br><span class="line">    aggregatorServer, err := aggregatorConfig.NewWithDelegate(delegateAPIServer)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create controllers for auto-registration</span></span><br><span class="line">    apiRegistrationClient, err := apiregistrationclient.NewForConfig(aggregatorConfig.GenericConfig.LoopbackClientConfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// autoRegisterController中有一个queue和一个map，map用来存储APIService的具体对象，而queue只用来存储APIService的name</span></span><br><span class="line">    autoRegistrationController := autoregister.NewAutoRegisterController(aggregatorServer.APIRegistrationInformers.Apiregistration().V1().APIServices(), apiRegistrationClient)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将apiserver中的GroupVersion，转换成APIService，添加到autoRegistrationController的queue和map中，这个只执行一次</span></span><br><span class="line">    apiServices := apiServicesToRegister(delegateAPIServer, autoRegistrationController)</span><br><span class="line">    crdRegistrationController := crdregistration.NewCRDRegistrationController(</span><br><span class="line">        apiExtensionInformers.Apiextensions().V1().CustomResourceDefinitions(),</span><br><span class="line">        autoRegistrationController)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Imbue all builtin group-priorities onto the aggregated discovery</span></span><br><span class="line">    <span class="keyword">if</span> aggregatorConfig.GenericConfig.AggregatedDiscoveryGroupManager != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> gv, entry := <span class="keyword">range</span> apiVersionPriorities &#123;</span><br><span class="line">            aggregatorConfig.GenericConfig.AggregatedDiscoveryGroupManager.SetGroupVersionPriority(metav1.GroupVersion(gv), <span class="type">int</span>(entry.group), <span class="type">int</span>(entry.version))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = aggregatorServer.GenericAPIServer.AddPostStartHook(<span class="string">&quot;kube-apiserver-autoregistration&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="comment">// 通过不断循环，将crd中的GroupVersion，转换成APIService，添加到autoRegistrationController的queue和map中</span></span><br><span class="line">        <span class="keyword">go</span> crdRegistrationController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// let the CRD controller process the initial set of CRDs before starting the autoregistration controller.</span></span><br><span class="line">            <span class="comment">// this prevents the autoregistration controller&#x27;s initial sync from deleting APIServices for CRDs that still exist.</span></span><br><span class="line">            <span class="comment">// we only need to do this if CRDs are enabled on this server.  We can&#x27;t use discovery because we are the source for discovery.</span></span><br><span class="line">            <span class="keyword">if</span> crdAPIEnabled &#123;</span><br><span class="line">                klog.Infof(<span class="string">&quot;waiting for initial CRD sync...&quot;</span>)</span><br><span class="line">                crdRegistrationController.WaitForInitialSync()</span><br><span class="line">                klog.Infof(<span class="string">&quot;initial CRD sync complete...&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                klog.Infof(<span class="string">&quot;CRD API not enabled, starting APIService registration without waiting for initial CRD sync&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过不断的轮询，将queue中的APIService取出，通过apiservice的API，添加或者更新到etcd数据库中，固化下来。</span></span><br><span class="line">            autoRegistrationController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> aggregatorServer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个转换过程，主要是通过两个Controller来实现的: <code>crdRegistrationController</code>和<code>autoRegistrationController</code>，这里就体现了Kubernetes中非常核心的设计模式，<code>Controller-Loop</code>模式，即不断从API中获取对象定义，然后按照API对象的定义，执行对应的操作，确保API对象定义和实际的效果是相符的，这种API也叫做<code>declarative api</code>，即申明式API。</p>
<p><code>autoRegistrationController</code>中定义了一个队列，用来保存添加进来的APIService对象，这些APIService，可能是KubeAPIServer或者APIExtensions APIServer转换过来的，也可能是通过APIService的API直接添加进来的，然后在<code>kube-apiserver-autoregistration</code> PostStartHook中，启动这个Controller，通过不断轮询，将队列中的APIService取出，然后调用apiservice对应的API，将他们添加或者更新到etcd数据库中，固化下来。</p>
<p><code>crdRegistrationController</code>则是将APIExtensions APIServer中定义的CRD对象转换成APIService，注册到<code>autoRegistrationController</code>的队列中，然后在<code>kube-apiserver-autoregistration</code> PostStartHook中，启动这个Controller，通过不断轮询CRD的API，将CRD中的GroupVersion，转换成APIService，添加到<code>autoRegistrationController</code>的队列中。除了APIExtensions APIServer，还有KubeAPIServer，因为它里面的对象资源是内置的，不会动态发生变化，所以，在<code>apiServicesToRegister()</code>方法中只进行一次转换，然后注册进<code>autoRegistrationController</code>队列中。</p>
<p>但是需要注意由APIExtensions和KubeAPIServer转换过来的APIService是特殊的，叫做<code>local APIService</code>，来看看APIService的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># kube-aggregator/pkg/apis/apiregistration/v1/types.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> APIServiceSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Service is a reference to the service for this API server.  It must communicate</span></span><br><span class="line">    <span class="comment">// on port 443.</span></span><br><span class="line">    <span class="comment">// If the Service is nil, that means the handling for the API groupversion is handled locally on this server.</span></span><br><span class="line">    <span class="comment">// The call will simply delegate to the normal handler chain to be fulfilled.</span></span><br><span class="line">    <span class="comment">// +optional</span></span><br><span class="line">    Service *ServiceReference <span class="string">`json:&quot;service,omitempty&quot; protobuf:&quot;bytes,1,opt,name=service&quot;`</span></span><br><span class="line">    <span class="comment">// Group is the API group name this server hosts</span></span><br><span class="line">    Group <span class="type">string</span> <span class="string">`json:&quot;group,omitempty&quot; protobuf:&quot;bytes,2,opt,name=group&quot;`</span></span><br><span class="line">    <span class="comment">// Version is the API version this server hosts.  For example, &quot;v1&quot;</span></span><br><span class="line">    Version <span class="type">string</span> <span class="string">`json:&quot;version,omitempty&quot; protobuf:&quot;bytes,3,opt,name=version&quot;`</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上面的Service属性的注释可以看到，Service属性如果是nil的话，则表明该APIService是一个local APIService，local APIService的请求，将会delegate给对应的handler来处理，来看看APIExtensions和KubeAPIServer中的GroupVersion是怎么转换成local APIService的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># kubernetes/cmd/kube-apiserver/app/aggregator.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeAPIService</span><span class="params">(gv schema.GroupVersion)</span></span> *v1.APIService &#123;</span><br><span class="line">    apiServicePriority, ok := apiVersionPriorities[gv]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="comment">// if we aren&#x27;t found, then we shouldn&#x27;t register ourselves because it could result in a CRD group version</span></span><br><span class="line">        <span class="comment">// being permanently stuck in the APIServices list.</span></span><br><span class="line">        klog.Infof(<span class="string">&quot;Skipping APIService creation for %v&quot;</span>, gv)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;v1.APIService&#123;</span><br><span class="line">        ObjectMeta: metav1.ObjectMeta&#123;Name: gv.Version + <span class="string">&quot;.&quot;</span> + gv.Group&#125;,</span><br><span class="line">        Spec: v1.APIServiceSpec&#123;</span><br><span class="line">            Group:                gv.Group,</span><br><span class="line">            Version:              gv.Version,</span><br><span class="line">            GroupPriorityMinimum: apiServicePriority.group,</span><br><span class="line">            VersionPriority:      apiServicePriority.version,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，构建APIServiceSpec时，并没有传Service属性，不传的话，默认为nil，这样的APIService，则会由本地的APIServer进行处理，其实也就是KubeAPIServer或者是APIExtension APIServer，而不会被Aggregator给proxy出去，这个后面看下Aggregator的proxy策略就知道了。</p>
<h2 id="apiservice-registration-controller"><a href="#apiservice-registration-controller" class="headerlink" title="apiservice-registration-controller"></a>apiservice-registration-controller</h2><p>这个Controller的作用，则是通过轮询数据库中的APIService对象，为每个APIService构建Handler，并且向Aggregator中的GenericAPIServer注册的过程，来看下它的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># kube-aggregator/pkg/apiserver/apiservice_controller.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> APIHandlerManager <span class="keyword">interface</span> &#123;</span><br><span class="line">    AddAPIService(apiService *v1.APIService) <span class="type">error</span></span><br><span class="line">    RemoveAPIService(apiServiceName <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> APIServiceRegistrationController <span class="keyword">struct</span> &#123;</span><br><span class="line">    apiHandlerManager APIHandlerManager</span><br><span class="line"></span><br><span class="line">    apiServiceLister listers.APIServiceLister</span><br><span class="line">    apiServiceSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To allow injection for testing.</span></span><br><span class="line">    syncFn <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    queue workqueue.RateLimitingInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAPIServiceRegistrationController</span><span class="params">(apiServiceInformer informers.APIServiceInformer, apiHandlerManager APIHandlerManager)</span></span> *APIServiceRegistrationController &#123;</span><br><span class="line">    c := &amp;APIServiceRegistrationController&#123;</span><br><span class="line">        apiHandlerManager: apiHandlerManager,</span><br><span class="line">        apiServiceLister:  apiServiceInformer.Lister(),</span><br><span class="line">        apiServiceSynced:  apiServiceInformer.Informer().HasSynced,</span><br><span class="line">        queue:             workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">&quot;APIServiceRegistrationController&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apiServiceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc:    c.addAPIService,</span><br><span class="line">        UpdateFunc: c.updateAPIService,</span><br><span class="line">        DeleteFunc: c.deleteAPIService,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    c.syncFn = c.sync</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个Controller是在APIAggregator的New()方法中被创建，并且添加到poststarthook中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># kube-aggregator/pkg/apiserver/apiserver.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span></span> NewWithDelegate(delegationTarget genericapiserver.DelegationTarget) (*APIAggregator, <span class="type">error</span>) &#123;</span><br><span class="line">    s := &amp;APIAggregator&#123;</span><br><span class="line">        GenericAPIServer:         genericServer,</span><br><span class="line">        delegateHandler:          delegationTarget.UnprotectedHandler()</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    apiserviceRegistrationController := NewAPIServiceRegistrationController(informerFactory.Apiregistration().V1().APIServices(), s)</span><br><span class="line">    ......</span><br><span class="line">    s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;apiservice-registration-controller&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        handlerSyncedCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        <span class="keyword">go</span> apiserviceRegistrationController.Run(context.StopCh, handlerSyncedCh)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-context.StopCh:</span><br><span class="line">        <span class="keyword">case</span> &lt;-handlerSyncedCh:</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面<code>APIServiceRegistrationController</code>中有一个<code>apiHandlerManager</code>的成员变量，其实它就是<code>APIAggregator</code>，通过<code>NewAPIServiceRegistrationController()</code>方法构建Controller的时候，传参过去的，而在APIAggregator中，则实现了为APIService构建Handler，并且注册进GenericAPIServer中的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># kube-aggregator/pkg/apiserver/apiserver.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *APIAggregator)</span></span> AddAPIService(apiService *v1.APIService) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// if the proxyHandler already exists, it needs to be updated. The aggregation bits do not</span></span><br><span class="line">    <span class="comment">// since they are wired against listers because they require multiple resources to respond</span></span><br><span class="line">    <span class="keyword">if</span> proxyHandler, exists := s.proxyHandlers[apiService.Name]; exists &#123;</span><br><span class="line">        proxyHandler.updateAPIService(apiService)</span><br><span class="line">        <span class="keyword">if</span> s.openAPIAggregationController != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.openAPIAggregationController.UpdateAPIService(proxyHandler, apiService)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proxyPath := <span class="string">&quot;/apis/&quot;</span> + apiService.Spec.Group + <span class="string">&quot;/&quot;</span> + apiService.Spec.Version</span><br><span class="line">    <span class="comment">// v1. is a special case for the legacy API.  It proxies to a wider set of endpoints.</span></span><br><span class="line">    <span class="keyword">if</span> apiService.Name == legacyAPIServiceName &#123;</span><br><span class="line">        proxyPath = <span class="string">&quot;/api&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register the proxy handler</span></span><br><span class="line">    proxyHandler := &amp;proxyHandler&#123;</span><br><span class="line">        localDelegate:   s.delegateHandler,</span><br><span class="line">        proxyClientCert: s.proxyClientCert,</span><br><span class="line">        proxyClientKey:  s.proxyClientKey,</span><br><span class="line">        proxyTransport:  s.proxyTransport,</span><br><span class="line">        serviceResolver: s.serviceResolver,</span><br><span class="line">        egressSelector:  s.egressSelector,</span><br><span class="line">    &#125;</span><br><span class="line">    proxyHandler.updateAPIService(apiService)</span><br><span class="line">    <span class="keyword">if</span> s.openAPIAggregationController != <span class="literal">nil</span> &#123;</span><br><span class="line">        s.openAPIAggregationController.AddAPIService(proxyHandler, apiService)</span><br><span class="line">    &#125;</span><br><span class="line">    s.proxyHandlers[apiService.Name] = proxyHandler</span><br><span class="line">    s.GenericAPIServer.Handler.NonGoRestfulMux.Handle(proxyPath, proxyHandler)</span><br><span class="line">    s.GenericAPIServer.Handler.NonGoRestfulMux.UnlistedHandlePrefix(proxyPath+<span class="string">&quot;/&quot;</span>, proxyHandler)</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>AddAPIService()</code>方法中，以该APIServcie的Group和Version构建了路径：<code>proxyPath := &quot;/apis/&quot; + apiService.Spec.Group + &quot;/&quot; + apiService.Spec.Version</code>，然后构建了一个<code>proxyHandler</code>的Handler，然后将<code>path: proxyHandler</code>注册进了Aggregator的GenericAPIServer中的NonGoRestfulMux中，完成了Handler的注册。与之对应的还有个<code>RemoveAPIService()</code>用来将一个APIService的Handler从Aggregator中移除。</p>
<p>下面来看看该Controller启动之后的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># kube-aggregator/pkg/apiserver/apiservice_controller.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *APIServiceRegistrationController)</span></span> Run(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, handlerSyncedCh <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    <span class="keyword">defer</span> c.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">    klog.Infof(<span class="string">&quot;Starting APIServiceRegistrationController&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> klog.Infof(<span class="string">&quot;Shutting down APIServiceRegistrationController&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !controllers.WaitForCacheSync(<span class="string">&quot;APIServiceRegistrationController&quot;</span>, stopCh, c.apiServiceSynced) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// initially sync all APIServices to make sure the proxy handler is complete</span></span><br><span class="line">    <span class="keyword">if</span> err := wait.PollImmediateUntil(time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">        services, err := c.apiServiceLister.List(labels.Everything())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;failed to initially list APIServices: %v&quot;</span>, err))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, s := <span class="keyword">range</span> services &#123;</span><br><span class="line">            <span class="keyword">if</span> err := c.apiHandlerManager.AddAPIService(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;failed to initially sync APIService %s: %v&quot;</span>, s.Name, err))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;, stopCh); err == wait.ErrWaitTimeout &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;timed out waiting for proxy handler to initialize&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;unexpected error: %v&quot;</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(handlerSyncedCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// only start one worker thread since its a slow moving API and the aggregation server adding bits</span></span><br><span class="line">    <span class="comment">// aren&#x27;t threadsafe</span></span><br><span class="line">    <span class="keyword">go</span> wait.Until(c.runWorker, time.Second, stopCh)</span><br><span class="line"></span><br><span class="line">    &lt;-stopCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *APIServiceRegistrationController)</span></span> sync(key <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    apiService, err := c.apiServiceLister.Get(key)</span><br><span class="line">    <span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">        c.apiHandlerManager.RemoveAPIService(key)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c.apiHandlerManager.AddAPIService(apiService)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在PostStartHook中，将该Controller启动之后，即调用<code>Run()</code>方法，首先会通过APIService API拿到当前所有的APIService对象，然后调用Aggregator的AddAPIService()方法，将现有的APIService都注册进GenericAPIServer中。之后，就通过Informer机制，不断轮询APIService API，当监测到有APIService对象的增删改时，则会调用<code>sync()</code>方法，从API中获取到该APIService对象，然后将其从GenericAPIServer的Handler中增加或者删除。</p>
<p>以上，就是这两个poststarthook中的几个Controller的逻辑，我们画张图，总结一下：</p>
<p><img src="/assets/kubernetes_aggregator_autoregistration.png" alt="kubernetes_aggregator_autoregistration"></p>
<h2 id="Aggregator-proxyHandler"><a href="#Aggregator-proxyHandler" class="headerlink" title="Aggregator proxyHandler"></a>Aggregator proxyHandler</h2><p>下面我们来重点关注一下Aggregator中的proxyHandler的proxy逻辑，但是首先来看下proxyHandler的构建逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"># kube-aggregator/pkg/apiserver/apiserver.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *APIAggregator)</span></span> AddAPIService(apiService *v1.APIService) <span class="type">error</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    proxyHandler := &amp;proxyHandler&#123;</span><br><span class="line">        localDelegate:   s.delegateHandler,</span><br><span class="line">        proxyClientCert: s.proxyClientCert,</span><br><span class="line">        proxyClientKey:  s.proxyClientKey,</span><br><span class="line">        proxyTransport:  s.proxyTransport,</span><br><span class="line">        serviceResolver: s.serviceResolver,</span><br><span class="line">        egressSelector:  s.egressSelector,</span><br><span class="line">    &#125;</span><br><span class="line">    proxyHandler.updateAPIService(apiService)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># kube-aggregator/pkg/apiserver/handler_proxy.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> proxyHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// localDelegate is used to satisfy local APIServices</span></span><br><span class="line">    localDelegate http.Handler</span><br><span class="line"></span><br><span class="line">    <span class="comment">// proxyClientCert/Key are the client cert used to identify this proxy. Backing APIServices use</span></span><br><span class="line">    <span class="comment">// this to confirm the proxy&#x27;s identity</span></span><br><span class="line">    proxyClientCert []<span class="type">byte</span></span><br><span class="line">    proxyClientKey  []<span class="type">byte</span></span><br><span class="line">    proxyTransport  *http.Transport</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Endpoints based routing to map from cluster IP to routable IP</span></span><br><span class="line">    serviceResolver ServiceResolver</span><br><span class="line"></span><br><span class="line">    handlingInfo atomic.Value</span><br><span class="line"></span><br><span class="line">    <span class="comment">// egressSelector selects the proper egress dialer to communicate with the custom apiserver</span></span><br><span class="line">    <span class="comment">// overwrites proxyTransport dialer if not nil</span></span><br><span class="line">    egressSelector *egressselector.EgressSelector</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> proxyHandlingInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// local indicates that this APIService is locally satisfied</span></span><br><span class="line">    local <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// name is the name of the APIService</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    <span class="comment">// restConfig holds the information for building a roundtripper</span></span><br><span class="line">    restConfig *restclient.Config</span><br><span class="line">    <span class="comment">// transportBuildingError is an error produced while building the transport.  If this</span></span><br><span class="line">    <span class="comment">// is non-nil, it will be reported to clients.</span></span><br><span class="line">    transportBuildingError <span class="type">error</span></span><br><span class="line">    <span class="comment">// proxyRoundTripper is the re-useable portion of the transport.  It does not vary with any request.</span></span><br><span class="line">    proxyRoundTripper http.RoundTripper</span><br><span class="line">    <span class="comment">// serviceName is the name of the service this handler proxies to</span></span><br><span class="line">    serviceName <span class="type">string</span></span><br><span class="line">    <span class="comment">// namespace is the namespace the service lives in</span></span><br><span class="line">    serviceNamespace <span class="type">string</span></span><br><span class="line">    <span class="comment">// serviceAvailable indicates this APIService is available or not</span></span><br><span class="line">    serviceAvailable <span class="type">bool</span></span><br><span class="line">    <span class="comment">// servicePort is the port of the service this handler proxies to</span></span><br><span class="line">    servicePort <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *proxyHandler)</span></span> updateAPIService(apiService *apiregistrationv1api.APIService) &#123;</span><br><span class="line">    <span class="keyword">if</span> apiService.Spec.Service == <span class="literal">nil</span> &#123;</span><br><span class="line">        r.handlingInfo.Store(proxyHandlingInfo&#123;local: <span class="literal">true</span>&#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newInfo := proxyHandlingInfo&#123;</span><br><span class="line">        name: apiService.Name,</span><br><span class="line">        restConfig: &amp;restclient.Config&#123;</span><br><span class="line">            TLSClientConfig: restclient.TLSClientConfig&#123;</span><br><span class="line">            Insecure:   apiService.Spec.InsecureSkipTLSVerify,</span><br><span class="line">            ServerName: apiService.Spec.Service.Name + <span class="string">&quot;.&quot;</span> + apiService.Spec.Service.Namespace + <span class="string">&quot;.svc&quot;</span>,</span><br><span class="line">            CertData:   r.proxyClientCert,</span><br><span class="line">            KeyData:    r.proxyClientKey,</span><br><span class="line">            CAData:     apiService.Spec.CABundle,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        serviceName:      apiService.Spec.Service.Name,</span><br><span class="line">        serviceNamespace: apiService.Spec.Service.Namespace,</span><br><span class="line">        servicePort:      *apiService.Spec.Service.Port,</span><br><span class="line">        serviceAvailable: apiregistrationv1apihelper.IsAPIServiceConditionTrue(apiService, apiregistrationv1api.Available),</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    newInfo.proxyRoundTripper, newInfo.transportBuildingError = restclient.TransportFor(newInfo.restConfig)</span><br><span class="line">    r.handlingInfo.Store(newInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>proxyHandler中有一个localDelegate成员变量，是一个http.Handler，它从APIAggregator的delegateHandler属性赋值过来，这个值又是在APIAggregator的New()方法传进来的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := &amp;APIAggregator&#123;</span><br><span class="line">        GenericAPIServer:         genericServer,</span><br><span class="line">        delegateHandler:          delegationTarget.UnprotectedHandler()</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是APIAggregator的delegationTarget的UnprotectedHandler()创建的，那这个UnprotectedHandler()是什么呢？来看下这个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span></span> UnprotectedHandler() http.Handler &#123;</span><br><span class="line">    <span class="comment">// when we delegate, we need the server we&#x27;re delegating to choose whether or not to use gorestful</span></span><br><span class="line">    <span class="keyword">return</span> s.Handler.Director</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个就是GenericAPIServer中的Handler的Director成员变量，该Handler中，还有一个成员变量是FullHandlerChain：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">APIServerHandler&#123;</span><br><span class="line">    FullHandlerChain:   handlerChainBuilder(director),</span><br><span class="line">    GoRestfulContainer: gorestfulContainer,</span><br><span class="line">    NonGoRestfulMux:    nonGoRestfulMux,</span><br><span class="line">    Director:           director,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个内容，我们在<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/10/05/kubernetes/kube-apiserver-genericapiserver.html">Kubernetes APIServer GenericAPIServer</a>有过介绍，FullHandlerChain在director外面包了很多filter，用来做认证授权这些操作，而Director则直接是director，即没有认证授权这些操作，director也是一个Handler，所以这里把它叫做UnprotectedHandler，意思是可以不经过认证授权，就可以直接被该Handler处理。前面在Delegation小节，我们介绍过，Aggregator的delegationTarget是KubeAPIServer，所以这里的Director其实就是KubeAPIServer的APIServerHandler中的Director，这样做的意图也很明显，就是当请求从Aggregator delegate给KubeAPIServer时，就不需要再认证了，因为请求在达到Aggregator的Handler时，就已经经过认证了。</p>
<p>除了这个localDelegate成员变量，还有一个需要关注的就是handlingInfo，它是一个原子变量，通过Store/Load对其内容进行存储和读取，在updateAPIService()方法中，将APIService转换成proxyHandlingInfo结构体，然后存储到handlingInfo变量中。注意，该方法的第一行内容，如果APIServiceSpec的Service为nil，则将proxyHandlingInfo的local属性置为true，意思是这是个local APIService，即前面介绍过的，KubeAPIServer和APIExtensins转换来的APIService，都是local APIService。</p>
<p>了解了以上内容，再来看下proxyHandler的处理逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"># kube-aggregator/pkg/apiserver/handler_proxy.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *proxyHandler)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    value := r.handlingInfo.Load()</span><br><span class="line">    <span class="keyword">if</span> value == <span class="literal">nil</span> &#123;</span><br><span class="line">        r.localDelegate.ServeHTTP(w, req)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    handlingInfo := value.(proxyHandlingInfo)</span><br><span class="line">    <span class="keyword">if</span> handlingInfo.local &#123;</span><br><span class="line">        <span class="keyword">if</span> r.localDelegate == <span class="literal">nil</span> &#123;</span><br><span class="line">            http.Error(w, <span class="string">&quot;&quot;</span>, http.StatusNotFound)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        r.localDelegate.ServeHTTP(w, req)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !handlingInfo.serviceAvailable &#123;</span><br><span class="line">        proxyError(w, req, <span class="string">&quot;service unavailable&quot;</span>, http.StatusServiceUnavailable)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> handlingInfo.transportBuildingError != <span class="literal">nil</span> &#123;</span><br><span class="line">        proxyError(w, req, handlingInfo.transportBuildingError.Error(), http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user, ok := genericapirequest.UserFrom(req.Context())</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        proxyError(w, req, <span class="string">&quot;missing user&quot;</span>, http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a new location based on the existing request pointed at the target service</span></span><br><span class="line">    location := &amp;url.URL&#123;&#125;</span><br><span class="line">    location.Scheme = <span class="string">&quot;https&quot;</span></span><br><span class="line">    rloc, err := r.serviceResolver.ResolveEndpoint(handlingInfo.serviceNamespace, handlingInfo.serviceName, handlingInfo.servicePort)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">&quot;error resolving %s/%s: %v&quot;</span>, handlingInfo.serviceNamespace, handlingInfo.serviceName, err)</span><br><span class="line">        proxyError(w, req, <span class="string">&quot;service unavailable&quot;</span>, http.StatusServiceUnavailable)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    location.Host = rloc.Host</span><br><span class="line">    location.Path = req.URL.Path</span><br><span class="line">    location.RawQuery = req.URL.Query().Encode()</span><br><span class="line"></span><br><span class="line">    newReq, cancelFn := newRequestForProxy(location, req)</span><br><span class="line">    <span class="keyword">defer</span> cancelFn()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> handlingInfo.proxyRoundTripper == <span class="literal">nil</span> &#123;</span><br><span class="line">        proxyError(w, req, <span class="string">&quot;&quot;</span>, http.StatusNotFound)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we need to wrap the roundtripper in another roundtripper which will apply the front proxy headers</span></span><br><span class="line">    proxyRoundTripper, upgrade, err := maybeWrapForConnectionUpgrades(handlingInfo.restConfig, handlingInfo.proxyRoundTripper, req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        proxyError(w, req, err.Error(), http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    proxyRoundTripper = transport.NewAuthProxyRoundTripper(user.GetName(), user.GetGroups(), user.GetExtra(), proxyRoundTripper)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we are upgrading, then the upgrade path tries to use this request with the TLS config we provide, but it does</span></span><br><span class="line">    <span class="comment">// NOT use the roundtripper.  Its a direct call that bypasses the round tripper.  This means that we have to</span></span><br><span class="line">    <span class="comment">// attach the &quot;correct&quot; user headers to the request ahead of time.  After the initial upgrade, we&#x27;ll be back</span></span><br><span class="line">    <span class="comment">// at the roundtripper flow, so we only have to muck with this request, but we do have to do it.</span></span><br><span class="line">    <span class="keyword">if</span> upgrade &#123;</span><br><span class="line">        transport.SetAuthProxyHeaders(newReq, user.GetName(), user.GetGroups(), user.GetExtra())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handler := proxy.NewUpgradeAwareHandler(location, proxyRoundTripper, <span class="literal">true</span>, upgrade, &amp;responder&#123;w: w&#125;)</span><br><span class="line">    handler.ServeHTTP(w, newReq)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到该方法整体逻辑还是比较简单的，最开始判断handlingInfo是否为local的，如果是，则由localDelegate去处理该请求，即由KubeAPIServer的Handler去处理，这样就将请求给delegate出去了，如果不是，则说明该请求应该是被外部的APIServer去处理，然后会使用handlingInfo中的APIService信息，构建一个proxy handler，将该请求给proxy出去，这个proxy handler的具体细节，这里就不展开了。</p>
<p>现在，我们来梳理下Aggregator到KubeAPIServer的delegation逻辑，在前面Delegation小节，我们介绍过CreateServerChain()最终构建出来一个aggregatorServer，aggregatorServer的delegationTarget是KubeAPIServer，而KubeAPIServer的delegationTarget又是APIExtensions APIServer，当Kubernetes APIServer最终运行起来时，其实运行的是aggregatorServer中的GenericAPIServer的启动逻辑，向net/http Server注册的Handler，其实是Aggregator中的GenericAPIServer中的Handler，所以整个API的入口，其实是Aggregator的Handler，又因为前面通过那两个poststarthook，将KubeAPIServer和APIExtensions APIServer中的API对象资源，转换成了Aggregator的APIService，并且为每一个APIService注册了proxyHandler来处理请求，并且是注册到NonGoRestfulMux中的，所以，当任何请求到APIServer时，都是由Aggregator中的GenericAPIServer中的Handler中的NonGoRestfulMux来处理的，但是在这之前，是要先经过包围在Handler外的filter处理的，即经过认证授权等操作，再进入到NonGoRestfulMux的处理逻辑，然后NonGoRestfulMux又根据路径路由到对应的proxyHandler来处理，即进入了上面proxyHandler的ServeHTTP()方法，如果发现对应的APIService是local的，就需要将该请求delegate给它的delegationTarget来进一步处理，即KubeAPIServer的GenericAPIServer，这样就到了KubeAPIServer的GenericAPIServer的Handler的处理逻辑了。</p>
<h2 id="KubeAPIServer-Handler"><a href="#KubeAPIServer-Handler" class="headerlink" title="KubeAPIServer Handler"></a>KubeAPIServer Handler</h2><p>经过上面的分析，请求被Aggregator delegate到了KubeAPIServer的GenericAPIServer的Handler进行处理，注意是UnprotectedHandler，也即Director对应的Handler，即delegate的请求，是不经过认证授权的，到了这里，就比较好理解了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/server/handler.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d director)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    path := req.URL.Path</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check to see if our webservices want to claim this path</span></span><br><span class="line">    <span class="keyword">for</span> _, ws := <span class="keyword">range</span> d.goRestfulContainer.RegisteredWebServices() &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> ws.RootPath() == <span class="string">&quot;/apis&quot;</span>:</span><br><span class="line">            <span class="comment">// if we are exactly /apis or /apis/, then we need special handling in loop.</span></span><br><span class="line">            <span class="comment">// normally these are passed to the nonGoRestfulMux, but if discovery is enabled, it will go directly.</span></span><br><span class="line">            <span class="comment">// We can&#x27;t rely on a prefix match since /apis matches everything (see the big comment on Director above)</span></span><br><span class="line">            <span class="keyword">if</span> path == <span class="string">&quot;/apis&quot;</span> || path == <span class="string">&quot;/apis/&quot;</span> &#123;</span><br><span class="line">                klog.V(<span class="number">5</span>).Infof(<span class="string">&quot;%v: %v %q satisfied by gorestful with webservice %v&quot;</span>, d.name, req.Method, path, ws.RootPath())</span><br><span class="line">                <span class="comment">// don&#x27;t use servemux here because gorestful servemuxes get messed up when removing webservices</span></span><br><span class="line">                <span class="comment">// TODO fix gorestful, remove TPRs, or stop using gorestful</span></span><br><span class="line">                d.goRestfulContainer.Dispatch(w, req)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> strings.HasPrefix(path, ws.RootPath()):</span><br><span class="line">            <span class="comment">// ensure an exact match or a path boundary match</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(ws.RootPath()) || path[<span class="built_in">len</span>(ws.RootPath())] == <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">                klog.V(<span class="number">5</span>).Infof(<span class="string">&quot;%v: %v %q satisfied by gorestful with webservice %v&quot;</span>, d.name, req.Method, path, ws.RootPath())</span><br><span class="line">                <span class="comment">// don&#x27;t use servemux here because gorestful servemuxes get messed up when removing webservices</span></span><br><span class="line">                <span class="comment">// TODO fix gorestful, remove TPRs, or stop using gorestful</span></span><br><span class="line">                d.goRestfulContainer.Dispatch(w, req)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we didn&#x27;t find a match, then we just skip gorestful altogether</span></span><br><span class="line">    klog.V(<span class="number">5</span>).Infof(<span class="string">&quot;%v: %v %q satisfied by nonGoRestful&quot;</span>, d.name, req.Method, path)</span><br><span class="line">    d.nonGoRestfulMux.ServeHTTP(w, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为KubeAPIServer中的API对象资源，都是注册到goRestfulContainer中的，所以，这些API对象，都是由goRestfulContainer进行路由，找到对应的WebService进行处理，即上面的<code>d.goRestfulContainer.Dispatch()</code>方法，如果goRestfulContainer没有匹配到对应的路径，则由nonGoRestfulMux来进一步处理。那KubeAPIServer又是怎么Delegate给APIExtensions APIServer的呢？其实是通过nonGoRestfulMux的NotFoundHandler来实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/server/config.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span></span> New(name <span class="type">string</span>, delegationTarget DelegationTarget) (*GenericAPIServer, <span class="type">error</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">    handlerChainBuilder := <span class="function"><span class="keyword">func</span><span class="params">(handler http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">        <span class="keyword">return</span> c.BuildHandlerChainFunc(handler, c.Config)</span><br><span class="line">    &#125;</span><br><span class="line">    apiServerHandler := NewAPIServerHandler(name, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler())</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># apiserver/pkg/server/handler.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAPIServerHandler</span><span class="params">(name <span class="type">string</span>, s runtime.NegotiatedSerializer, handlerChainBuilder HandlerChainBuilderFn, notFoundHandler http.Handler)</span></span> *APIServerHandler &#123;</span><br><span class="line">    nonGoRestfulMux := mux.NewPathRecorderMux(name)</span><br><span class="line">    <span class="keyword">if</span> notFoundHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">        nonGoRestfulMux.NotFoundHandler(notFoundHandler)</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，GenericAPIServer的New()方法中，将delegationTarget.UnprotectedHandler()，即Director，传递给NewAPIServerHandler()，对应的参数为notFoundHandler，并通过nonGoRestfulMux的NotFoundHandler()方法注册进去，这个notFoundHandler的作用，就是在所有的注册到nonGoRestfulMux中的路径都没有匹配到时，则由该Handler进行处理，在<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/10/04/kubernetes/kube-apiserver-nongorestfulmux.html">Kubernetes APIServer NonGoRestfulMux</a>中有过介绍，而在KubeAPIServer中，这个notFoundHandler就是注册的APIExtensions APIServer中的GenericAPIServer中的Handler中的Director。</p>
<p>所以，再结合上面的director的处理逻辑，goRestfulContainer没有匹配到路径，则进入到nonGoRestfulMux，nonGoRestfulMux再没有匹配到路径，则进入到notFoundHander进行处理，这就进入到了APIExtensions APIServer的Handler处理逻辑了。</p>
<h2 id="APIExtensions-crdHandler"><a href="#APIExtensions-crdHandler" class="headerlink" title="APIExtensions crdHandler"></a>APIExtensions crdHandler</h2><p>最后到了APIExtensions的GenericAPIServer的Handler，我们先来看下它是如何构建的，在CustomResourceDefinitions的New()方法中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># apiextensions-apiserver/pkg/apiserver/apiserver.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span></span> New(delegationTarget genericapiserver.DelegationTarget) (*CustomResourceDefinitions, <span class="type">error</span>) &#123;</span><br><span class="line">    genericServer, err := c.GenericConfig.New(<span class="string">&quot;apiextensions-apiserver&quot;</span>, delegationTarget)</span><br><span class="line">    s := &amp;CustomResourceDefinitions&#123;</span><br><span class="line">        GenericAPIServer: genericServer,</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    delegateHandler := delegationTarget.UnprotectedHandler()</span><br><span class="line">    <span class="keyword">if</span> delegateHandler == <span class="literal">nil</span> &#123;</span><br><span class="line">        delegateHandler = http.NotFoundHandler()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    crdHandler, err := NewCustomResourceDefinitionHandler(</span><br><span class="line">        versionDiscoveryHandler,</span><br><span class="line">        groupDiscoveryHandler,</span><br><span class="line">        s.Informers.Apiextensions().V1().CustomResourceDefinitions(),</span><br><span class="line">        delegateHandler,</span><br><span class="line">        c.ExtraConfig.CRDRESTOptionsGetter,</span><br><span class="line">        c.GenericConfig.AdmissionControl,</span><br><span class="line">        establishingController,</span><br><span class="line">        c.ExtraConfig.ServiceResolver,</span><br><span class="line">        c.ExtraConfig.AuthResolverWrapper,</span><br><span class="line">        c.ExtraConfig.MasterCount,</span><br><span class="line">        s.GenericAPIServer.Authorizer,</span><br><span class="line">        c.GenericConfig.RequestTimeout,</span><br><span class="line">        time.Duration(c.GenericConfig.MinRequestTimeout)*time.Second,</span><br><span class="line">        apiGroupInfo.StaticOpenAPISpec,</span><br><span class="line">        c.GenericConfig.MaxRequestBodyBytes,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    s.GenericAPIServer.Handler.NonGoRestfulMux.Handle(<span class="string">&quot;/apis&quot;</span>, crdHandler)</span><br><span class="line">    s.GenericAPIServer.Handler.NonGoRestfulMux.HandlePrefix(<span class="string">&quot;/apis/&quot;</span>, crdHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，它构建了一个crdHandler，然后将其注册到了<code>CustomResourceDefinitions.GenericAPIServer.Handler.NonGoRestfulMux</code>中，注册的路径为<code>&quot;/apis&quot;</code>或者是以<code>&quot;/apis/&quot;</code>开头的路径。这样当请求自定义的资源时，就会由注册到GenericAPIServer中的NonGoRestfulMux中的crdHandler进行处理，该crdHandler的ServeHTTP()方法又是一个非常复杂的实现，此外还定义了很多Controller，添加到poststarthook中，来对CRD资源进行处理，这里就不介绍了。</p>
<h2 id="PostStartHook-Delegation"><a href="#PostStartHook-Delegation" class="headerlink" title="PostStartHook Delegation"></a>PostStartHook Delegation</h2><p>最后，关于PostStartHook还有一个特殊点需要介绍下，KubeAPIServer, APIExtensions APIServer和Aggregator这三个APIServer delegation之后，注册在他们中的poststarthook其实也被delegate了，看下GenericAPIServer的New()方法有下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># apiserver/pkg/server/config.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span></span> New(name <span class="type">string</span>, delegationTarget DelegationTarget) (*GenericAPIServer, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// first add poststarthooks from delegated targets</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> delegationTarget.PostStartHooks() &#123;</span><br><span class="line">        s.postStartHooks[k] = v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> delegationTarget.PreShutdownHooks() &#123;</span><br><span class="line">        s.preShutdownHooks[k] = v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即当前的GenericAPIServer把它的delegationTarget的PostStartHook添加到了自己的postStartHooks中来，即KubeAPIServer包含了APIExtensions的PostStartHooks，而Aggregator又包含了KubeAPIServer的PostStartHooks，这样，这三者中所有的PostStartHooks就都注册到了Aggregator中，又因为服务启动时，是运行的Aggregator的GenericAPIServer，通过这种方式，将所有的poststarthooks启动起来，而不是分别运行的这三个APIServer中的poststarthooks，所以这些poststarthooks只被启动了一次，并没有重复运行。下面是我盘点的当前版本的Kubernetes中的PostStartHooks:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">* APIAggregator</span><br><span class="line">    * GenericAPIServer <span class="comment">// kube-aggregator</span></span><br><span class="line">        * delegationTarget    <span class="comment">// Master.GenericAPIServer</span></span><br><span class="line">        * Handler <span class="comment">// APIServerHandler</span></span><br><span class="line">            * NonGoRestfulMux</span><br><span class="line">                * NotFoundHandler <span class="comment">//  Master.GenericAPIServer.Handler.Director</span></span><br><span class="line">            * GoRestfulContainer</span><br><span class="line">            * FullHandlerChain</span><br><span class="line">            * Director</span><br><span class="line">        * postStartHooks</span><br><span class="line">            * <span class="comment">// CustomResourceDefinitions</span></span><br><span class="line">            * start-apiextensions-informers</span><br><span class="line">            * start-apiextensions-controllers</span><br><span class="line">            * crd-informer-synced</span><br><span class="line">            * <span class="comment">// Config</span></span><br><span class="line">            * start-kube-apiserver-admission-initializer</span><br><span class="line">            * <span class="comment">// Generic</span></span><br><span class="line">            * generic-apiserver-start-informers</span><br><span class="line">            * priority-and-fairness-config-consumer</span><br><span class="line">            * <span class="comment">// Master</span></span><br><span class="line">            * bootstrap-controller</span><br><span class="line">            * scheduling/bootstrap-system-priority-classes</span><br><span class="line">            * priority-and-fairness-config-producer</span><br><span class="line">            * rbac/bootstrap-roles</span><br><span class="line">            * start-cluster-authentication-info-controller</span><br><span class="line">            * <span class="comment">// Aggregator</span></span><br><span class="line">            * start-kube-aggregator-informers</span><br><span class="line">            * apiservice-registration-controller <span class="comment">// 将APIService转换成proxyHandler，注册进NonGoRestfulMux</span></span><br><span class="line">                * AddAPIService()</span><br><span class="line">            * apiservice-status-available-controller</span><br><span class="line">            * kube-apiserver-autoregistration <span class="comment">// 将apiserver+crd中的groupversion通过API注册进apiservice</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章在前面文章的基础上，梳理了APIServer的扩展机制，只是梳理了大致脉络，很多无关的细节都省略了，可能还是要结合代码和前面的文章，才能好理解一些，最后我们还是来总结一下：</p>
<ul>
<li>在aggregator启动的时候，即在createAggregatorServer()方法中，crd和apiserver中定义的资源组(GroupVersion)，会通过kube-apiserver-autoregistration poststarthook，被转换成APIService，然后注册进aggregator中，比如将GroupVersion{group: “apps”, version: “v1”}转成APIService，存进数据库中。apiserver中的资源因为是k8s内置的，是固定的，所以只需要在启动的时候，注册一次就可以了，但是CRD中的资源，因为可能会变动，所以需要不断的进行更新同步。</li>
<li>crd + apiserver + aggregator中的资源，都会转换成APIService，然后在apiservice-registration-controller poststarthook 中，以path: proxyHandler的形式，注册进aggregator的GenericAPIServer的NonGoRestfulMux中，只不过crd + apiserver中的资源被转换成的APIService只是形式上的转换，即只包含APIService的name和Kind，apiService.Spec.Service是nil，即是local的资源，这类资源，aggregator并不会proxy给外部的apiextension-apiserver，而是会让delegateHandler去处理，aggregator的delegateTarget是apiserver的Instance.GenericAPIServer，即将请求传给了kube-apiserver去处理。剩下的真正的APIService，则被proxy出去，由外部的APIServer去处理。</li>
<li>整个apiserver的入口是aggregator，run的是aggregator的genericapiserver，请求先到aggregator的GenericAPIServer的Handler，经过一系列handler chain之后，最终到达了director的handler，然后再由其根据path进行分发，因为apiserver+crd中的资源，都以APIService注册进aggregator中的GenericAPIServer中的NonGoRestfulMux，所以根据path，先分发到aggregator中对应的proxyHandler，然后发现是local的，于是再让delegateHandler进行处理，这样就进入到了kube-apiserver的Instance.GenericAPIServer.Handler.Director处理逻辑，k8s内置的标准的资源对象，都是在这里进行处理的，如果在Instance的GenericAPIServer中没匹配到对应的path，则会进入到nonGoRestfulMux的NotFoundHandler中进行处理，这样就进入到了CustomResourceDefinitions.GenericAPIServer.Handler.Director中，CRD的资源都是在这里进行处理的。</li>
<li>从上面的实现机制来看，感觉又有点过度设计的嫌疑，费了很大劲把KubeAPIServer和CRD中的资源都转成了APIService，但是实际上并没有多大的作用，仅仅是判断下是否为local就给delegate出去了，而且把<code>Pod</code>等这类内置的资源转成APIService也跟<code>APIService</code>的定义不符合，APIService的定义应该是一个API服务，要转也是把KubeAPIService以及APIExtension这种级别的APIServer给转成APIService才算合理，所以这种实现方式稍微有点诡异，让人很费解。</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Kubernetes APIServer扩展机制原理</p><p><a href="https://hackerain.me/2020/10/08/kubernetes/kube-apiserver-extensions.html">https://hackerain.me/2020/10/08/kubernetes/kube-apiserver-extensions.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>hackerain</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-10-08</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-10-28</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/kubernetes/">kubernetes</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/11/09/openstack/keystone-fernet-token.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Keystone Fernet Token解析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/10/06/kubernetes/kube-apiserver-api-resource-installation.html"><span class="level-item">Kubernetes APIServer API Resource Installation</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/assets/avatar.jpg" alt="开心BOY"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">开心BOY</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">45</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="/about" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/hackerain"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="知识星球" href="https://t.zsxq.com/0bWmBFDpu"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Delegation"><span class="level-left"><span class="level-item">1</span><span class="level-item">Delegation</span></span></a></li><li><a class="level is-mobile" href="#kube-apiserver-autoregistration"><span class="level-left"><span class="level-item">2</span><span class="level-item">kube-apiserver-autoregistration</span></span></a></li><li><a class="level is-mobile" href="#apiservice-registration-controller"><span class="level-left"><span class="level-item">3</span><span class="level-item">apiservice-registration-controller</span></span></a></li><li><a class="level is-mobile" href="#Aggregator-proxyHandler"><span class="level-left"><span class="level-item">4</span><span class="level-item">Aggregator proxyHandler</span></span></a></li><li><a class="level is-mobile" href="#KubeAPIServer-Handler"><span class="level-left"><span class="level-item">5</span><span class="level-item">KubeAPIServer Handler</span></span></a></li><li><a class="level is-mobile" href="#APIExtensions-crdHandler"><span class="level-left"><span class="level-item">6</span><span class="level-item">APIExtensions crdHandler</span></span></a></li><li><a class="level is-mobile" href="#PostStartHook-Delegation"><span class="level-left"><span class="level-item">7</span><span class="level-item">PostStartHook Delegation</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">8</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-18T00:00:00.000Z">2023-11-18</time></p><p class="title"><a href="/2023/11/18/kubernetes/kube-controller-runtime.html">Kubernetes controller-runtime 介绍</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-12T00:00:00.000Z">2023-11-12</time></p><p class="title"><a href="/2023/11/12/kubernetes/kube-versioning-codec.html">Kubernetes API Codec 解析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-11T00:00:00.000Z">2023-11-11</time></p><p class="title"><a href="/2023/11/11/kubernetes/kube-versioning-scheme.html">Kubernetes API Scheme 解析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-28T00:00:00.000Z">2023-10-28</time></p><p class="title"><a href="/2023/10/28/kubernetes/kube-versioning.html">Kubernetes API 多版本和序列化</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-26T00:00:00.000Z">2022-09-26</time></p><p class="title"><a href="/2022/09/26/elasticsearch/elasticsearch_large_text_field.html">Elasticsearch大文本字段(large text field)优化方案</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/"><span class="level-start"><span class="level-item">2017</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ceph/"><span class="tag">ceph</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/elasticsearch/"><span class="tag">elasticsearch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kubernetes/"><span class="tag">kubernetes</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/openstack/"><span class="tag">openstack</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/operations/"><span class="tag">operations</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/umi/"><span class="tag">umi</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/assets/logo.jpg" alt="开心BOY" height="28"></a><p class="is-size-7"><span>&copy; 2023 hackerain</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hackerain"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Kubernetes API Scheme 解析 - 开心BOY</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="开心BOY"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="开心BOY"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="概述在 Kubernetes API 多版本和序列化 这篇文章中，介绍了API多版本的功能和实现原理，其中Scheme就是其实现原理的一项重要机制，在平时的开发中也经常会遇到，本篇文章就对其进行下分析。 Scheme起到了一个类型（Type）注册中心的作用，在API Server内部，全局只有一个Scheme实例，各个版本的API资源，会将他们的类型，注册到Scheme中来，同时，也会将如何进行类"><meta property="og:type" content="blog"><meta property="og:title" content="Kubernetes API Scheme 解析"><meta property="og:url" content="https://hackerain.me/2023/11/11/kubernetes/kube-versioning-scheme.html"><meta property="og:site_name" content="开心BOY"><meta property="og:description" content="概述在 Kubernetes API 多版本和序列化 这篇文章中，介绍了API多版本的功能和实现原理，其中Scheme就是其实现原理的一项重要机制，在平时的开发中也经常会遇到，本篇文章就对其进行下分析。 Scheme起到了一个类型（Type）注册中心的作用，在API Server内部，全局只有一个Scheme实例，各个版本的API资源，会将他们的类型，注册到Scheme中来，同时，也会将如何进行类"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hackerain.me/assets/kubernetes_scheme_class.drawio.png"><meta property="og:image" content="https://hackerain.me/assets/kubernetes_versioning_gvktotype.png"><meta property="og:image" content="https://hackerain.me/assets/kubernetes_versioning_flowcontrol_internal.png"><meta property="og:image" content="https://hackerain.me/assets/kubernetes_versioning_flowcontrol_external.png"><meta property="article:published_time" content="2023-11-11T00:00:00.000Z"><meta property="article:modified_time" content="2023-11-12T10:53:24.323Z"><meta property="article:author" content="hackerain"><meta property="article:tag" content="kubernetes"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hackerain.me/assets/kubernetes_scheme_class.drawio.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hackerain.me/2023/11/11/kubernetes/kube-versioning-scheme.html"},"headline":"Kubernetes API Scheme 解析","image":["https://hackerain.me/assets/kubernetes_scheme_class.drawio.png","https://hackerain.me/assets/kubernetes_versioning_gvktotype.png","https://hackerain.me/assets/kubernetes_versioning_flowcontrol_internal.png","https://hackerain.me/assets/kubernetes_versioning_flowcontrol_external.png"],"datePublished":"2023-11-11T00:00:00.000Z","dateModified":"2023-11-12T10:53:24.323Z","author":{"@type":"Person","name":"hackerain"},"publisher":{"@type":"Organization","name":"开心BOY","logo":{"@type":"ImageObject","url":"https://hackerain.me/assets/logo.jpg"}},"description":"概述在 Kubernetes API 多版本和序列化 这篇文章中，介绍了API多版本的功能和实现原理，其中Scheme就是其实现原理的一项重要机制，在平时的开发中也经常会遇到，本篇文章就对其进行下分析。 Scheme起到了一个类型（Type）注册中心的作用，在API Server内部，全局只有一个Scheme实例，各个版本的API资源，会将他们的类型，注册到Scheme中来，同时，也会将如何进行类"}</script><link rel="canonical" href="https://hackerain.me/2023/11/11/kubernetes/kube-versioning-scheme.html"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="开心BOY" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/assets/logo.jpg" alt="开心BOY" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-11T00:00:00.000Z" title="11/11/2023, 12:00:00 AM">2023-11-11</time>发表</span><span class="level-item"><time dateTime="2023-11-12T10:53:24.323Z" title="11/12/2023, 10:53:24 AM">2023-11-12</time>更新</span><span class="level-item">44 分钟读完 (大约6625个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Kubernetes API Scheme 解析</h1><div class="content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 <a target="_blank" rel="noopener" href="https://hackerain.github.io/2023/10/28/kubernetes/kube-scheme.html">Kubernetes API 多版本和序列化</a> 这篇文章中，介绍了API多版本的功能和实现原理，其中Scheme就是其实现原理的一项重要机制，在平时的开发中也经常会遇到，本篇文章就对其进行下分析。</p>
<p>Scheme起到了一个类型（Type）注册中心的作用，在API Server内部，全局只有一个Scheme实例，各个版本的API资源，会将他们的类型，注册到Scheme中来，同时，也会将如何进行类型转换的方法注册到Scheme中来，后续在Handler中进行版本转换以及序列化时，则会使用Scheme中注册的类型创建对应版本的对象，以及使用注册的类型转换的方法对不同版本的对象进行转换。</p>
<span id="more"></span>

<h2 id="什么是类型"><a href="#什么是类型" class="headerlink" title="什么是类型"></a>什么是类型</h2><p>所以，理解什么是类型，即Type，很关键，我觉得可以简单的将类型理解为一个<code>Go Struct</code>的定义，就是各种API资源的结构体定义，可以从这个类型直接创建出来该结构体的实例，而不用直接使用该结构体去创建，这到底是怎么实现的呢？答案就是反射，即<a target="_blank" rel="noopener" href="https://pkg.go.dev/reflect">Reflect</a>。</p>
<p>关于反射，这里不过多解释，建议提前阅读下官方的这篇博客，<a target="_blank" rel="noopener" href="https://go.dev/blog/laws-of-reflection">The Laws of Reflection</a>，比较清晰。这里我们就举个简单的小例子来实际感受下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录结构</span></span><br><span class="line">.</span><br><span class="line">├── <span class="keyword">go</span>.mod</span><br><span class="line">├── main.<span class="keyword">go</span></span><br><span class="line">├── types.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// types.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  X1 <span class="type">string</span></span><br><span class="line">  X2 <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  f := &amp;Foo&#123;&#125;</span><br><span class="line">  t := reflect.TypeOf(f).Elem()</span><br><span class="line">  fmt.Println(t) <span class="comment">// main.Foo</span></span><br><span class="line">  fmt.Println(t.Name()) <span class="comment">// Foo</span></span><br><span class="line"></span><br><span class="line">  v, _ := reflect.New(t).Interface().(Foo)</span><br><span class="line">  v.X1 = <span class="string">&quot;nice&quot;</span></span><br><span class="line">  v.X2 = <span class="string">&quot;woce&quot;</span></span><br><span class="line">  fmt.Println(v) <span class="comment">//&#123;nice woce&#125;</span></span><br><span class="line"></span><br><span class="line">  fv := Foo&#123;X1: <span class="string">&quot;nice&quot;</span>, X2: <span class="string">&quot;woce&quot;</span>&#125;</span><br><span class="line">  fmt.Println(fv) <span class="comment">//&#123;nice woce&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在types.go中定义了一个Foo结构体，有两个属性X1和X2，然后在main方法中，先创建了一个空的Foo实例，将其指针赋值给 <code>f</code>，然后通过 <code>reflect.TypeOf(f).Elem()</code> 得到的值 <code>t</code> 就是Foo结构体的 <code>类型</code>，有了这个类型，就可以通过 <code>reflect.New(t).Interface()</code> 创建一个该类型的实例，但是这得到的只是一个interface类型的实例，还需要将其转换成具体的Foo类型的实例才能使用，这样就相当于创建了一个Foo结构体的实例 <code>v</code>，跟下面的 <code>fv</code> 直接使用Foo结构体创建的实例其实是等价的。</p>
<p>所以，反射其实还是挺好理解的，就是给一个变量，能够通过反射，知道该变量的类型以及具体的值，很多语言里都有反射的机制，像最熟悉的Python，可以通过 <code>getattr()</code>、<code>setattr()</code>方法去获取、设置某个变量的属性，还有通过 <code>__import__()</code> 方法动态的根据一个字符串路径去导入一个模块。</p>
<p>某种程度上，Go反射里面的 <code>类型 Type</code> 其实就跟Python里的 <code>__import__()</code> 有异曲同工之处，知道了一个字符串，就可以导入一个模块，知道了一个类型，就可以去实例化一个它的对象，所以Scheme就是这样一个类型注册中心，把所有的API资源结构体的类型全注册进来，需要时，就找到对应资源的类型，然后实例化一个它的对象。</p>
<p>我们再来把上面的例子稍微扩展一下，用简单的例子模拟下Scheme中的用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录结构</span></span><br><span class="line">.</span><br><span class="line">├── <span class="keyword">go</span>.mod</span><br><span class="line">├── main.<span class="keyword">go</span></span><br><span class="line">├── meta</span><br><span class="line">│   └── types.<span class="keyword">go</span></span><br><span class="line">├── types.<span class="keyword">go</span></span><br><span class="line">├── v1</span><br><span class="line">│   └── types.<span class="keyword">go</span></span><br><span class="line">└── v2</span><br><span class="line">    └── types.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// meta/types.go</span></span><br><span class="line"><span class="keyword">package</span> meta</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">  X1 <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// types.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;testgo/meta&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  X1 <span class="type">string</span></span><br><span class="line">  X2 <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  Status meta.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v1/types.go</span></span><br><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;testgo/meta&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  X1 <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  Status meta.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v2/types.go</span></span><br><span class="line"><span class="keyword">package</span> v2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;testgo/meta&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  X1 <span class="type">string</span></span><br><span class="line">  X2 <span class="type">string</span></span><br><span class="line"></span><br><span class="line">  Status meta.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">  <span class="string">&quot;testgo/v1&quot;</span></span><br><span class="line">  <span class="string">&quot;testgo/v2&quot;</span></span><br><span class="line">  <span class="string">&quot;testgo/meta&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  f := &amp;Foo&#123;&#125;</span><br><span class="line">  t := reflect.TypeOf(f).Elem()</span><br><span class="line">  fmt.Println(t) <span class="comment">// main.Foo</span></span><br><span class="line">  fmt.Println(t.Name()) <span class="comment">// Foo</span></span><br><span class="line"></span><br><span class="line">  v, _ := reflect.New(t).Interface().(Foo)</span><br><span class="line">  v.X1 = <span class="string">&quot;nice&quot;</span></span><br><span class="line">  v.X2 = <span class="string">&quot;woce&quot;</span></span><br><span class="line">  v.Status = meta.Status&#123;X1: <span class="string">&quot;tace&quot;</span>&#125;</span><br><span class="line">  fmt.Println(v) <span class="comment">//&#123;nice woce &#123;tace&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">  fv := Foo&#123;X1: <span class="string">&quot;nice&quot;</span>, X2: <span class="string">&quot;woce&quot;</span>, Status: meta.Status&#123;X1: <span class="string">&quot;tace&quot;</span>&#125;&#125;</span><br><span class="line">  fmt.Println(fv) <span class="comment">//&#123;nice woce &#123;tace&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">  f1 := &amp;v1.Foo&#123;&#125;</span><br><span class="line">  t1 := reflect.TypeOf(f1).Elem()</span><br><span class="line">  fmt.Println(t1) <span class="comment">// v1.Foo</span></span><br><span class="line">  fmt.Println(t1.Name()) <span class="comment">// Foo</span></span><br><span class="line"></span><br><span class="line">  f2 := &amp;v2.Foo&#123;&#125;</span><br><span class="line">  t2 := reflect.TypeOf(f2).Elem()</span><br><span class="line">  fmt.Println(t2) <span class="comment">// v2.Foo</span></span><br><span class="line">  fmt.Println(t2.Name()) <span class="comment">// Foo</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(t1 == t2) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">  s1 := &amp;meta.Status&#123;&#125;</span><br><span class="line">  s2 := &amp;meta.Status&#123;&#125;</span><br><span class="line">  t3 := reflect.TypeOf(s1).Elem()</span><br><span class="line">  t4 := reflect.TypeOf(s2).Elem()</span><br><span class="line"></span><br><span class="line">  fmt.Println(t3 == t4) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中，在原来的基础上，又添加了一个meta.Status结构体，并且添加了v1, v2版本的Foo，而且给每个版本的Foo都加了一个meta.Status属性，然后分别获得了他们的类型：t, t1, t2, t3, t4，从上面的 <code>t1 == t2</code> 为 false，可以判断t1和t2是两个不同的类型，虽然他们都叫Foo，而 <code>t3 == t4</code> 为true，说明他们是同一个类型，虽然是从两个对象上获取的类型，所以本质上，每一个结构体的定义，就对应着一个类型，不论这个结构体定义在哪里，只要我们知道了它的类型，就能够实例化它。</p>
<p>而在Kubernetes中，类型一般是比较复杂的，一个API资源类型会定义很多个字段，而且类型是分版本的，而版本又分内部版本和外部版本，所以这个类型就是多版本API的基础。回过头来看看上一个小节提到的 <code>FlowScheme</code> 示例，<code>k8s.io/api/flowcontrol/v1beta2/types.go</code> 和 <code>k8s.io/api/flowcontrol/v1beta3/types.go</code> 中定义的Struct就是内部版本的类型，并且从上面的分析可以知道，<code>v1beta2</code> 中的 <code>FlowSchema</code> 和 <code>v1beta3</code> 中的 <code>FlowSchema</code> 其实是两个类型，属于不同的版本，虽然他们的名字一样，但是他们里面的属性可能会有差别，而且他们是定义在单独的第三方库 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/api">k8s.io/api</a> 中的，可以独立发布，方便客户端进行引用，而 <code>kubernetes/pkg/apis/flowcontrol/types.go</code> 中定义的Struct则是内部版本的类型，因为只在Kubernetes内部使用到，所以放到了Kubernetes代码目录树内，是Kubernetes本身的一部分。在Kubernetes中，所有的内部版本的类型，都放到了 <code>kubernetes/pkg/apis/</code> 目录下，而所有的外部版本的类型，都放到了 <code>k8s.io/api</code> 项目中，然后都以组的方式进行分类管理。</p>
<p>理解了类型，我们就比较好理解Scheme了，是时候祭出Scheme的类图，来近距离看看它了：</p>
<p><img src="/assets/kubernetes_scheme_class.drawio.png"></p>
<p>它的核心代码位于 <code>k8s.io/apimachinery/pkg/runtime/scheme.go</code> 中，<a target="_blank" rel="noopener" href="https://github.com/kubernetes/apimachinery">k8s.io/apimachinery</a> 也是一个第三方库，跟 k8s.io/api 类似，都是为了方便客户端开发引用，所以才从Kubernetes主代码树里剥离出来的，可以看到Scheme还是一个比较复杂的结构体，属性虽然不多，但是方法很多，而且实现了很多接口，我们来介绍几个比较主要的内容，先忽略一些不重要的信息，否则内容太多。</p>
<h2 id="类型注册"><a href="#类型注册" class="headerlink" title="类型注册"></a>类型注册</h2><p>首先最最重要的就是 <code>gvkToType</code> 和 <code>typeToGVK</code> 这两个map了，他们就是存放注册进来的类型的，通过下面的 <code>AddKnownTypes()</code> 和 <code>AddKnownTypeWithName()</code>方法注册进来，在该方法中，就调用了上面示例中提到的 <code>reflect.TypeOf(f).Elem()</code> 方法去获取一个对象的类型，我们先来看看这个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheme)</span></span> AddKnownTypes(gv schema.GroupVersion, types ...Object) &#123;</span><br><span class="line">  s.addObservedVersion(gv)</span><br><span class="line">  <span class="keyword">for</span> _, obj := <span class="keyword">range</span> types &#123;</span><br><span class="line">    t := reflect.TypeOf(obj)</span><br><span class="line">    <span class="keyword">if</span> t.Kind() != reflect.Pointer &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;All types must be pointers to structs.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t = t.Elem()</span><br><span class="line">    s.AddKnownTypeWithName(gv.WithKind(t.Name()), obj)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheme)</span></span> AddKnownTypeWithName(gvk schema.GroupVersionKind, obj Object) &#123;</span><br><span class="line">    ......</span><br><span class="line">    t := reflect.TypeOf(obj)</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> t.Kind() != reflect.Pointer &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;All types must be pointers to structs.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t = t.Elem()</span><br><span class="line">    <span class="keyword">if</span> t.Kind() != reflect.Struct &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;All types must be pointers to structs.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    s.gvkToType[gvk] = t</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, existingGvk := <span class="keyword">range</span> s.typeToGVK[t] &#123;</span><br><span class="line">        <span class="keyword">if</span> existingGvk == gvk &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.typeToGVK[t] = <span class="built_in">append</span>(s.typeToGVK[t], gvk)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到从obj中解析出该对象的Type(类型)之后，会将Type与GVK的对应关系分别存到 <code>gvkToType</code> 和 <code>typeToGVK</code> 两个map中，<code>gvkToType</code>是 <code>GroupVersionKind</code> 到 <code>reflect.Type</code> 的映射，即给出一个GVK，那就能找到它对应的类型，而且是有且仅有一个类型与GVK相对，比如GVK为 <code>GroupVersionKind&#123;Group: &quot;flowcontrol.apiserver.k8s.io&quot;, Version: &quot;v1beta2&quot;, Kind: &quot;FlowSchema&quot;&#125;</code>，那它对应到的类型（Type）就是定义在 <code>k8s.io/api/flowcontrol/v1beta2/types.go</code> 中的 <code>FlowSchema</code> 结构体，而 <code>typeToGVK</code> 则正好反过来，是类型到GVK的映射，但是这个不一样的是GVK是一个列表，即一个类型（Type）可能对应多个GVK，这个该怎么理解呢？其实这个的意思是，一个类型可能被多个GVK引用，比如一些公用的类型，像<code>WatchEvent</code>, <code>ListOptions</code>等，所以，GVK和Type是这样一个对应关系：</p>
<p><img src="/assets/kubernetes_versioning_gvktotype.png"></p>
<p>根据某个GVK能找到唯一的一个Type，但是根据Type找GVK，可能会有多个GVK的情况，这种一般都是公共的元数据的资源类型，其他的API资源类型基本上都是一对一的关系。</p>
<p>与之相关的，是下面两个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheme)</span></span> ObjectKinds(obj Object) ([]schema.GroupVersionKind, <span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  ......</span><br><span class="line">  v, err := conversion.EnforcePtr(obj)</span><br><span class="line">  ......</span><br><span class="line">  t := v.Type()</span><br><span class="line">  ......</span><br><span class="line">  gvks, ok := s.typeToGVK[t]</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> gvks, unversionedType, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ObjectKinds()</code>方法是根据一个对象的类型去 <code>typeToGVK</code> 中找它对应的GVK，返回的是一个GVK列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheme)</span></span> New(kind schema.GroupVersionKind) (Object, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> t, exists := s.gvkToType[kind]; exists &#123;</span><br><span class="line">    <span class="keyword">return</span> reflect.New(t).Interface().(Object), <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>New()</code>方法则是根据一个GVK去 <code>gvkToType</code> 中找到它对应的Type，然后通过 <code>reflect.New()</code> 方法去实例化一个它的对象。</p>
<p>所以各个版本的API资源，都会将自己的GVK和Type通过 <code>AddKnownTypes()</code> 注册到Scheme中，后续可以通过 <code>ObjectKinds()</code> 、<code>New()</code> 等方法去使用它们。我们还是以 <code>FlowSchema</code> 为例，来看看各个API资源是怎么注册其类型的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/api/flowcontrol/v1beta2/register.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GroupName is the name of api group</span></span><br><span class="line"><span class="keyword">const</span> GroupName = <span class="string">&quot;flowcontrol.apiserver.k8s.io&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SchemeGroupVersion is group version used to register these objects</span></span><br><span class="line"><span class="keyword">var</span> SchemeGroupVersion = schema.GroupVersion&#123;Group: GroupName, Version: <span class="string">&quot;v1beta2&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// SchemeBuilder installs the api group to a scheme</span></span><br><span class="line">  SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)</span><br><span class="line">  <span class="comment">// AddToScheme adds api to a scheme</span></span><br><span class="line">  AddToScheme = SchemeBuilder.AddToScheme</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adds the list of known types to the given scheme.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addKnownTypes</span><span class="params">(scheme *runtime.Scheme)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  scheme.AddKnownTypes(SchemeGroupVersion,</span><br><span class="line">    &amp;FlowSchema&#123;&#125;,</span><br><span class="line">    &amp;FlowSchemaList&#123;&#125;,</span><br><span class="line">    &amp;PriorityLevelConfiguration&#123;&#125;,</span><br><span class="line">    &amp;PriorityLevelConfigurationList&#123;&#125;,</span><br><span class="line">  )</span><br><span class="line">  metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要关注下 <code>addKnownTypes()</code>方法即可，注意它的参数，是一个指针类型的 <code>scheme</code>，前面我们讲过，APIServer全局只有一个Scheme，这里即引用的全局的Scheme实例的指针，将本版本的API资源类型注册到Scheme中。这里展示的v1beta2版本的，v1beta3还有内部版本，都是类似的，他们的对应目录下都有一个 <code>register.go</code> 用来向Scheme中注册本版本的API资源类型。</p>
<h2 id="类型转换方法注册"><a href="#类型转换方法注册" class="headerlink" title="类型转换方法注册"></a>类型转换方法注册</h2><p>如前所述，Scheme还有一个重要功能，就是可以将不同版本的API对象进行互相转换，这个转换是在 <code>内部版本</code> 和 <code>外部版本</code> 之间进行的，所以各个API资源都将<strong>外部版本的API资源类型</strong>如何跟<strong>内部版本类型</strong>进行转换的方法注册到Scheme中，即上面类图中的<code>converer *convertion.Converter</code>属性, 在Converter内部维护了一个map，key是以<code>[source, dest]</code>为组合的一对儿<code>relect.Type</code>，value则是类型转换方法，即给定了一对儿类型，就可以找到一个怎么从源类型转换到目的类型的方法。</p>
<p>Scheme提供了以下两个方法进行类型转换方法的注册：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheme)</span></span> AddConversionFunc(a, b <span class="keyword">interface</span>&#123;&#125;, fn conversion.ConversionFunc) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.converter.RegisterUntypedConversionFunc(a, b, fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheme)</span></span> AddGeneratedConversionFunc(a, b <span class="keyword">interface</span>&#123;&#125;, fn conversion.ConversionFunc) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.converter.RegisterGeneratedUntypedConversionFunc(a, b, fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后提供了 <code>Convert()</code>、<code>ConvertToVersion()</code>、<code>UnsafeConvertToVersion()</code>等方法调用注册进来的类型转换方法对某一对儿特定的类型进行转换。那问题来了，这类型到底是怎么转换的呢？我们还是来看个示例，还是以 <code>FlowSchema</code> 为例，来看看它的类型转换方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kubernetes/pkg/apis/flowcontrol/v1beta2/zz_generated.conversion.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterConversions</span><span class="params">(s *runtime.Scheme)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">if</span> err := s.AddGeneratedConversionFunc((*v1beta2.FlowSchema)(<span class="literal">nil</span>), (*flowcontrol.FlowSchema)(<span class="literal">nil</span>), <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;, scope conversion.Scope)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Convert_v1beta2_FlowSchema_To_flowcontrol_FlowSchema(a.(*v1beta2.FlowSchema), b.(*flowcontrol.FlowSchema), scope)</span><br><span class="line">  &#125;)</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">if</span> err := s.AddGeneratedConversionFunc((*flowcontrol.FlowSchema)(<span class="literal">nil</span>), (*v1beta2.FlowSchema)(<span class="literal">nil</span>), <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;, scope conversion.Scope)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Convert_flowcontrol_FlowSchema_To_v1beta2_FlowSchema(a.(*flowcontrol.FlowSchema), b.(*v1beta2.FlowSchema), scope)</span><br><span class="line">  &#125;)</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里也是引用的Scheme的指针，通过调用scheme的 <code>AddGeneratedConversionFunc()</code> 方法，注册了两个类型转换方法，即 <code>v1beta2.FlowSchema</code> 这个外部版本的类型与 <code>flowcontrol.FlowSchema</code> 这个内部版本的类型之间的互相转换，而跟踪到最后，发现其实这个类型转换方法就是很简单的两个对象之间属性的赋值，就是把源类型对象的属性值取出来，赋值给目的类型对象的对应属性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kubernetes/pkg/apis/flowcontrol/v1beta2/zz_generated.conversion.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">autoConvert_v1beta2_FlowSchema_To_flowcontrol_FlowSchema</span><span class="params">(in *v1beta2.FlowSchema, out *flowcontrol.FlowSchema, s conversion.Scope)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  out.ObjectMeta = in.ObjectMeta</span><br><span class="line">  <span class="keyword">if</span> err := Convert_v1beta2_FlowSchemaSpec_To_flowcontrol_FlowSchemaSpec(&amp;in.Spec, &amp;out.Spec, s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := Convert_v1beta2_FlowSchemaStatus_To_flowcontrol_FlowSchemaStatus(&amp;in.Status, &amp;out.Status, s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">autoConvert_v1beta2_FlowSchemaSpec_To_flowcontrol_FlowSchemaSpec</span><span class="params">(in *v1beta2.FlowSchemaSpec, out *flowcontrol.FlowSchemaSpec, s conversion.Scope)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := Convert_v1beta2_PriorityLevelConfigurationReference_To_flowcontrol_PriorityLevelConfigurationReference(&amp;in.PriorityLevelConfiguration, &amp;out.PriorityLevelConfiguration, s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  out.MatchingPrecedence = in.MatchingPrecedence</span><br><span class="line">  out.DistinguisherMethod = (*flowcontrol.FlowDistinguisherMethod)(unsafe.Pointer(in.DistinguisherMethod))</span><br><span class="line">  out.Rules = *(*[]flowcontrol.PolicyRulesWithSubjects)(unsafe.Pointer(&amp;in.Rules))</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">autoConvert_v1beta2_FlowSchemaStatus_To_flowcontrol_FlowSchemaStatus</span><span class="params">(in *v1beta2.FlowSchemaStatus, out *flowcontrol.FlowSchemaStatus, s conversion.Scope)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  out.Conditions = *(*[]flowcontrol.FlowSchemaCondition)(unsafe.Pointer(&amp;in.Conditions))</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些转换方法都位于 <code>zz_generated.conversion.go</code> 这个文件中，这个文件及其内容都是根据types.go中的类型定义自动生成的，因为这种类型转换的逻辑很简单，但是代码量又大，完全可以让它自动生成。但是如前文所说，现在Kubernetes的API都趋于稳定了，beta版和稳定版之间几乎没有差异，所以外部版本跟内部版本之间的转换就是很简单的属性赋值，但是如果内外版本的属性有不一致的情况，在转换时还是要特殊处理下的，可能会忽略掉某些属性，或者是把某些属性放到别的字段去，这种特殊的情况，就需要开发者来特别指定，而不能自动生成了，比如跟 <code>FlowSchema</code> 在同一个组中的 <code>LimitedPriorityLevelConfiguration</code> 资源就有这种情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/api/flowcontrol/v1beta2/types.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LimitedPriorityLevelConfiguration <span class="keyword">struct</span> &#123;</span><br><span class="line">  AssuredConcurrencyShares <span class="type">int32</span> <span class="string">`json:&quot;assuredConcurrencyShares&quot; protobuf:&quot;varint,1,opt,name=assuredConcurrencyShares&quot;`</span></span><br><span class="line">  LimitResponse LimitResponse <span class="string">`json:&quot;limitResponse,omitempty&quot; protobuf:&quot;bytes,2,opt,name=limitResponse&quot;`</span></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/api/flowcontrol/v1beta3/types.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LimitedPriorityLevelConfiguration <span class="keyword">struct</span> &#123;</span><br><span class="line">  NominalConcurrencyShares <span class="type">int32</span> <span class="string">`json:&quot;nominalConcurrencyShares&quot; protobuf:&quot;varint,1,opt,name=nominalConcurrencyShares&quot;`</span></span><br><span class="line">  LimitResponse LimitResponse <span class="string">`json:&quot;limitResponse,omitempty&quot; protobuf:&quot;bytes,2,opt,name=limitResponse&quot;`</span></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>v1beta2和v1beta3的字段名发生了改变，从v1beta2中的 <code>AssuredConcurrencyShares</code> 改成了 v1beta3中的 <code>NominalConcurrencyShares</code>，那这种情况，内部版本是什么样的呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kubernets/pkg/apis/flowcontrol/types.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LimitedPriorityLevelConfiguration <span class="keyword">struct</span> &#123;</span><br><span class="line">  NominalConcurrencyShares <span class="type">int32</span></span><br><span class="line">  LimitResponse LimitResponse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到内部版本，其实是跟v1beta3版本的字段保持一致的，即是跟最新版本的类型保持一致的。那这种情况的类型该怎么转换呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// kubernetes/pkg/apis/flowcontrol/v1beta2/conversion.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Convert_v1beta2_LimitedPriorityLevelConfiguration_To_flowcontrol_LimitedPriorityLevelConfiguration</span><span class="params">(in *v1beta2.LimitedPriorityLevelConfiguration, out *flowcontrol.LimitedPriorityLevelConfiguration, s conversion.Scope)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := autoConvert_v1beta2_LimitedPriorityLevelConfiguration_To_flowcontrol_LimitedPriorityLevelConfiguration(in, out, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  out.NominalConcurrencyShares = in.AssuredConcurrencyShares</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Convert_flowcontrol_LimitedPriorityLevelConfiguration_To_v1beta2_LimitedPriorityLevelConfiguration</span><span class="params">(in *flowcontrol.LimitedPriorityLevelConfiguration, out *v1beta2.LimitedPriorityLevelConfiguration, s conversion.Scope)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := autoConvert_flowcontrol_LimitedPriorityLevelConfiguration_To_v1beta2_LimitedPriorityLevelConfiguration(in, out, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  out.AssuredConcurrencyShares = in.NominalConcurrencyShares</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在v1beta2目录中，单独定义了一个conversion.go，它定义了两个方法指定了内部版本和外部版本进行转换时，这两个属性该怎么去处理，就是简单的把两个值互相赋值下，而这两个方法又会被 <code>zz_generated.conversion.go</code> 中的转换方法所引用。而v1beta3的外部版本跟内部版本字段是一样的，所以是不需要额外做转换的工作的，所以可以看到v1beta3目录中，并没有convertion.go文件。</p>
<h2 id="版本优先级注册"><a href="#版本优先级注册" class="headerlink" title="版本优先级注册"></a>版本优先级注册</h2><p>Scheme中还有一个比较重要的点，就是版本优先级，一个组中可能会有很多个版本，开发者期望用户使用什么版本，以及期望某个API对象存储到数据库时，使用哪个版本的数据结构，都是通过这个版本优先级来确定的。在Scheme中，<code>versionPriority</code> 这个map就是用来存储某个组的版本优先级的，可以看到value是一个<code>[]string</code>，即某个组有几个版本都以字符串的形式存放到这个value中，而且优先级越高的，越在前面，即排在第一位的，就是版本优先级最高的。</p>
<p>比如 <code>flowcontrol</code> API组就通过scheme的 <code>SetVersionPriority()</code> 方法注册进去 v1beta3, v1beta2, v1beta1, v1alpha1 四个版本，而排在第一位的v1beta3是优先级最高的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kubernetes/pkg/apis/flowcontrol/install/install.go</span></span><br><span class="line"></span><br><span class="line">scheme.SetVersionPriority(flowcontrolv1beta3.SchemeGroupVersion, flowcontrolv1beta2.SchemeGroupVersion,</span><br><span class="line">    flowcontrolv1beta1.SchemeGroupVersion, flowcontrolv1alpha1.SchemeGroupVersion)</span><br></pre></td></tr></table></figure>

<p>然后可以通过 <code>PrioritizedVersionsForGroup()</code> 方法去获取某个组的所有版本优先级，比如在API自动发现时，当用户请求某个组的根路径时，会返回该组支持的所有版本，并且有个 <code>preferredVersion</code> 字段，告诉用户建议使用哪个版本，如下例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># curl http<span class="punctuation">:</span><span class="comment">//127.0.0.1:8001/apis/flowcontrol.apiserver.k8s.io/</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;APIGroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;apiVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;flowcontrol.apiserver.k8s.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;versions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;groupVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;flowcontrol.apiserver.k8s.io/v1beta3&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v1beta3&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;groupVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;flowcontrol.apiserver.k8s.io/v1beta2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v1beta2&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;preferredVersion&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;groupVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;flowcontrol.apiserver.k8s.io/v1beta3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v1beta3&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>perferredVersion</code> 显示为 v1beta3，就是由上面设置的版本优先级来决定的。此外，还有当存储某个对象时，需要获取到该类资源所在组的最高优先级的版本，去存储该版本的数据结构，也是通过 <code>PrioritizedVersionsForGroup()</code> 这个方法来获取的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apiserver/pkg/server/storage/resource_encoding_config.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *DefaultResourceEncodingConfig)</span></span> StorageEncodingFor(resource schema.GroupResource) (schema.GroupVersion, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> !o.scheme.IsGroupRegistered(resource.Group) &#123;</span><br><span class="line">    <span class="keyword">return</span> schema.GroupVersion&#123;&#125;, fmt.Errorf(<span class="string">&quot;group %q is not registered in scheme&quot;</span>, resource.Group)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resourceOverride, resourceExists := o.resources[resource]</span><br><span class="line">  <span class="keyword">if</span> resourceExists &#123;</span><br><span class="line">    <span class="keyword">return</span> resourceOverride.ExternalResourceEncoding, <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return the most preferred external version for the group</span></span><br><span class="line">  <span class="keyword">return</span> o.scheme.PrioritizedVersionsForGroup(resource.Group)[<span class="number">0</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，以上就是Scheme的核心内容了，基本上Scheme实现的几个接口：<code>ObjectTyper</code>, <code>ObjectCreater</code>, <code>ObjectConvertor</code>，我们都有介绍过了，还有一个 <code>ObjectDefaulter</code> 是用来设置默认值的，此处不太重要，略去不提。</p>
<p>最后，我们还是以 <code>FlowControl</code> 为例，结合它的代码目录树结构，来整体回顾下：</p>
<p><code>// kubernetes/pkg/apis/flowcontrol</code></p>
<p><img src="/assets/kubernetes_versioning_flowcontrol_internal.png"></p>
<p><code>// k8s.io/api/flowcontrol</code></p>
<p><img src="/assets/kubernetes_versioning_flowcontrol_external.png"></p>
<p>曾经有很长一段时间lost在这个代码目录中，看着这些版本还有代码，不知道他们是干什么的，为什么有的在这，有的在那？为什么会有一些<code>zz_</code>开头的文件？为什么 <code>types.go</code> 在好几个地方都定义了？现在终于搞清楚了，我们就结合这个目录树的结构，来对上面介绍的Scheme内容进行一次简单的回顾总结：</p>
<ul>
<li>首先就是API资源类型有多版本的，而且分内部版本和外部版本的，外部版本定义在 <code>k8s.io/api</code> 这个第三方库中，而内部版本定义在 <code>kubernetes/pkg/apis</code> 本身的代码目录树中；</li>
<li>每个版本中都有一个 <code>types.go</code> 文件，它定义了各个版的API资源类型，需要注意内部版本的类型是直接位于<code>flowcontrol/</code>目录下的，并没有一个 <code>internal/</code> 这样一个目录结构；</li>
<li>跟 <code>types.go</code> 在一起的，还有个 <code>register.go</code>，就是用来向Scheme中注册本版本的资源类型的；</li>
<li><code>zz_generated.deepcopy.go</code>中定义了内部版本的API资源类型的深拷贝方法，即安全的拷贝一个对象，在进行类型转换等地方会用到；</li>
<li>在 <code>kubernetes/pkg/apis/flowcontrol/</code> 目录下除了有内部版本的类型定义之外，还分了很多版本目录，里面定义了各个版本跟内部版本如何进行转换的方法以及本版本的默认值方法，以 <code>kubernetes/pkg/apis/flowcontrol/v1beta2</code> 目录下文件为例，介绍下各个文件的作用：<ul>
<li><code>zz_generated.conversion.go</code> 是根据types.go自动生成的内部版本与本版本的类型的转换方法，这里面还包含了向 scheme 中注册类型转换方法的入口；</li>
<li><code>conversion.go</code> 是针对特殊的字段由开发者编写的类型转换方法；</li>
<li><code>zz_generated.defaults.go</code> 是自动生成的默认值方法；</li>
<li><code>defaults.go</code> 是针对特殊字段单独设置的默认值方法；</li>
<li><code>register.go</code> 是用来向scheme中注册默认值方法的；</li>
</ul>
</li>
<li>再来以 <code>k8s.io/api/flowcontrol/v1beta2/</code> 目录下的文件为例，介绍下各个文件的作用：<ul>
<li><code>types.go</code> 定义了外部版本的API资源类型；</li>
<li><code>register.go</code> 是向scheme中注册本版本的API资源类型；</li>
<li><code>generated.proto</code> 是根据类型自动生成的 protobuf 的定义文件；</li>
<li><code>generated.pb.go</code> 则是根据 <code>generated.proto</code> 定义文件自动生成的对应的go代码，当客户端跟kubernetes api走gRPC通信时，就使用protobuf格式的数据，就会用到这里的代码；</li>
<li><code>zz_generated.deepcopy.go</code> 则是定义的本版本的API资源类型的深拷贝方法；</li>
</ul>
</li>
</ul>
<p>在 <code>kubernetes/pkg/apis/flowcontrol/install</code> 目录下还有个 install.go 文件，它里面就是类型注册，以及版本优先级注册的入口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  Install(legacyscheme.Scheme)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Install registers the API group and adds types to a scheme</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Install</span><span class="params">(scheme *runtime.Scheme)</span></span> &#123;</span><br><span class="line">  utilruntime.Must(flowcontrol.AddToScheme(scheme))</span><br><span class="line">  utilruntime.Must(flowcontrolv1alpha1.AddToScheme(scheme))</span><br><span class="line">  utilruntime.Must(flowcontrolv1beta1.AddToScheme(scheme))</span><br><span class="line">  utilruntime.Must(flowcontrolv1beta2.AddToScheme(scheme))</span><br><span class="line">  utilruntime.Must(flowcontrolv1beta3.AddToScheme(scheme))</span><br><span class="line">  utilruntime.Must(scheme.SetVersionPriority(flowcontrolv1beta3.SchemeGroupVersion, flowcontrolv1beta2.SchemeGroupVersion,</span><br><span class="line">    flowcontrolv1beta1.SchemeGroupVersion, flowcontrolv1alpha1.SchemeGroupVersion))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>init()</code> 方法，即在启动时，就会向scheme中去注册各种版本的API资源类型，以及设置版本优先级。</p>
<p>OK，说了这么多，那Scheme到底在哪呢？前面说的都是引用它的指针，最后有请我们的主角隆重登场：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kubernetes/pkg/api/legacyscheme/scheme.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// Scheme is the default instance of runtime.Scheme to which types in the Kubernetes API are already registered.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> If you are copying this file to start a new api group, STOP! Copy the</span></span><br><span class="line">  <span class="comment">// extensions group instead. This Scheme is special and should appear ONLY in</span></span><br><span class="line">  <span class="comment">// the api group, unless you really know what you&#x27;re doing.</span></span><br><span class="line">  <span class="comment">// TODO(lavalamp): make the above error impossible.</span></span><br><span class="line">  Scheme = runtime.NewScheme()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Codecs provides access to encoding and decoding for the scheme</span></span><br><span class="line">  Codecs = serializer.NewCodecFactory(Scheme)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ParameterCodec handles versioning of objects that are converted to query parameters.</span></span><br><span class="line">  ParameterCodec = runtime.NewParameterCodec(Scheme)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章从源码角度介绍了下Scheme的功能作用以及实现机制，由于Scheme比较抽象，想解释比较抽象的东西，最好的办法就是通过举例去解释它，所以本篇文章通过举例的方式，介绍了什么是类型，类型是如何注册的，类型转换方法是如何注册的，以及版本优先级的注册，基本上把Scheme最核心的功能分析了下，然后结合分析，介绍了下在开发中经常遇到的各个文件的作用。</p>
<p>通过这些系列分析文章，我觉得Kubernetes的代码写的还是相当不错的，尤其是真的做到了 <code>Do not repeat your self</code>，基本上把所有共性的逻辑都抽象出来作为公共逻辑，每个API资源，只需要实现自己相关的代码就可以了，因此，开发一个新的API变得比较简单，不需要你去实现数据库的增删查改逻辑，也不需要去关心如何进行序列化，也不用关心如何向APIServer中注册Handler，只需要定义好各个版本的数据结构，即Kubernetes中所说的类型(Type)，以及各个版本跟内部版本之间如何进行转换的逻辑，然后创建好该API相关的<code>REST Store</code>，再用工具自动生成一些必要的代码，最终注册到相应的地方即可，相比很多应用开发一个新的API，需要从前到后，添加很多耦合代码来说，Kubernetes做的真的不错。</p>
<p>当然了，这种抽象，带来的一个问题，就是复杂性增加了好几个维度，尤其是Golang的，这种看似无面向对象实际又有面向对象的机制，你定义了一个接口，没法直观的判断谁实现了这些接口，也没法直观的看出来一个结构体实现了哪些接口，不像Java，C++，Python这种面向对象的语言那样清晰，Golang比较隐晦。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Kubernetes API Scheme 解析</p><p><a href="https://hackerain.me/2023/11/11/kubernetes/kube-versioning-scheme.html">https://hackerain.me/2023/11/11/kubernetes/kube-versioning-scheme.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>hackerain</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-11-11</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-11-12</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/kubernetes/">kubernetes</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/11/12/kubernetes/kube-versioning-codec.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Kubernetes API Codec 解析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/10/28/kubernetes/kube-versioning.html"><span class="level-item">Kubernetes API 多版本和序列化</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/assets/avatar.jpg" alt="开心BOY"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">开心BOY</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">44</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="/about" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/hackerain"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="知识星球" href="https://t.zsxq.com/0bWmBFDpu"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#概述"><span class="level-left"><span class="level-item">1</span><span class="level-item">概述</span></span></a></li><li><a class="level is-mobile" href="#什么是类型"><span class="level-left"><span class="level-item">2</span><span class="level-item">什么是类型</span></span></a></li><li><a class="level is-mobile" href="#类型注册"><span class="level-left"><span class="level-item">3</span><span class="level-item">类型注册</span></span></a></li><li><a class="level is-mobile" href="#类型转换方法注册"><span class="level-left"><span class="level-item">4</span><span class="level-item">类型转换方法注册</span></span></a></li><li><a class="level is-mobile" href="#版本优先级注册"><span class="level-left"><span class="level-item">5</span><span class="level-item">版本优先级注册</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">6</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-12T00:00:00.000Z">2023-11-12</time></p><p class="title"><a href="/2023/11/12/kubernetes/kube-versioning-codec.html">Kubernetes API Codec 解析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-11T00:00:00.000Z">2023-11-11</time></p><p class="title"><a href="/2023/11/11/kubernetes/kube-versioning-scheme.html">Kubernetes API Scheme 解析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-28T00:00:00.000Z">2023-10-28</time></p><p class="title"><a href="/2023/10/28/kubernetes/kube-versioning.html">Kubernetes API 多版本和序列化</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-26T00:00:00.000Z">2022-09-26</time></p><p class="title"><a href="/2022/09/26/elasticsearch/elasticsearch_large_text_field.html">Elasticsearch大文本字段(large text field)优化方案</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-08-07T10:52:55.000Z">2022-08-07</time></p><p class="title"><a href="/2022/08/07/umi/umi.html">UMI框架解析</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/"><span class="level-start"><span class="level-item">2017</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ceph/"><span class="tag">ceph</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/elasticsearch/"><span class="tag">elasticsearch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kubernetes/"><span class="tag">kubernetes</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/openstack/"><span class="tag">openstack</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/operations/"><span class="tag">operations</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/umi/"><span class="tag">umi</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/assets/logo.jpg" alt="开心BOY" height="28"></a><p class="is-size-7"><span>&copy; 2023 hackerain</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hackerain"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
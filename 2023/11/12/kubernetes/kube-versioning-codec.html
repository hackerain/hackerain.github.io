<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Kubernetes API Codec 解析 - 开心BOY</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="开心BOY"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="开心BOY"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="概述在 Kubernetes API 多版本和序列化 这篇文章中，介绍了API多版本的功能和实现原理，其中Codec就是用来做序列化工作的，它主要用在两个地方：一个是通过HTTP协议跟客户端进行交互时，会对传输的数据进行序列化和反序列化，将字节流类型的数据转换成对应的API对象，或者是将API对象转换成对应格式的数据返回给客户端；一个是用在存储层的，即API对象存储到数据库时，也需要经过编码的，即"><meta property="og:type" content="blog"><meta property="og:title" content="Kubernetes API Codec 解析"><meta property="og:url" content="https://hackerain.me/2023/11/12/kubernetes/kube-versioning-codec.html"><meta property="og:site_name" content="开心BOY"><meta property="og:description" content="概述在 Kubernetes API 多版本和序列化 这篇文章中，介绍了API多版本的功能和实现原理，其中Codec就是用来做序列化工作的，它主要用在两个地方：一个是通过HTTP协议跟客户端进行交互时，会对传输的数据进行序列化和反序列化，将字节流类型的数据转换成对应的API对象，或者是将API对象转换成对应格式的数据返回给客户端；一个是用在存储层的，即API对象存储到数据库时，也需要经过编码的，即"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hackerain.me/assets/kubernetes_versioning_codec_serializer.drawio.png"><meta property="og:image" content="https://hackerain.me/assets/kubernetes_versioning_codec.drawio.png"><meta property="og:image" content="https://hackerain.me/assets/kubernetes_versioning_groupversioner.png"><meta property="article:published_time" content="2023-11-12T00:00:00.000Z"><meta property="article:modified_time" content="2023-11-12T11:00:19.131Z"><meta property="article:author" content="hackerain"><meta property="article:tag" content="kubernetes"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hackerain.me/assets/kubernetes_versioning_codec_serializer.drawio.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hackerain.me/2023/11/12/kubernetes/kube-versioning-codec.html"},"headline":"Kubernetes API Codec 解析","image":["https://hackerain.me/assets/kubernetes_versioning_codec_serializer.drawio.png","https://hackerain.me/assets/kubernetes_versioning_codec.drawio.png","https://hackerain.me/assets/kubernetes_versioning_groupversioner.png"],"datePublished":"2023-11-12T00:00:00.000Z","dateModified":"2023-11-12T11:00:19.131Z","author":{"@type":"Person","name":"hackerain"},"publisher":{"@type":"Organization","name":"开心BOY","logo":{"@type":"ImageObject","url":"https://hackerain.me/assets/logo.jpg"}},"description":"概述在 Kubernetes API 多版本和序列化 这篇文章中，介绍了API多版本的功能和实现原理，其中Codec就是用来做序列化工作的，它主要用在两个地方：一个是通过HTTP协议跟客户端进行交互时，会对传输的数据进行序列化和反序列化，将字节流类型的数据转换成对应的API对象，或者是将API对象转换成对应格式的数据返回给客户端；一个是用在存储层的，即API对象存储到数据库时，也需要经过编码的，即"}</script><link rel="canonical" href="https://hackerain.me/2023/11/12/kubernetes/kube-versioning-codec.html"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="开心BOY" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/assets/logo.jpg" alt="开心BOY" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-12T00:00:00.000Z" title="11/12/2023, 12:00:00 AM">2023-11-12</time>发表</span><span class="level-item"><time dateTime="2023-11-12T11:00:19.131Z" title="11/12/2023, 11:00:19 AM">2023-11-12</time>更新</span><span class="level-item">32 分钟读完 (大约4802个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Kubernetes API Codec 解析</h1><div class="content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 <a target="_blank" rel="noopener" href="https://hackerain.github.io/2023/10/28/kubernetes/kube-versioning.html">Kubernetes API 多版本和序列化</a> 这篇文章中，介绍了API多版本的功能和实现原理，其中Codec就是用来做序列化工作的，它主要用在两个地方：一个是通过HTTP协议跟客户端进行交互时，会对传输的数据进行序列化和反序列化，将字节流类型的数据转换成对应的API对象，或者是将API对象转换成对应格式的数据返回给客户端；一个是用在存储层的，即API对象存储到数据库时，也需要经过编码的，即经过序列化，默认是存储成 protobuf格式的数据，然后从数据库读出来数据时，又会反序列化为对应的API对象，下面我们来分析下Codec的实现机制。</p>
<span id="more"></span>

<h2 id="Serializer"><a href="#Serializer" class="headerlink" title="Serializer"></a>Serializer</h2><p>Serializer即是将API对象以某种数据格式进行序列化和反序列化，目前支持的数据格式有三种：json, yaml, protobuf，我们先来看看相关的接口定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apimachinery/pkg/runtime/interfaces.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Encoder writes objects to a serialized form</span></span><br><span class="line"><span class="keyword">type</span> Encoder <span class="keyword">interface</span> &#123;</span><br><span class="line">  Encode(obj Object, w io.Writer) <span class="type">error</span></span><br><span class="line">  Identifier() Identifier</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decoder attempts to load an object from data.</span></span><br><span class="line"><span class="keyword">type</span> Decoder <span class="keyword">interface</span> &#123;</span><br><span class="line">  Decode(data []<span class="type">byte</span>, defaults *schema.GroupVersionKind, into Object) (Object, *schema.GroupVersionKind, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serializer is the core interface for transforming objects into a serialized format and back.</span></span><br><span class="line"><span class="keyword">type</span> Serializer <span class="keyword">interface</span> &#123;</span><br><span class="line">  Encoder</span><br><span class="line">  Decoder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Codec is a Serializer that deals with the details of versioning objects. It offers the same</span></span><br><span class="line"><span class="comment">// interface as Serializer, so this is a marker to consumers that care about the version of the objects</span></span><br><span class="line"><span class="comment">// they receive.</span></span><br><span class="line"><span class="keyword">type</span> Codec Serializer</span><br></pre></td></tr></table></figure>

<p>Encoder接口中定义的<code>Encode()</code>方法是要将一个API对象以某种格式编码到输出中，而Decoder接口中定义的<code>Decode()</code>方法则是将字节类型的数据解码成某个版本的API对象，这两个编码解码的接口组合起来形成一个新的接口，叫<code>Serializer</code>，同时也叫 <code>Codec</code>。</p>
<p>目前 Kubernetes 中有三种数据格式的Serializer，均实现了上面的接口，分别为json, yaml和protobuf，来看下他们的类图：</p>
<p><img src="/assets/kubernetes_versioning_codec_serializer.drawio.png"></p>
<p>这几个Serializer定义在 <code>k8s.io/apimachinery/pkg/runtime/serializer/</code> 目录下，分别实现了Json, Yaml和Protobuf数据格式的编码和解码操作，需要注意的是没有专门的Yaml Serializer的实现，因为Json跟Yaml的转换很容易，所以直接使用Json Serializer去实现了Yaml Serializer，具体json和protobuf是如何进行Encode和Decode的，这里我们不展开，这里只需要知道这几个Serializer的作用，做了什么事情即可。</p>
<h2 id="CodecFactory"><a href="#CodecFactory" class="headerlink" title="CodecFactory"></a>CodecFactory</h2><p>上面的接口中，为什么要再定义一个跟Serializer同名的接口Codec呢？Codec的注释有这么一句话，说明了它的作用：</p>
<blockquote>
<p>Codec is a Serializer that deals with the details of versioning objects. </p>
</blockquote>
<p>即Codec是专门用来处理多版本的API对象的序列化的，它除了需要做API对象的序列化操作之外，还需要做版本转换的操作，而上面介绍到的json/yaml/protobuf Serializer相对偏底层，只是做某个版本对象的序列化操作，Codec会引用Serializer做具体的序列化，然后再做版本转换。Codec既然跟对象版本有关，那肯定不同版本的API资源就要有不同的Codec了，所以我们就需要有个生产Codec的工厂类，即CodecFactory：</p>
<p><img src="/assets/kubernetes_versioning_codec.drawio.png"></p>
<p>可以看到它实现了两个接口，<code>NegotiatedSerializer</code> 和 <code>StorageSerializer</code>，正好对应了本小节开头提到的Codec的两个作用：一个作用于HTTP，用来跟客户端交互，一个作用于存储，用来跟数据库交互，其中的 <code>EncoderForVersion()</code> 和 <code>DecoderToVersion()</code> 就是用来生产Codec的方法，来看看相关代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apimachinery/pkg/runtime/serializer/codec_factory.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCodecFactory</span><span class="params">(scheme *runtime.Scheme, mutators ...CodecFactoryOptionsMutator)</span></span> CodecFactory &#123;</span><br><span class="line">  options := CodecFactoryOptions&#123;Pretty: <span class="literal">true</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> _, fn := <span class="keyword">range</span> mutators &#123;</span><br><span class="line">    fn(&amp;options)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建了 json/yaml/protobuf 三种serializer</span></span><br><span class="line">  serializers := newSerializersForScheme(scheme, json.DefaultMetaFactory, options)</span><br><span class="line">  <span class="keyword">return</span> newCodecFactory(scheme, serializers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCodecFactory</span><span class="params">(scheme *runtime.Scheme, serializers []serializerType)</span></span> CodecFactory &#123;</span><br><span class="line">  decoders := <span class="built_in">make</span>([]runtime.Decoder, <span class="number">0</span>, <span class="built_in">len</span>(serializers))</span><br><span class="line">  <span class="keyword">var</span> accepts []runtime.SerializerInfo</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> legacySerializer runtime.Serializer</span><br><span class="line">  <span class="keyword">for</span> _, d := <span class="keyword">range</span> serializers &#123;</span><br><span class="line">    decoders = <span class="built_in">append</span>(decoders, d.Serializer)</span><br><span class="line">    <span class="keyword">for</span> _, mediaType := <span class="keyword">range</span> d.AcceptContentTypes &#123;</span><br><span class="line">      ......</span><br><span class="line">      info := runtime.SerializerInfo&#123;</span><br><span class="line">        MediaType:        d.ContentType,</span><br><span class="line">        EncodesAsText:    d.EncodesAsText,</span><br><span class="line">        Serializer:       d.Serializer,</span><br><span class="line">        PrettySerializer: d.PrettySerializer,</span><br><span class="line">        StrictSerializer: d.StrictSerializer,</span><br><span class="line">      &#125;</span><br><span class="line">      ......</span><br><span class="line">      accepts = <span class="built_in">append</span>(accepts, info)</span><br><span class="line">      <span class="keyword">if</span> mediaType == runtime.ContentTypeJSON &#123;</span><br><span class="line">        legacySerializer = d.Serializer</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> CodecFactory&#123;</span><br><span class="line">    scheme:    scheme,</span><br><span class="line">    universal: recognizer.NewDecoder(decoders...),</span><br><span class="line"></span><br><span class="line">    accepts: accepts,</span><br><span class="line"></span><br><span class="line">    legacySerializer: legacySerializer,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码显示了CodecFactory是如何创建出来的，比较重要的是 <code>serializers := newSerializersForScheme(scheme, json.DefaultMetaFactory, options)</code> 这行代码，这是去创建 json/yaml/protobuf 三种Serializer，然后在 <code>newCodecFactory()</code> 方法中将他们转成了 <code>SerializerInfo</code> 对象，最终将他们放到了CodecFactory的 <code>accepts</code> 属性中。还有个<code>universal</code> 属性，是把三种Serializer放到了一个列表里，然后组成了一个统一的decoder，即它可以解析三种格式的数据。</p>
<p>再来看看CodecFactory生产Codec的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apimachinery/pkg/runtime/serializer/codec_factory.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f CodecFactory)</span></span> CodecForVersions(encoder runtime.Encoder, decoder runtime.Decoder, encode runtime.GroupVersioner, decode runtime.GroupVersioner) runtime.Codec &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> these are for backcompat, remove them in the future</span></span><br><span class="line">  <span class="keyword">if</span> encode == <span class="literal">nil</span> &#123;</span><br><span class="line">    encode = runtime.DisabledGroupVersioner</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> decode == <span class="literal">nil</span> &#123;</span><br><span class="line">    decode = runtime.InternalGroupVersioner</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> versioning.NewDefaultingCodecForScheme(f.scheme, encoder, decoder, encode, decode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DecoderToVersion returns a decoder that targets the provided group version.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f CodecFactory)</span></span> DecoderToVersion(decoder runtime.Decoder, gv runtime.GroupVersioner) runtime.Decoder &#123;</span><br><span class="line">  <span class="keyword">return</span> f.CodecForVersions(<span class="literal">nil</span>, decoder, <span class="literal">nil</span>, gv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EncoderForVersion returns an encoder that targets the provided group version.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f CodecFactory)</span></span> EncoderForVersion(encoder runtime.Encoder, gv runtime.GroupVersioner) runtime.Encoder &#123;</span><br><span class="line">  <span class="keyword">return</span> f.CodecForVersions(encoder, <span class="literal">nil</span>, gv, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几个函数接收的参数，都是接口类型的，Encoder和Decoder上面我们介绍过了，是用来做具体的数据格式序列化的，还有个GroupVersioner来看下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apimachinery/pkg/runtime/interfaces.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupVersioner <span class="keyword">interface</span> &#123;</span><br><span class="line">  KindForGroupVersionKinds(kinds []schema.GroupVersionKind) (target schema.GroupVersionKind, ok <span class="type">bool</span>)</span><br><span class="line">  Identifier() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而实现了该接口的是一个叫 <code>multiGroupVersioner</code> 的结构体，位于 <code>k8s.io/apimachinery/pkg/runtime/codec.go</code>：</p>
<p><img src="/assets/kubernetes_versioning_groupversioner.png"></p>
<p>这个<code>multiGroupVersioner</code>的作用是什么呢？可以看看它里面的属性，有一个<code>GroupVersion</code>类型的<code>target</code>，然后有一个<code>[]GroupKind</code>类型的<code>accetedGroupKinds</code>，然后 <code>KindForGroupVersionKinds()</code> 方法的作用就是，当接收一个GVK列表时，看它们的GroupKind哪一个在acceptGroupKinds里，然后就会把它的Kind取出来，跟target组成一个新的GVK返回，即期望输出的Group和Version是固定的，就是target所指定的，只需要找到匹配的Kind即可，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target=mygroup/__internal, acceptedGroupKinds=mygroup/Foo, anothergroup/Bar</span><br><span class="line">KindForGroupVersionKinds(yetanother/v1/Baz, anothergroup/v1/Bar) -&gt; mygroup/__internal/Bar (matched preferred group/kind)</span><br></pre></td></tr></table></figure>

<p>那它到底有什么用呢？要知道我们前面讲类型注册时，注册进scheme的类型，可能会对应多个GVK，即typeToGVK，<code>multiGroupVersioner</code>的作用就是在这，在进行版本转换时，已知一个类型，找到多个GVK时，能够唯一的确定一个GVK：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apimachinery/pkg/runtime/scheme.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheme)</span></span> convertToVersion(<span class="built_in">copy</span> <span class="type">bool</span>, in Object, target GroupVersioner) (Object, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> t reflect.Type</span><br><span class="line">  t = reflect.TypeOf(in)</span><br><span class="line">  t = t.Elem()</span><br><span class="line">  kinds, ok := s.typeToGVK[t]</span><br><span class="line">  gvk, ok := target.KindForGroupVersionKinds(kinds)</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解了GroupVersioner的作用，再来看看 <code>CodecForVersions()</code> 这几个工厂方法，就是指定了做序列化的encoder或者decoder，以及目标版本，然后构造了一个能够处理版本转换的 <code>versioning.codec</code>，它就是这个工厂方法生产出来的Codec，再来具体看看它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apimachinery/pkg/runtime/serializer/versioning/versioning.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultingCodecForScheme</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  scheme *runtime.Scheme,</span></span></span><br><span class="line"><span class="params"><span class="function">  encoder runtime.Encoder,</span></span></span><br><span class="line"><span class="params"><span class="function">  decoder runtime.Decoder,</span></span></span><br><span class="line"><span class="params"><span class="function">  encodeVersion runtime.GroupVersioner,</span></span></span><br><span class="line"><span class="params"><span class="function">  decodeVersion runtime.GroupVersioner,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> runtime.Codec &#123;</span><br><span class="line">  <span class="keyword">return</span> NewCodec(encoder, decoder, runtime.UnsafeObjectConvertor(scheme), scheme, scheme, scheme, encodeVersion, decodeVersion, scheme.Name())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCodec</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  encoder runtime.Encoder,</span></span></span><br><span class="line"><span class="params"><span class="function">  decoder runtime.Decoder,</span></span></span><br><span class="line"><span class="params"><span class="function">  convertor runtime.ObjectConvertor,</span></span></span><br><span class="line"><span class="params"><span class="function">  creater runtime.ObjectCreater,</span></span></span><br><span class="line"><span class="params"><span class="function">  typer runtime.ObjectTyper,</span></span></span><br><span class="line"><span class="params"><span class="function">  defaulter runtime.ObjectDefaulter,</span></span></span><br><span class="line"><span class="params"><span class="function">  encodeVersion runtime.GroupVersioner,</span></span></span><br><span class="line"><span class="params"><span class="function">  decodeVersion runtime.GroupVersioner,</span></span></span><br><span class="line"><span class="params"><span class="function">  originalSchemeName <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> runtime.Codec &#123;</span><br><span class="line">  internal := &amp;codec&#123;</span><br><span class="line">    encoder:   encoder,</span><br><span class="line">    decoder:   decoder,</span><br><span class="line">    convertor: convertor,</span><br><span class="line">    creater:   creater,</span><br><span class="line">    typer:     typer,</span><br><span class="line">    defaulter: defaulter,</span><br><span class="line"></span><br><span class="line">    encodeVersion: encodeVersion,</span><br><span class="line">    decodeVersion: decodeVersion,</span><br><span class="line"></span><br><span class="line">    identifier: identifier(encodeVersion, encoder),</span><br><span class="line"></span><br><span class="line">    originalSchemeName: originalSchemeName,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> internal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> codec <span class="keyword">struct</span> &#123;</span><br><span class="line">  encoder   runtime.Encoder</span><br><span class="line">  decoder   runtime.Decoder</span><br><span class="line">  convertor runtime.ObjectConvertor</span><br><span class="line">  creater   runtime.ObjectCreater</span><br><span class="line">  typer     runtime.ObjectTyper</span><br><span class="line">  defaulter runtime.ObjectDefaulter</span><br><span class="line"></span><br><span class="line">  encodeVersion runtime.GroupVersioner</span><br><span class="line">  decodeVersion runtime.GroupVersioner</span><br><span class="line"></span><br><span class="line">  identifier runtime.Identifier</span><br><span class="line"></span><br><span class="line">  originalSchemeName <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>codec实例中的encoder, decoder就是用来做具体序列化工作的json/yaml/protobuf Serializer，而creater, typer, defaulter均是scheme，encodeVersion, decodeVersion则是目标版本，还有convertor本质上也是scheme，只是在外面又包了一层，最终进行版本转换，调用的是scheme的<code>UnsafeConvertToVersion()</code>方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apimachinery/pkg/runtime/helper.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> unsafeObjectConvertor <span class="keyword">struct</span> &#123;</span><br><span class="line">  *Scheme</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c unsafeObjectConvertor)</span></span> ConvertToVersion(in Object, outVersion GroupVersioner) (Object, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> c.Scheme.UnsafeConvertToVersion(in, outVersion)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnsafeObjectConvertor</span><span class="params">(scheme *Scheme)</span></span> ObjectConvertor &#123;</span><br><span class="line">  <span class="keyword">return</span> unsafeObjectConvertor&#123;scheme&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来大致看看这个codec提供的Encode和Decode方法的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apimachinery/pkg/runtime/serializer/versioning/versioning.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *codec)</span></span> doEncode(obj runtime.Object, w io.Writer, memAlloc runtime.MemoryAllocator) <span class="type">error</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  encodeFn := c.encoder.Encode</span><br><span class="line">  ......</span><br><span class="line">  out, err := c.convertor.ConvertToVersion(obj, c.encodeVersion)</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> encodeFn(out, w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *codec)</span></span> Decode(data []<span class="type">byte</span>, defaultGVK *schema.GroupVersionKind, into runtime.Object) (runtime.Object, *schema.GroupVersionKind, <span class="type">error</span>) &#123;</span><br><span class="line">  decodeInto := into</span><br><span class="line">  obj, gvk, err := c.decoder.Decode(data, defaultGVK, decodeInto)</span><br><span class="line">  <span class="keyword">if</span> into != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// perform defaulting if requested</span></span><br><span class="line">    <span class="keyword">if</span> c.defaulter != <span class="literal">nil</span> &#123;</span><br><span class="line">      c.defaulter.Default(obj)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Short-circuit conversion if the into object is same object</span></span><br><span class="line">    <span class="keyword">if</span> into == obj &#123;</span><br><span class="line">      <span class="keyword">return</span> into, gvk, strictDecodingErr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := c.convertor.Convert(obj, into, c.decodeVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, gvk, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> into, gvk, strictDecodingErr</span><br><span class="line">  &#125;  </span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Encode时，是先进行版本转换，然后再用encoder进行序列化，而Decode时，先用decoder进行反序列化，将字节类型的数据Decode到某一个版本的API对象中，然后再对其进行赋默认值操作，还有进行版本转换，转换到目标版本，版本转换就是调用到上面提到的 <code>unsafeObjectConvertor</code>，它又调用scheme中注册的各种版本转换方法进行转换了。</p>
<p>这个Codec虽然逻辑有点绕，但是总结来说，它做的工作就是利用Serializer + Scheme，来做序列化和版本转换的工作。</p>
<h2 id="Codec使用场景"><a href="#Codec使用场景" class="headerlink" title="Codec使用场景"></a>Codec使用场景</h2><p>我们再来看看Codec是怎么使用的，前面提到过，Codec在两个地方被用到：一个是客户端通过HTTP协议跟APIServer交互时，需要进行Codec，一个是将API对象存储到数据库时，需要进行Codec，我们来分别看下这两个场景是怎么用Codec的，简单走下代码的流程即可（Code Walk-through）。</p>
<h3 id="跟数据库进行交互"><a href="#跟数据库进行交互" class="headerlink" title="跟数据库进行交互"></a>跟数据库进行交互</h3><p>在 <a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/09/19/kubernetes/kube-apiserver-storage-overview.html">Kubernetes APIServer Storage 框架解析</a> 这篇文章中，就介绍过API对象是怎么存储到数据库中的，其中，在为每个API资源构建<code>etcd store</code>时，会通过 <code>DefaultStorageFactory</code> 来为其构建存储配置，而Codec相关的逻辑就在这：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apiserver/pkg/server/storage/storage_factory.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DefaultStorageFactory)</span></span> NewConfig(groupResource schema.GroupResource) (*storagebackend.Config, <span class="type">error</span>) &#123;</span><br><span class="line">    chosenStorageResource := s.getStorageGroupResource(groupResource)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operate on copy</span></span><br><span class="line">    storageConfig := s.StorageConfig</span><br><span class="line">    codecConfig := StorageCodecConfig&#123;</span><br><span class="line">        StorageMediaType:  s.DefaultMediaType,</span><br><span class="line">        StorageSerializer: s.DefaultSerializer,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> override, ok := s.Overrides[getAllResourcesAlias(chosenStorageResource)]; ok &#123;</span><br><span class="line">        override.Apply(&amp;storageConfig, &amp;codecConfig)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> override, ok := s.Overrides[chosenStorageResource]; ok &#123;</span><br><span class="line">        override.Apply(&amp;storageConfig, &amp;codecConfig)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    codecConfig.StorageVersion, err = s.ResourceEncodingConfig.StorageEncodingFor(chosenStorageResource)</span><br><span class="line">    codecConfig.MemoryVersion, err = s.ResourceEncodingConfig.InMemoryEncodingFor(groupResource)</span><br><span class="line">    codecConfig.Config = storageConfig</span><br><span class="line"></span><br><span class="line">    storageConfig.Codec, storageConfig.EncodeVersioner, err = s.newStorageCodecFn(codecConfig)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;storageConfig, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>codecConfig中会保存存储序列化相关的一些配置，<code>StorageMediaType</code>默认为 <code>application/vnd.kubernetes.protobuf</code>，而<code>StorageSerializer</code>则为 <code>legacyscheme.Codecs</code>，还有<code>StorageVersion</code>和<code>MemoryVersion</code>，分别表示该资源存储到数据库时使用的版本，以及加载到内存中使用的版本，我们来看看这两个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apiserver/pkg/server/storage/resource_encoding_config.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *DefaultResourceEncodingConfig)</span></span> StorageEncodingFor(resource schema.GroupResource) (schema.GroupVersion, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> !o.scheme.IsGroupRegistered(resource.Group) &#123;</span><br><span class="line">    <span class="keyword">return</span> schema.GroupVersion&#123;&#125;, fmt.Errorf(<span class="string">&quot;group %q is not registered in scheme&quot;</span>, resource.Group)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resourceOverride, resourceExists := o.resources[resource]</span><br><span class="line">  <span class="keyword">if</span> resourceExists &#123;</span><br><span class="line">    <span class="keyword">return</span> resourceOverride.ExternalResourceEncoding, <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return the most preferred external version for the group</span></span><br><span class="line">  <span class="keyword">return</span> o.scheme.PrioritizedVersionsForGroup(resource.Group)[<span class="number">0</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *DefaultResourceEncodingConfig)</span></span> InMemoryEncodingFor(resource schema.GroupResource) (schema.GroupVersion, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> !o.scheme.IsGroupRegistered(resource.Group) &#123;</span><br><span class="line">    <span class="keyword">return</span> schema.GroupVersion&#123;&#125;, fmt.Errorf(<span class="string">&quot;group %q is not registered in scheme&quot;</span>, resource.Group)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resourceOverride, resourceExists := o.resources[resource]</span><br><span class="line">  <span class="keyword">if</span> resourceExists &#123;</span><br><span class="line">    <span class="keyword">return</span> resourceOverride.InternalResourceEncoding, <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> schema.GroupVersion&#123;Group: resource.Group, Version: runtime.APIVersionInternal&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到存储使用的版本，是通过scheme的<code>PrioritizedVersionsForGroup()</code>方法获得的，这个方法我们在scheme中介绍过，是获取该组中所有的版本，他们会按照优先级排序，排在第一位的是优先级最高的，一般是稳定版本是优先级最高的，这里取第0个值，即取的是版本优先级最高的版本，而内存版本则是内部版本，version为 <code>__internal</code>，所谓内存版本是指从数据库读出来原始的数据之后，要转换成的版本。</p>
<p><code>NewConfig()</code>最终调用 <code>newStorageCodecFn(codecConfig)</code> 创建了Codec，我们来看看该方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apiserver/pkg/server/storage/storage_codec.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStorageCodec</span><span class="params">(opts StorageCodecConfig)</span></span> (runtime.Codec, runtime.GroupVersioner, <span class="type">error</span>) &#123;</span><br><span class="line">  mediaType, _, err := mime.ParseMediaType(opts.StorageMediaType)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%q is not a valid mime-type&quot;</span>, opts.StorageMediaType)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  supportedMediaTypes := opts.StorageSerializer.SupportedMediaTypes()</span><br><span class="line">  serializer, ok := runtime.SerializerInfoForMediaType(supportedMediaTypes, mediaType)</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    supportedMediaTypeList := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(supportedMediaTypes))</span><br><span class="line">    <span class="keyword">for</span> i, mediaType := <span class="keyword">range</span> supportedMediaTypes &#123;</span><br><span class="line">      supportedMediaTypeList[i] = mediaType.MediaType</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to find serializer for %q, supported media types: %v&quot;</span>, mediaType, supportedMediaTypeList)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  s := serializer.Serializer</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give callers the opportunity to wrap encoders and decoders.  For decoders, each returned decoder will</span></span><br><span class="line">  <span class="comment">// be passed to the recognizer so that multiple decoders are available.</span></span><br><span class="line">  <span class="keyword">var</span> encoder runtime.Encoder = s</span><br><span class="line">  <span class="keyword">if</span> opts.EncoderDecoratorFn != <span class="literal">nil</span> &#123;</span><br><span class="line">    encoder = opts.EncoderDecoratorFn(encoder)</span><br><span class="line">  &#125;</span><br><span class="line">  decoders := []runtime.Decoder&#123;</span><br><span class="line">    <span class="comment">// selected decoder as the primary</span></span><br><span class="line">    s,</span><br><span class="line">    <span class="comment">// universal deserializer as a fallback</span></span><br><span class="line">    opts.StorageSerializer.UniversalDeserializer(),</span><br><span class="line">    <span class="comment">// base64-wrapped universal deserializer as a last resort.</span></span><br><span class="line">    <span class="comment">// this allows reading base64-encoded protobuf, which should only exist if etcd2+protobuf was used at some point.</span></span><br><span class="line">    <span class="comment">// data written that way could exist in etcd2, or could have been migrated to etcd3.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> flag this type of data if we encounter it, require migration (read to decode, write to persist using a supported encoder), and remove in 1.8</span></span><br><span class="line">    runtime.NewBase64Serializer(<span class="literal">nil</span>, opts.StorageSerializer.UniversalDeserializer()),</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> opts.DecoderDecoratorFn != <span class="literal">nil</span> &#123;</span><br><span class="line">    decoders = opts.DecoderDecoratorFn(decoders)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  encodeVersioner := runtime.NewMultiGroupVersioner(</span><br><span class="line">    opts.StorageVersion,</span><br><span class="line">    schema.GroupKind&#123;Group: opts.StorageVersion.Group&#125;,</span><br><span class="line">    schema.GroupKind&#123;Group: opts.MemoryVersion.Group&#125;,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure the storage receives the correct version.</span></span><br><span class="line">  encoder = opts.StorageSerializer.EncoderForVersion(</span><br><span class="line">    encoder,</span><br><span class="line">    encodeVersioner,</span><br><span class="line">  )</span><br><span class="line">  decoder := opts.StorageSerializer.DecoderToVersion(</span><br><span class="line">    recognizer.NewDecoder(decoders...),</span><br><span class="line">    runtime.NewCoercingMultiGroupVersioner(</span><br><span class="line">      opts.MemoryVersion,</span><br><span class="line">      schema.GroupKind&#123;Group: opts.MemoryVersion.Group&#125;,</span><br><span class="line">      schema.GroupKind&#123;Group: opts.StorageVersion.Group&#125;,</span><br><span class="line">    ),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> runtime.NewCodec(encoder, decoder), encodeVersioner, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到的方法基本上就都是我们前面介绍过的了，首先根据MediaType拿到对应的Serializer，然后创建了GroupVersioner目标版本，目标版本分别是<code>codecConfig</code>中的数据库存储版本和内存版本，然后通过<code>StorageSerializer</code>，即<code>Codecs</code>，即<code>CodecFactory</code>，使用<code>EncoderForVersion()</code>, <code>DecoderToVersion()</code>工厂方法，构建出带版本转换的encoder和decoder，最后这两者再组装成一个新的Codec返回：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apimachinery/pkg/runtime/codec.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> codec <span class="keyword">struct</span> &#123;</span><br><span class="line">  Encoder</span><br><span class="line">  Decoder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCodec creates a Codec from an Encoder and Decoder.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCodec</span><span class="params">(e Encoder, d Decoder)</span></span> Codec &#123;</span><br><span class="line">  <span class="keyword">return</span> codec&#123;e, d&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个codec就是简单的封装，只是为了对外提供统一的接口而已，它就是最终<code>etcd store</code>对API对象进行数据库存储和读取时，使用到的Codec了，例如下例中的codec便是这里<code>NewCodec()</code>创建出来的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apiserver/pkg/storage/etcd3/store.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(codec runtime.Codec, versioner storage.Versioner, value []<span class="type">byte</span>, objPtr runtime.Object, rev <span class="type">int64</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> _, err := conversion.EnforcePtr(objPtr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to convert output object to pointer: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  _, _, err := codec.Decode(value, <span class="literal">nil</span>, objPtr)</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跟客户端进行交互"><a href="#跟客户端进行交互" class="headerlink" title="跟客户端进行交互"></a>跟客户端进行交互</h3><p>以GET某个API对象为例，在install GET请求的Handler时，构建了一个<code>reqScope</code>，它里面包含了跟序列化相关的变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apiserver/pkg/endpoints/installer.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *APIInstaller)</span></span> registerResourceHandlers(path <span class="type">string</span>, storage rest.Storage, ws *restful.WebService) (*metav1.APIResource, *storageversion.ResourceInfo, <span class="type">error</span>) &#123;</span><br><span class="line">  ......</span><br><span class="line">  fqKindToRegister, err := GetResourceKind(a.group.GroupVersion, storage, a.group.Typer)</span><br><span class="line">  ......</span><br><span class="line">  reqScope := handlers.RequestScope&#123;</span><br><span class="line">    Serializer:      a.group.Serializer, <span class="comment">// localscheme.Codecs</span></span><br><span class="line">    ParameterCodec:  a.group.ParameterCodec,</span><br><span class="line">    Creater:         a.group.Creater, <span class="comment">// scheme</span></span><br><span class="line">    Convertor:       a.group.Convertor, <span class="comment">// scheme</span></span><br><span class="line">    Defaulter:       a.group.Defaulter, <span class="comment">// scheme</span></span><br><span class="line">    Typer:           a.group.Typer, <span class="comment">// scheme</span></span><br><span class="line">    UnsafeConvertor: a.group.UnsafeConvertor, <span class="comment">// wrapper of scheme</span></span><br><span class="line">    Authorizer:      a.group.Authorizer,</span><br><span class="line">    ......</span><br><span class="line">    Kind:        fqKindToRegister,</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">switch</span> action.Verb &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;GET&quot;</span>: </span><br><span class="line">      <span class="keyword">var</span> handler restful.RouteFunction</span><br><span class="line">      handler = restfulGetResource(getter, reqScope)</span><br><span class="line">      ......</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fqKindToRegister</code>, <code>Kind</code>为该API资源所对应的GVK，是scheme根据<code>REST storage</code>从注册的类型中识别出来的，reqScope中的 <code>Serializer</code> 实际上是 <code>localscheme.Codecs</code>，<code>Creater, Convertor, Defaulter, Typeer, UnsafeConvertor</code>实际上都指向的是全局的scheme，最终，构造了GET Handler的入口函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apiserver/pkg/endpoints/handlers/get.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getResourceHandler</span><span class="params">(scope *RequestScope, getter getterFunc)</span></span> http.HandlerFunc &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    namespace, name, err := scope.Namer.Name(req)</span><br><span class="line">    ......</span><br><span class="line">    outputMediaType, _, err := negotiation.NegotiateOutputMediaType(req, scope.Serializer, scope)</span><br><span class="line">    ......</span><br><span class="line">    result, err := getter(ctx, name, req)</span><br><span class="line">    ......</span><br><span class="line">    transformResponseObject(ctx, scope, req, w, http.StatusOK, outputMediaType, result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>getter()</code>是从数据库中获取到对应name的API对象，并且进行了版本转换，转换成了内部版本，然后在 <code>transformResponseObject()</code> 方法中，又会根据outPutMediaType，以及scope中的Kind, Serializer等，将其转换为目标版本：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor/k8s.io/apiserver/pkg/endpoints/handlers/response.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transformResponseObject</span><span class="params">(ctx context.Context, scope *RequestScope, req *http.Request, w http.ResponseWriter, statusCode <span class="type">int</span>, mediaType negotiation.MediaTypeOptions, result runtime.Object)</span></span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  kind, serializer, _ := targetEncodingForTransform(scope, mediaType, req)</span><br><span class="line">  responsewriters.WriteObjectNegotiated(serializer, scope, kind.GroupVersion(), w, req, statusCode, obj, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kind即为目标GVK，serializer即为codecs，实际来自scope中的Serializer。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apiserver/pkg/endpoints/handlers/responsewriters/writers.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteObjectNegotiated</span><span class="params">(s runtime.NegotiatedSerializer, restrictions negotiation.EndpointRestrictions, gv schema.GroupVersion, w http.ResponseWriter, req *http.Request, statusCode <span class="type">int</span>, object runtime.Object, listGVKInContentType <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  mediaType, serializer, err := negotiation.NegotiateOutputMediaType(req, s, restrictions)</span><br><span class="line"></span><br><span class="line">  encoder := s.EncoderForVersion(serializer.Serializer, gv)</span><br><span class="line"></span><br><span class="line">  request.TrackSerializeResponseObjectLatency(req.Context(), <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> listGVKInContentType &#123;</span><br><span class="line">      SerializeObject(generateMediaTypeWithGVK(serializer.MediaType, mediaType.Convert), encoder, w, req, statusCode, object)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      SerializeObject(serializer.MediaType, encoder, w, req, statusCode, object)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SerializeObject</span><span class="params">(mediaType <span class="type">string</span>, encoder runtime.Encoder, hw http.ResponseWriter, req *http.Request, statusCode <span class="type">int</span>, object runtime.Object)</span></span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  err := encoder.Encode(object, w)</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>encoder := s.EncoderForVersion()</code> 则是调用了CodecFactory的工厂方法，创建了一个versioning.codec，然后调用 <code>encoder.Encode()</code> 进行序列化以及版本转换，然后将结果输出到HTTP ResponseWriter中，返回给客户端。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Codec承担着序列化的工作，除了做序列化，还承担着调用scheme的逻辑进行版本转换的工作，所以Codec其实也是实现API多版本的重要机制，跟Scheme可以说是相辅相成。本篇文章分析了Codec的实现原理，本质上Codec是一个工厂方法类，它会为各个API资源进行版本转换和序列化创建一个实例，然后会用在两个场景上，一个是通过HTTP协议跟客户端进行交互，一个是跟数据库进行交互，同时本篇文章也对Codec在这两个场景的相关代码进行了简单的梳理。</p>
<p>如果想更好的理解Codec在这两个场景的作用，就需要了解APIServer的框架以及存储框架，推荐阅读下列文章：</p>
<ul>
<li>在<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/08/09/kubernetes/kube-apiserver-overview.html">Kubernetes APIServer 机制概述</a>中我们介绍到了APIServer的本质其实是一个实现了RESTful API的WebServer，它使用golang的<a target="_blank" rel="noopener" href="https://golang.org/pkg/net/http/">net/http</a>的Server构建，并且Handler是其中非常重要的概念，此外，又简单介绍了APIServer的扩展机制，即Aggregator, APIExtensions以及KubeAPIServer这三者之间通过Delegation的方式实现了扩展。</li>
<li>在<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/09/19/kubernetes/kube-apiserver-storage-overview.html">Kubernetes APIServer Storage 框架解析</a>中，我们介绍了APIServer相关的存储框架，每个API对象，都有对应的<code>REST store</code>以及<code>etcd store</code>，它们是如何存储进数据库的。</li>
<li>在<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/10/05/kubernetes/kube-apiserver-genericapiserver.html">Kubernetes APIServer GenericAPIServer</a>中介绍了GenericAPIServer的作用，以及它的Handler是如何构建，API对象是如何以APIGroupInfo的形式注册进Handler中的，以及PostStartHook的机制。</li>
<li>在<a target="_blank" rel="noopener" href="https://hackerain.github.io/2020/10/06/kubernetes/kube-apiserver-api-resource-installation.html">Kubernetes APIServer API Resource Installation</a>中，介绍了KubeAPIServer, Aggregator, APIExtensions中的API对象资源是如何构建成<code>REST Store</code>，并且组织成<code>APIGroupInfo</code>，然后注册进GenericAPIServer中的，然后又盘点了下当前版本的Kubernetes中都有哪些API对象资源。</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Kubernetes API Codec 解析</p><p><a href="https://hackerain.me/2023/11/12/kubernetes/kube-versioning-codec.html">https://hackerain.me/2023/11/12/kubernetes/kube-versioning-codec.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>hackerain</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-11-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-11-12</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/kubernetes/">kubernetes</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/11/18/kubernetes/kube-controller-runtime.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Kubernetes controller-runtime 介绍</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/11/11/kubernetes/kube-versioning-scheme.html"><span class="level-item">Kubernetes API Scheme 解析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/assets/avatar.jpg" alt="开心BOY"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">开心BOY</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">45</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="/about" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/hackerain"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="知识星球" href="https://t.zsxq.com/0bWmBFDpu"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#概述"><span class="level-left"><span class="level-item">1</span><span class="level-item">概述</span></span></a></li><li><a class="level is-mobile" href="#Serializer"><span class="level-left"><span class="level-item">2</span><span class="level-item">Serializer</span></span></a></li><li><a class="level is-mobile" href="#CodecFactory"><span class="level-left"><span class="level-item">3</span><span class="level-item">CodecFactory</span></span></a></li><li><a class="level is-mobile" href="#Codec使用场景"><span class="level-left"><span class="level-item">4</span><span class="level-item">Codec使用场景</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#跟数据库进行交互"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">跟数据库进行交互</span></span></a></li><li><a class="level is-mobile" href="#跟客户端进行交互"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">跟客户端进行交互</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">5</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-18T00:00:00.000Z">2023-11-18</time></p><p class="title"><a href="/2023/11/18/kubernetes/kube-controller-runtime.html">Kubernetes controller-runtime 介绍</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-12T00:00:00.000Z">2023-11-12</time></p><p class="title"><a href="/2023/11/12/kubernetes/kube-versioning-codec.html">Kubernetes API Codec 解析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-11T00:00:00.000Z">2023-11-11</time></p><p class="title"><a href="/2023/11/11/kubernetes/kube-versioning-scheme.html">Kubernetes API Scheme 解析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-28T00:00:00.000Z">2023-10-28</time></p><p class="title"><a href="/2023/10/28/kubernetes/kube-versioning.html">Kubernetes API 多版本和序列化</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-26T00:00:00.000Z">2022-09-26</time></p><p class="title"><a href="/2022/09/26/elasticsearch/elasticsearch_large_text_field.html">Elasticsearch大文本字段(large text field)优化方案</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/"><span class="level-start"><span class="level-item">2017</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ceph/"><span class="tag">ceph</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/elasticsearch/"><span class="tag">elasticsearch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kubernetes/"><span class="tag">kubernetes</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/openstack/"><span class="tag">openstack</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/operations/"><span class="tag">operations</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/umi/"><span class="tag">umi</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/assets/logo.jpg" alt="开心BOY" height="28"></a><p class="is-size-7"><span>&copy; 2023 hackerain</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hackerain"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>